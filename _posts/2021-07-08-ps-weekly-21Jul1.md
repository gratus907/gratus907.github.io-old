---
layout: single
title: "7월 1-2주차 Weekly PS"
categories: algorithms
tags:
  - weekly-ps
sidebar:
  nav: "sidepost"
comment: true
comments : true
---
<div id="toc">
Contents
</div>
* TOC
{:toc}
----------

July 01 - July 11, 2021

## Recent Updates 
- 2021 UCPC에 (팀명은 미정) 참여할 예정입니다. 현재 계획된 팀원은 `dlwocks31` 과 `gyuni` 로, dlwocks31은 지난 2년간 PS를 같이 돌아왔었고 `gyuni`님과는 2019 UCPC쯤에 팀연습 스파링(?) 으로 만나본적이 있습니다.
- 2021 SCPC도 일단은 출전합니다. 

## Rounds 
### Atcoder Beginner Round 208
- [라운드 링크](https://atcoder.jp/contests/abc208/tasks)
- 420등, +4 (1840 -> 1844).
- D번까지 무난하게 풀었는데 E번 구현에서 너무 심하게 말렸습니다. 딱히 재밌지는 않고... F번은 좀 재밌는 수학문제같던데 E에 말려서 읽어보지도 못했네요.

### (Virtual) Codeforces Round 490 (Div.3)
- E번이 좀 재밌는 문제였습니다. 나머지는 딱히.

## Problems
집나간 실력을 되찾기 위한 목적으로 몇개 밀었습니다. 

### ICPC Mid Atlantic 2006, BOJ 1849 순열 
- $1, 2, \dots n$ 의 permutation을 찾는 문제인데, 각 $i$에 대해, $i$ 앞에 있는 수들 중 $i$보다 큰 수의 개수 $A_i$ 가 주어집니다.
- 기본적인 아이디어는, 각 $i$가 들어갈 위치를 찾아주는 것입니다. 1을 제외한 모든 수가 1보다 크기 때문에, $A_1$이 주어지면 1이 들어가야 할 위치를 그냥 알 수 있습니다. 1을 찾고 나면, 2는 남은 자리들 중 $A_2$번째 자리에 들어가야 한다는 것을 어렵지 않게 알 수 있습니다.
- 결국은 $1, 2, \dots n$ 에 대해, 이 집합에서 수를 하나 뽑아내고, 남아 있는 수들 중 $k$번째를 빠르게 구하는 자료구조가 필요합니다.
- Order statistics tree를 이용하여 $O(n \log n)$에 쉽게 해결할 수 있고, segment tree로도 같은 복잡도로 구현할 수 있습니다. 

### CERC 2010D, BOJ 3429 방어선 
- 수열 $A_i$가 하나 주어지고, 수열에서 **최장 길이의 연속하는 증가 부분** 을 찾는 문제입니다. 단, 딱 한 번 원래 수열에서 연속한 부분 하나를 들어낼 수 있습니다.
- 예를 들어, 5, 3, 4, 9, 2, 8, 6, 7, 1 에서 (9, 2, 8) 부분을 떼어내고 가운데 3, 4, 6, 7을 취하는 식입니다.
- `DP1[i]`, `DP2[i]` 를 각각 $i$번째를 오른쪽 / 왼쪽 끝으로 하는 최장 길이의 연속하는 증가 부분이라고 합시다. 이제, 우리가 원하는 값은 모든 $i < j$, $A_i < A_j$에 대해, $D_1(i) + D_2(j)$ 를 계산하여 이를 maximize하는 것입니다.
- 위 표현을 Naive하게 계산하려고 시도하면 '모든 $i < j$, $A_i < A_j$' 에서 이미 $O(n^2)$ 시간이 걸립니다.
- 대신, $A_i$가 큰 것부터 $D_2(i)$의 값들을 세그먼트 트리 같은 자료구조에 업데이트하고, 여기에 $[i, n]$ 구간의 최댓값을 쿼리하는 식으로 생각하면 $O(n \log n)$ 시간에 문제를 해결할 수 있습니다. 코어 로직의 코드는...
```cpp
for (int i = n-1; i >= 0; i--) {
        int u = arr[i].second;
        int q = s.query(u, n);
        s.modify(u, dp2[u]);
        dp[u] = dp1[u] + q;
        ans = max(ans, dp[u]);
    }
    cout << ans << '\n';
}
```
- `arr[i].second` 는 $A_i$ 순으로 정렬한 후 다시 인덱스를 가져오기 위함입니다. 대략적인 업데이트 순서는 바로 눈으로 보는 대로입니다. 
- 주의할 점은, $A_i = A_j$ 인 $i, j$가 없음이 보장되어있지 않기 때문에, 쿼리할 때 업데이트 순서를 조심해야 합니다. $A_i$가 같을 때 뭐부터 $D_2(i)$ 를 세그트리에 넣어주는지가 중요한데, $A_i = A_j$이면 $D_2(i)$의 유무가 후속하는 $j$ 쿼리에 영향을 줄 수 없도록, 왼쪽부터 업데이트해야 합니다.

### UCPC 2018 예선F, BOJ 15899 트리와 색깔
- 트리의 각 정점이 1부터 $C$ 사이의 색깔을 가지고 있고, $f(v, c)$ 를 $v$를 루트로 하는 서브트리에서 색깔이 $c$이하인 정점의 개수로 정의할 때 이를 빨리 계산하는 문제입니다.
- Euler Tour 라는 테크닉을 이용, 트리를 배열로 펴 주면 서브트리에 대한 쿼리가 우리가 잘 이해하고 있는 구간에 대한 쿼리로 바뀝니다.
- 쿼리를 오프라인 처리해서, 색깔이 작은 쿼리부터 처리하겠습니다.
- 이제, 색깔이 작은 것부터 업데이트하면서 중간중간 타이밍이 될때마다 쿼리를 처리해 주면 됩니다.


### BAPC 2005E, BOJ 5419 북서풍
- 전형적인 '스위핑 + 세그트리' 입니다. 
- 문제를 단순화하기 위해, 좌표평면에 N개의 점이 있고, 남동쪽 대신 북동쪽으로 간다고 생각해 봅시다. 좌표압축을 한다음 Y좌표들을 뒤집어 버리면 이렇게 만드는 것은 어렵지 않게 가능합니다. 
- 이제, 각 점들을 $(x_i, y_i)$ 라고 하고, 1차원 세그먼트 트리 하나를 만듭니다. 각 점을 세그트리의 $x_i$ 번 위치에 추가할 것입니다. 
- 우리가 원하는 것은, $(x_i, y_i)$에 서서 세그트리에 $[x_i, \infty]$ 쿼리를 날렸을때 여기서부터 북동쪽으로 갈수있는 점의 개수를 얻는 것입니다. 그러나 우리의 세그트리는 $y$좌표를 기억하지 않고 그냥 무작정 점의 개수를 세기 때문에, $y$좌표는 우리가 스위핑해야 합니다.
- $y$좌표가 큰 순서대로, 즉 위에서부터 세그트리에 점을 하나씩 넣으면서, 이 점까지 넣은 다음 동쪽을 바라보면 나보다 아래 (y좌표 기준) 점들을 아직 아예 추가가 되지 않았기 때문에 북동쪽 점들만 보이게 됩니다.

### 