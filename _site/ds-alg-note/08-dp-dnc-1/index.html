<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TNVQ3G5D5B"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TNVQ3G5D5B');
</script>

    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>VIII. Dynamic Programming &amp; Divide and Conquer (1) - Gratus907’s Study Note</title>
<meta name="description" content="Contents     Divide and Conquer           Merge Sort       빠른 거듭 제곱           Dynamic Programming           Memoization : Top Down DP       Bottom Up DP       DP 예시 : 2차원 경로 문제           Additional Topics / Problems    * 오늘은 특별한 알고리즘을 배우는 것이 아니라, ‘방법론’ 에 가깝기 때문에, Section과 Additional의 구분이 별로 없고 모두 소문제들로 구성되어 있습니다. 여기 나온 모든 소문제를 고민해 보길 권합니다.  Divide and Conquer  어떤 문제들은 문제 자체가 재귀적입니다. 즉, 어떤 커다란 문제 X를 풀기 위해, X를 여러 개의 작은 문제 $x_1, x_2, \dots x_k$로 나눈 다음, 각각을 풀고, 합칠 수 있습니다. 프로그래밍으로 생각해 보자면, 재귀함수를 쓰는 것이 자연스러운 문제들이 있습니다. 이러한 문제들에 대해, Divide and Conquer (분할 정복) 이라는 기법이 매우 유용합니다. 지금까지 여러분은 분할 정복을 쓰는 알고리즘을 상당히 많이 만나 보았기 때문에, 분할 정복이라는 말이 익숙하지 않더라도 생각하는 방법 자체는 그렇게 낯설지 않을 것입니다. 이 문제를 풀기 어렵지만, 작은 문제를 풀고 합치는 게 더 쉬울 수도 있다면, 분할 정복을 생각해 볼 수 있겠습니다.  Merge Sort  병합 정렬 (Merge Sort) 는 대표적인 분할 정복 기법입니다. 앞서 말한 분할 정복을 쓰는 이유가 가장 잘 나타납니다. $n$ 크기의 배열을 정렬하는 것보다, $n/2$ 크기의 배열 2개를 정렬하고, 두 정렬된 배열을 정렬성을 유지하면서 합치는 것이 더 빠르기 때문입니다. 아래 예시와 Additional (1), (2) 모두 분할 정복을 이용하는 훌륭한 예시입니다.  빠른 거듭 제곱  Divide and Conquer를 사용하는 다른 예시를 생각해 봅시다. 이번의 목표는, 어떤 수 $x$의 $y$제곱을 계산하는 일입니다. 상식적으로, 곱셈을 $y$ 번 하는 일이므로, $O(y)$에 하는 것이 자연스러워 보입니다. 암호학, 특히 RSA 암호 체계에서는 $x^y \pmod{p}$를 계산할 일이 매우 많은데, $y$가 거대한 수인 경우도 많이 있습니다. 만약 $10,702,103$의 $2,718,281,828$ 제곱 같은 것을 계산하려고 한다면, 어떨까요? 이때 우리는 ‘exponentiation by squaring’ 이라는 방법을 쓸 수 있습니다. 만약 $x^y$에서 $y$가 홀수라면, $x^{y-1} \times x$로 식을 정리합니다. 만약 $y$가 짝수라면, $(x^{y/2})^2$ 로 정리합니다. 이 방법이 $\order{\log y}$ 에 제곱을 수행한다는 사실을 생각해 봅시다.  Dynamic Programming  Memoization : Top Down DP  분할 정복은 정말 강력한 도구입니다. 예를 들어, 피보나치 수열도 분할 정복으로 계산할 수 있습니다. fib(n)을 계산하기 위해, fib(n-1) 과 fib(n-2)를 호출하면 됩니다. 그러나 이 방법의 시간 복잡도는 처참합니다. 호출되는 과정을 보면, $f(n)$ 은 한 번 호출하더라도, $f(1)$ 이나 $f(2)$ 같은 함수들을 수없이 많이 호출하고 있기 때문입니다. 우리는 이런 중복되는 과정을, 약간의 메모리를 이용하여, 한번만 계산하고 싶습니다. 이를 위해 사용하는 기법이 Memoization입니다.1 미리 배열 fib[]에, 매번 호출될 때마다 내가 계산한 값을 적어 놓습니다. 매번 함수가 호출될 때마다, 혹시 이 값이 내가 본 적 있는 값인지 메모지를 확인하고, 메모지에 적힌 값은 다시 계산하는 대신, 메모지를 보고 바로 답하는 것입니다. 함수 호출의 순서를 보면, 큰 값들 (TOP) 이 먼저 호출되고, 그 과정에서 작은 값들 (DOWN)의 값들의 계산이 필요함을 눈치챈 다음, 내려가면서 이 값들을 계산하고 다시 올라오면서 문제를 해결하는 과정을 볼 수 있습니다. 이 과정을 TOP-DOWN 방식의 Dynamic Programming 이라고 부릅니다.  Bottom Up DP  물론, 피보나치 수열을 계산하기 위해 꼭 저런 방식을 쓸 필요는 없습니다. 작은 값들을 이용해서 큰 값을 계산할 수만 있다면, 다음과 같이 간단하게 코딩해도 됩니다.         for (int i = 2; i&lt;=n; i++)     fib[i] = fib[i-1] + fib[i-2]       이 방법은, 계산 순서를 볼 때, 작은 값들을 먼저 계산해놓고 그걸 이용해서 위로 올라가며 계산하는 방법입니다. 이를 Bottom-UP 방식의 Dynamic Programming이라고 부릅니다. Top-Down과 Bottom-Up 중 무엇이 더 구현하기 편하고, 어느쪽이 유리한지는 그때그때 다르기 때문에, 상황에 따라 다른 방법을 사용해야 합니다. 중요한 것은 다음의 원칙입니다.          Optimal Substructure : 큰 문제 $f(X)$를 해결하기 위해, $f(Y)$ such that $Y &lt; X$의 답을 이용하는 것입니다.2 즉, 작은 문제의 답이 항상 더 큰 문제의 답을 제공하는데 도움이 되는 경우를 의미합니다. 이 조건은 Divide and Conquer과 Dynamic Programming 모두에 적용됩니다.           Overlapping Subproblem : 위 Overlapping Substructure를 적용함에 있어서, 겹치는 문제를 여러번 풀어야 해서 이를 최적화하고 싶은 경우를 의미합니다. Fibonacci가 대표적입니다. 이 원칙은 Dynamic Programming의 기본 원리입니다.      DP 예시 : 2차원 경로 문제  양수로 이루어진 $n \times n$ 행렬이 주어져 있습니다. 이때, 우리는 $(1, 1)$ 에서 출발하여, $(n, n)$ 위치까지 이동하되, 아래쪽 또는 오른쪽으로만 이동할 수 있습니다. 이동하는 과정에서, 행렬의 방문한 칸에 쓰여 있는 숫자들을 더한 값이 이 경로의 최종 점수입니다. 점수를 최대화하는 이동 경로를 찾아 봅시다. Optimal Substructure를 생각해 봅시다. 어떤 칸 $(i, j)$ 에 도착하기 위해서는, $(i-1, j)$ 또는 $(i, j-1)$ 에서 와야 합니다. 이때, $(i-1, j)$ 까지 어떻게 왔는지는 별로 관심이 없지만, 이 시점까지 온 점수가 최대가 되면 좋을 것 같습니다. 즉, 경로와 무관하게 일단 어떻게든 최선을 다해 $(i-1, j)$ 또는 $(i, j-1)$ 까지 왔다면, 그 경로들에서 한칸을 연장하여 $(i, j)$ 에 오는 최적 경로가 나타나기 때문입니다. 즉, 다음과 같은 DP를 구상합니다. (C_{ij} = \begin{cases}     0 &amp; \text{if } i = 0 \text{ or } j = 0     \max({C_{i-1, j}, C_{i, j-1}}) + M_{ij} &amp; \text{otherwise} \end{cases}) 만약 $C_{44}$를 계산하려고 한다면, $C_{34}$와 $C_{43}$ 을 계산해야하고, 그러면 $C_{33}, C_{24}, C_{33}, C_{42}$ 를 계산해야 합니다. 벌써 $C_{33}$ 을 두번 계산했습니다! Overlapping Substructure가 보입니다. 이를 최적화하여 계산해도 좋고, 아래와 같이 Bottom-Up DP를 생각해도 됩니다.          for (int i = 1; i&lt;=n; i++)     for (int j = 1; j&lt;=n; j++)         C[i][j] = M[i][j] + max(C[i-1][j], C[i][j-1]);       이렇게 하면 Dynamic Programming을 이용, $O(n^2)$ 에 계산하게 됩니다. 방금 본 것처럼, 2차원 그리드 위에서도 합리적인 DP 순서를 줄 수 있으면 (왼쪽 위부터 오른쪽 아래) 다이나믹 프로그래밍이 가능합니다. 이외에도 DP는 정말 다양한 형태로 등장하고, 유용하기 때문에 많은 연습이 필요합니다.  추천문제 : 아래 (3), (4), (5) 이후에도 더 풀어보고 싶다면, BOJ 기준 1005, 11066, 9251번을 확인해 보세요.  Additional Topics / Problems          Karatsuba Algorithm 우리가 곱셈은 $O(1)$에 수행된다고 믿었지만, 사실 생각해 보면 상식적으로 그럴 리가 없습니다. 10억 자리 수를 곱하는 일과 $3 \times 5$를 하는 일이 같은 시간에 수행될 리는 없기 때문입니다. 일상적으로 사용하는 수의 범위에서, 특히 C++의 int 나 long long 범위에서 곱셈이 자연스럽게 상수 비슷한 시간에 수행되기 때문에 우리는 앞으로도 $O(1)$에 기본 사칙연산이 작동한다는 믿음을 갖고 말하겠지만, 여기서는 잠깐만 이 부분을 의심해 봅시다. 다음 흐름을 따라가며, Karatsuba의 아이디어와, 이 아이디어를 처음 들었던 유명한 수학자 Kolmogorov3가 받았던 충격을 느껴봅시다.      (1) 초등학교에서 배운 방법대로 $139 \times 312$를 계산해 보고, 이     방법을 그대로 컴퓨터로 구현해 낸다면 $n$자리 수를 곱셈하는데     어느정도의 시간이 들지 예측해 보세요.      (2) 이하, $x, y$는 $B$진법의 $n$자리 수라고 합시다. 먼저, 적당한     $m &lt; n$을 골라, $x = x_1 B^m + x_0$, $y = y_1 B^m + y_0$ 이라고     씁시다. $m$을 $n$의 절반이 되게 고르면 됩니다.4      (3) 이제, $xy$ 가 $(x_1 B^m + x_0) (y_1 B^m + y_0)$ 이므로,     $x_1y_1 B^{2m} + (x_1y_0 + x_0y_1)B^m + x_0y_0$으로 나타납니다.     $x_1y_1, x_0y_0$은 그대로 계산하고, 가운데 항을 계산하는 대신,     $(x_1 + x_0) (y_1 + y_0)$을 계산하고 앞 두개를 빼면 같은 항을     얻습니다.      (4) 이 알고리즘의 시간 복잡도를 증명하세요. Week 1의 Master Theorem.           ($\star$)Closest Pair Problem : BOJ 2261 다음 문제를 고민하고 해결해 봅시다. $\R^2$ 상의 점 $n$개에 대하여, 가장 가까운 두 점 간의 거리를 찾고자 합니다. 조금 더 수학적으로는, $l = \min_{i, j} d(p_i, p_j)$ 을 찾는 문제입니다. 흐름을 따라가며, 분할 정복이 얼마나 강력한 툴인지 다시한번 느껴봅시다.      (1) 자명한 ‘쉬운 알고리즘’ 은 $O(n^2)$ 입니다. 우리는 이 문제에 대해     $O(n \log^2 n)$, 나아가 $O(n \log n)$ 알고리즘을 생각하려고     합니다.      (2) 먼저, Divide and Conquer를 생각하기 위해, $x$축을 기준으로     반으로 자르겠습니다.      (3) 그러면, [두 점이 왼쪽에 있는 경우], [두 점이 오른쪽에 있는     경우], [양쪽에서 하나씩 뽑는 경우] 를 각각 풀면 됩니다. 이     방법이 시간 복잡도에 전혀 발전이 없음을 보이세요.      (4) 그러나, [양쪽] 케이스를 정말 모두 확인해야 할까요? 얇은     Strip만 보면 충분함을 관찰하세요.      (5) Challenge 양쪽 케이스에서, Strip 안의 점 $p_i$에 대해, 최대     7번의 비교로 충분함을 보이세요.      (6) 이 방법의 시간 복잡도를 증명하고, 어떻게 더 줄일지 생각해     보세요.           행렬 곱셈 순서 : BOJ 11049 BOJ 11049번을 보고, 이 문제를 어떻게 해결할 수 있는지 생각해 봅시다.      (1) 단순하게는 풀 방법이 잘 떠오르지 않습니다. 하나 가능한 방법은     모든 가능한 행렬 곱셈 순서를 Naive하게 나열하고 확인하는 것인데,     이 방법에서 확인해야 할 곱셈 순서가 몇 가지일까요? 이걸 계산하는     문제는 상당히 어렵습니다. 언젠가 수학 세션을 하게 되면 생각해     보기로 합시다.      (2) 마지막 곱셈의 위치를 기준으로 생각해 봅시다.     마지막 곱셈의 위치가 $(A_1 A_2 \dots A_k)$와     $(A_{k+1} A_{k+2} \dots A_n)$ 을 곱하는 것일 때...      (3) DP[i][j] = i번째부터 j번째까지의 행렬을 최대한 잘 곱했을     때의 최소 비용 이라고 정의합시다. 점화식을 세워 보고, 그     점화식을 어떻게 빨리 계산할 수 있을지 고민해 보세요.           Knapsack Problem : BOJ 12865 이 문제는 매우 유명한 0-1 Knapsack이라는 문제입니다. 각 물품마다 $w_i$의 무게와 $v_i$의 가치가 있고, 가방에 무게가 $W$ 이하가 되게 넣어야 할 때 가치를 최대화하세요.      (1) Heuristic은 매우 중요한 알고리즘의 일부이지만 이 문제에서 먹히지     않습니다. 혹시 Naive하게 $v_i / w_i$ 가 최대인것부터     밀어넣는다는 생각을 하셨나요? 가방에 2의 무게만 넣을 수 있고,     무게가 1, 가치가 5인 물건과 무게가 2, 가치가 6인 물건이 있는     경우를 생각해 보세요.      (2) DP 문제를 접근하는 좋은 방법은, DP 테이블을 먼저 구상하는     것입니다. DP[i][j] 를 다음과 같이 정의할 때... 라고     시작합시다. 어떻게 정의해야 할까요? 힌트 : DP 칸수를 $N \times W$ 로 시도해 봅시다.           DP on data structures : BOJ 15681 고정관념을 버리면 쉽게 풀 수 있습니다. 루트 있는 트리에서, 노드 $x$에 대해, 그 노드를 루트로 하는 서브트리의 정점의 수를 빠르게 답하려면 어떻게 할까요?                      이 문제는 쿼리형 문제 라고 부르는 형태인데, “쿼리” 라고 불리는 “질문”이 $Q$개 주어지고 이 쿼리들에 답해야 하는 상황입니다. 자료구조에 대해 얘기할 때, OO에 대한 쿼리를 빠르게 처리하는 자료구조 라는 식으로 이해한 기억이 있을 것입니다.                       쿼리가 들어올 때마다 트리를 돌아보면서 대답하면, 한 쿼리를 해결하는 데 $O(n)$ 시간이 들고 (루트만 계속 물어볼 수도 있으니까), 전체 $O(qn)$ 시간이 든다는 의미입니다. 당연히 이 복잡도는 용납할 수 없습니다.                       쿼리당 $O(1)$ 에 해결하기 위해, 미리 시간을 좀 써서 전처리 (Preprocessing) 하고, 쿼리가 들어오면 그때그때 답해주면 어떨까요? 즉, $O(n + q)$ 에 해결하겠다는 의미입니다.                                 ‘기억하다’ 라는 뜻의 memorization이 아닙니다. ‘메모하다’ 라고 받아들여 주세요 &#8617;                 이렇게 써놓기는 했지만 $X, Y$가 수일 때만 사용가능한 것은 아닙니다. 합리적인 Order를 줄 수 있으면 되겠죠? &#8617;                 Andrey Kolmogorov. 주로 확률론을 연구했지만 알고리즘에도 상당히 많은 관심을 가졌던 수학자입니다 &#8617;                 아직 “$n$이 홀수면 어떻게 하지” 라는 고민이 든다면, Big-O Notation에 대한 “철학” 이 부족한 것입니다. ㅎㅎ &#8617;">


  <meta name="author" content="Wonseok Shin">
  
  <meta property="article:author" content="Wonseok Shin">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Gratus907's Study Note">
<meta property="og:title" content="VIII. Dynamic Programming &amp; Divide and Conquer (1)">
<meta property="og:url" content="http://localhost:4000/ds-alg-note/08-dp-dnc-1/">


  <meta property="og:description" content="Contents     Divide and Conquer           Merge Sort       빠른 거듭 제곱           Dynamic Programming           Memoization : Top Down DP       Bottom Up DP       DP 예시 : 2차원 경로 문제           Additional Topics / Problems    * 오늘은 특별한 알고리즘을 배우는 것이 아니라, ‘방법론’ 에 가깝기 때문에, Section과 Additional의 구분이 별로 없고 모두 소문제들로 구성되어 있습니다. 여기 나온 모든 소문제를 고민해 보길 권합니다.  Divide and Conquer  어떤 문제들은 문제 자체가 재귀적입니다. 즉, 어떤 커다란 문제 X를 풀기 위해, X를 여러 개의 작은 문제 $x_1, x_2, \dots x_k$로 나눈 다음, 각각을 풀고, 합칠 수 있습니다. 프로그래밍으로 생각해 보자면, 재귀함수를 쓰는 것이 자연스러운 문제들이 있습니다. 이러한 문제들에 대해, Divide and Conquer (분할 정복) 이라는 기법이 매우 유용합니다. 지금까지 여러분은 분할 정복을 쓰는 알고리즘을 상당히 많이 만나 보았기 때문에, 분할 정복이라는 말이 익숙하지 않더라도 생각하는 방법 자체는 그렇게 낯설지 않을 것입니다. 이 문제를 풀기 어렵지만, 작은 문제를 풀고 합치는 게 더 쉬울 수도 있다면, 분할 정복을 생각해 볼 수 있겠습니다.  Merge Sort  병합 정렬 (Merge Sort) 는 대표적인 분할 정복 기법입니다. 앞서 말한 분할 정복을 쓰는 이유가 가장 잘 나타납니다. $n$ 크기의 배열을 정렬하는 것보다, $n/2$ 크기의 배열 2개를 정렬하고, 두 정렬된 배열을 정렬성을 유지하면서 합치는 것이 더 빠르기 때문입니다. 아래 예시와 Additional (1), (2) 모두 분할 정복을 이용하는 훌륭한 예시입니다.  빠른 거듭 제곱  Divide and Conquer를 사용하는 다른 예시를 생각해 봅시다. 이번의 목표는, 어떤 수 $x$의 $y$제곱을 계산하는 일입니다. 상식적으로, 곱셈을 $y$ 번 하는 일이므로, $O(y)$에 하는 것이 자연스러워 보입니다. 암호학, 특히 RSA 암호 체계에서는 $x^y \pmod{p}$를 계산할 일이 매우 많은데, $y$가 거대한 수인 경우도 많이 있습니다. 만약 $10,702,103$의 $2,718,281,828$ 제곱 같은 것을 계산하려고 한다면, 어떨까요? 이때 우리는 ‘exponentiation by squaring’ 이라는 방법을 쓸 수 있습니다. 만약 $x^y$에서 $y$가 홀수라면, $x^{y-1} \times x$로 식을 정리합니다. 만약 $y$가 짝수라면, $(x^{y/2})^2$ 로 정리합니다. 이 방법이 $\order{\log y}$ 에 제곱을 수행한다는 사실을 생각해 봅시다.  Dynamic Programming  Memoization : Top Down DP  분할 정복은 정말 강력한 도구입니다. 예를 들어, 피보나치 수열도 분할 정복으로 계산할 수 있습니다. fib(n)을 계산하기 위해, fib(n-1) 과 fib(n-2)를 호출하면 됩니다. 그러나 이 방법의 시간 복잡도는 처참합니다. 호출되는 과정을 보면, $f(n)$ 은 한 번 호출하더라도, $f(1)$ 이나 $f(2)$ 같은 함수들을 수없이 많이 호출하고 있기 때문입니다. 우리는 이런 중복되는 과정을, 약간의 메모리를 이용하여, 한번만 계산하고 싶습니다. 이를 위해 사용하는 기법이 Memoization입니다.1 미리 배열 fib[]에, 매번 호출될 때마다 내가 계산한 값을 적어 놓습니다. 매번 함수가 호출될 때마다, 혹시 이 값이 내가 본 적 있는 값인지 메모지를 확인하고, 메모지에 적힌 값은 다시 계산하는 대신, 메모지를 보고 바로 답하는 것입니다. 함수 호출의 순서를 보면, 큰 값들 (TOP) 이 먼저 호출되고, 그 과정에서 작은 값들 (DOWN)의 값들의 계산이 필요함을 눈치챈 다음, 내려가면서 이 값들을 계산하고 다시 올라오면서 문제를 해결하는 과정을 볼 수 있습니다. 이 과정을 TOP-DOWN 방식의 Dynamic Programming 이라고 부릅니다.  Bottom Up DP  물론, 피보나치 수열을 계산하기 위해 꼭 저런 방식을 쓸 필요는 없습니다. 작은 값들을 이용해서 큰 값을 계산할 수만 있다면, 다음과 같이 간단하게 코딩해도 됩니다.         for (int i = 2; i&lt;=n; i++)     fib[i] = fib[i-1] + fib[i-2]       이 방법은, 계산 순서를 볼 때, 작은 값들을 먼저 계산해놓고 그걸 이용해서 위로 올라가며 계산하는 방법입니다. 이를 Bottom-UP 방식의 Dynamic Programming이라고 부릅니다. Top-Down과 Bottom-Up 중 무엇이 더 구현하기 편하고, 어느쪽이 유리한지는 그때그때 다르기 때문에, 상황에 따라 다른 방법을 사용해야 합니다. 중요한 것은 다음의 원칙입니다.          Optimal Substructure : 큰 문제 $f(X)$를 해결하기 위해, $f(Y)$ such that $Y &lt; X$의 답을 이용하는 것입니다.2 즉, 작은 문제의 답이 항상 더 큰 문제의 답을 제공하는데 도움이 되는 경우를 의미합니다. 이 조건은 Divide and Conquer과 Dynamic Programming 모두에 적용됩니다.           Overlapping Subproblem : 위 Overlapping Substructure를 적용함에 있어서, 겹치는 문제를 여러번 풀어야 해서 이를 최적화하고 싶은 경우를 의미합니다. Fibonacci가 대표적입니다. 이 원칙은 Dynamic Programming의 기본 원리입니다.      DP 예시 : 2차원 경로 문제  양수로 이루어진 $n \times n$ 행렬이 주어져 있습니다. 이때, 우리는 $(1, 1)$ 에서 출발하여, $(n, n)$ 위치까지 이동하되, 아래쪽 또는 오른쪽으로만 이동할 수 있습니다. 이동하는 과정에서, 행렬의 방문한 칸에 쓰여 있는 숫자들을 더한 값이 이 경로의 최종 점수입니다. 점수를 최대화하는 이동 경로를 찾아 봅시다. Optimal Substructure를 생각해 봅시다. 어떤 칸 $(i, j)$ 에 도착하기 위해서는, $(i-1, j)$ 또는 $(i, j-1)$ 에서 와야 합니다. 이때, $(i-1, j)$ 까지 어떻게 왔는지는 별로 관심이 없지만, 이 시점까지 온 점수가 최대가 되면 좋을 것 같습니다. 즉, 경로와 무관하게 일단 어떻게든 최선을 다해 $(i-1, j)$ 또는 $(i, j-1)$ 까지 왔다면, 그 경로들에서 한칸을 연장하여 $(i, j)$ 에 오는 최적 경로가 나타나기 때문입니다. 즉, 다음과 같은 DP를 구상합니다. (C_{ij} = \begin{cases}     0 &amp; \text{if } i = 0 \text{ or } j = 0     \max({C_{i-1, j}, C_{i, j-1}}) + M_{ij} &amp; \text{otherwise} \end{cases}) 만약 $C_{44}$를 계산하려고 한다면, $C_{34}$와 $C_{43}$ 을 계산해야하고, 그러면 $C_{33}, C_{24}, C_{33}, C_{42}$ 를 계산해야 합니다. 벌써 $C_{33}$ 을 두번 계산했습니다! Overlapping Substructure가 보입니다. 이를 최적화하여 계산해도 좋고, 아래와 같이 Bottom-Up DP를 생각해도 됩니다.          for (int i = 1; i&lt;=n; i++)     for (int j = 1; j&lt;=n; j++)         C[i][j] = M[i][j] + max(C[i-1][j], C[i][j-1]);       이렇게 하면 Dynamic Programming을 이용, $O(n^2)$ 에 계산하게 됩니다. 방금 본 것처럼, 2차원 그리드 위에서도 합리적인 DP 순서를 줄 수 있으면 (왼쪽 위부터 오른쪽 아래) 다이나믹 프로그래밍이 가능합니다. 이외에도 DP는 정말 다양한 형태로 등장하고, 유용하기 때문에 많은 연습이 필요합니다.  추천문제 : 아래 (3), (4), (5) 이후에도 더 풀어보고 싶다면, BOJ 기준 1005, 11066, 9251번을 확인해 보세요.  Additional Topics / Problems          Karatsuba Algorithm 우리가 곱셈은 $O(1)$에 수행된다고 믿었지만, 사실 생각해 보면 상식적으로 그럴 리가 없습니다. 10억 자리 수를 곱하는 일과 $3 \times 5$를 하는 일이 같은 시간에 수행될 리는 없기 때문입니다. 일상적으로 사용하는 수의 범위에서, 특히 C++의 int 나 long long 범위에서 곱셈이 자연스럽게 상수 비슷한 시간에 수행되기 때문에 우리는 앞으로도 $O(1)$에 기본 사칙연산이 작동한다는 믿음을 갖고 말하겠지만, 여기서는 잠깐만 이 부분을 의심해 봅시다. 다음 흐름을 따라가며, Karatsuba의 아이디어와, 이 아이디어를 처음 들었던 유명한 수학자 Kolmogorov3가 받았던 충격을 느껴봅시다.      (1) 초등학교에서 배운 방법대로 $139 \times 312$를 계산해 보고, 이     방법을 그대로 컴퓨터로 구현해 낸다면 $n$자리 수를 곱셈하는데     어느정도의 시간이 들지 예측해 보세요.      (2) 이하, $x, y$는 $B$진법의 $n$자리 수라고 합시다. 먼저, 적당한     $m &lt; n$을 골라, $x = x_1 B^m + x_0$, $y = y_1 B^m + y_0$ 이라고     씁시다. $m$을 $n$의 절반이 되게 고르면 됩니다.4      (3) 이제, $xy$ 가 $(x_1 B^m + x_0) (y_1 B^m + y_0)$ 이므로,     $x_1y_1 B^{2m} + (x_1y_0 + x_0y_1)B^m + x_0y_0$으로 나타납니다.     $x_1y_1, x_0y_0$은 그대로 계산하고, 가운데 항을 계산하는 대신,     $(x_1 + x_0) (y_1 + y_0)$을 계산하고 앞 두개를 빼면 같은 항을     얻습니다.      (4) 이 알고리즘의 시간 복잡도를 증명하세요. Week 1의 Master Theorem.           ($\star$)Closest Pair Problem : BOJ 2261 다음 문제를 고민하고 해결해 봅시다. $\R^2$ 상의 점 $n$개에 대하여, 가장 가까운 두 점 간의 거리를 찾고자 합니다. 조금 더 수학적으로는, $l = \min_{i, j} d(p_i, p_j)$ 을 찾는 문제입니다. 흐름을 따라가며, 분할 정복이 얼마나 강력한 툴인지 다시한번 느껴봅시다.      (1) 자명한 ‘쉬운 알고리즘’ 은 $O(n^2)$ 입니다. 우리는 이 문제에 대해     $O(n \log^2 n)$, 나아가 $O(n \log n)$ 알고리즘을 생각하려고     합니다.      (2) 먼저, Divide and Conquer를 생각하기 위해, $x$축을 기준으로     반으로 자르겠습니다.      (3) 그러면, [두 점이 왼쪽에 있는 경우], [두 점이 오른쪽에 있는     경우], [양쪽에서 하나씩 뽑는 경우] 를 각각 풀면 됩니다. 이     방법이 시간 복잡도에 전혀 발전이 없음을 보이세요.      (4) 그러나, [양쪽] 케이스를 정말 모두 확인해야 할까요? 얇은     Strip만 보면 충분함을 관찰하세요.      (5) Challenge 양쪽 케이스에서, Strip 안의 점 $p_i$에 대해, 최대     7번의 비교로 충분함을 보이세요.      (6) 이 방법의 시간 복잡도를 증명하고, 어떻게 더 줄일지 생각해     보세요.           행렬 곱셈 순서 : BOJ 11049 BOJ 11049번을 보고, 이 문제를 어떻게 해결할 수 있는지 생각해 봅시다.      (1) 단순하게는 풀 방법이 잘 떠오르지 않습니다. 하나 가능한 방법은     모든 가능한 행렬 곱셈 순서를 Naive하게 나열하고 확인하는 것인데,     이 방법에서 확인해야 할 곱셈 순서가 몇 가지일까요? 이걸 계산하는     문제는 상당히 어렵습니다. 언젠가 수학 세션을 하게 되면 생각해     보기로 합시다.      (2) 마지막 곱셈의 위치를 기준으로 생각해 봅시다.     마지막 곱셈의 위치가 $(A_1 A_2 \dots A_k)$와     $(A_{k+1} A_{k+2} \dots A_n)$ 을 곱하는 것일 때...      (3) DP[i][j] = i번째부터 j번째까지의 행렬을 최대한 잘 곱했을     때의 최소 비용 이라고 정의합시다. 점화식을 세워 보고, 그     점화식을 어떻게 빨리 계산할 수 있을지 고민해 보세요.           Knapsack Problem : BOJ 12865 이 문제는 매우 유명한 0-1 Knapsack이라는 문제입니다. 각 물품마다 $w_i$의 무게와 $v_i$의 가치가 있고, 가방에 무게가 $W$ 이하가 되게 넣어야 할 때 가치를 최대화하세요.      (1) Heuristic은 매우 중요한 알고리즘의 일부이지만 이 문제에서 먹히지     않습니다. 혹시 Naive하게 $v_i / w_i$ 가 최대인것부터     밀어넣는다는 생각을 하셨나요? 가방에 2의 무게만 넣을 수 있고,     무게가 1, 가치가 5인 물건과 무게가 2, 가치가 6인 물건이 있는     경우를 생각해 보세요.      (2) DP 문제를 접근하는 좋은 방법은, DP 테이블을 먼저 구상하는     것입니다. DP[i][j] 를 다음과 같이 정의할 때... 라고     시작합시다. 어떻게 정의해야 할까요? 힌트 : DP 칸수를 $N \times W$ 로 시도해 봅시다.           DP on data structures : BOJ 15681 고정관념을 버리면 쉽게 풀 수 있습니다. 루트 있는 트리에서, 노드 $x$에 대해, 그 노드를 루트로 하는 서브트리의 정점의 수를 빠르게 답하려면 어떻게 할까요?                      이 문제는 쿼리형 문제 라고 부르는 형태인데, “쿼리” 라고 불리는 “질문”이 $Q$개 주어지고 이 쿼리들에 답해야 하는 상황입니다. 자료구조에 대해 얘기할 때, OO에 대한 쿼리를 빠르게 처리하는 자료구조 라는 식으로 이해한 기억이 있을 것입니다.                       쿼리가 들어올 때마다 트리를 돌아보면서 대답하면, 한 쿼리를 해결하는 데 $O(n)$ 시간이 들고 (루트만 계속 물어볼 수도 있으니까), 전체 $O(qn)$ 시간이 든다는 의미입니다. 당연히 이 복잡도는 용납할 수 없습니다.                       쿼리당 $O(1)$ 에 해결하기 위해, 미리 시간을 좀 써서 전처리 (Preprocessing) 하고, 쿼리가 들어오면 그때그때 답해주면 어떨까요? 즉, $O(n + q)$ 에 해결하겠다는 의미입니다.                                 ‘기억하다’ 라는 뜻의 memorization이 아닙니다. ‘메모하다’ 라고 받아들여 주세요 &#8617;                 이렇게 써놓기는 했지만 $X, Y$가 수일 때만 사용가능한 것은 아닙니다. 합리적인 Order를 줄 수 있으면 되겠죠? &#8617;                 Andrey Kolmogorov. 주로 확률론을 연구했지만 알고리즘에도 상당히 많은 관심을 가졌던 수학자입니다 &#8617;                 아직 “$n$이 홀수면 어떻게 하지” 라는 고민이 든다면, Big-O Notation에 대한 “철학” 이 부족한 것입니다. ㅎㅎ &#8617;">







  <meta property="article:published_time" content="2021-08-25T00:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/ds-alg-note/08-dp-dnc-1/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Wonseok Shin",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Gratus907's Study Note Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

    <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'], ['\\(', '\\)']],
      packages: {'[+]': ['physics']}
    },
    loader: {
      load: ["input/tex", "output/chtml", '[tex]/physics']
    },
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<p style="display: none;">$$\newcommand{\Z}{\mathbb{Z}} \newcommand{\R}{\mathbb{R}} \newcommand{\Q}{\mathbb{Q}} \newcommand{\N}{\mathbb{N}}\newcommand{\C}{\mathbb{C}}  \newcommand{\oiv}[1]{\left] #1 \right[} \newcommand{\civ}[1]{\left[ #1 \right]} \newcommand{\ad}[1]{\text{ad}(#1)} \newcommand{\acc}[1]{\text{acc}(#1)} \newcommand{\Setcond}[2]{ \left\{\, #1 \mid #2 \, \right\}} \newcommand{\Set}[1]{ \left\{ #1 \right\}} \newcommand{\abs}[1]{ \left\lvert #1 \right\rvert}\newcommand{\prt}{\mathcal{P}}\newcommand{\st}{\text{ such that }}\newcommand{\for}{\text{ for }} \newcommand{\cl}[1]{\text{cl}(#1)}\newcommand{\oiv}[1]{\left] #1 \right[}\newcommand{\interior}[1]{\text{int}(#1)}\newcommand{\di}{\mathrel{|}}\newcommand{\limply}{\rightarrow}\newcommand{\fa}{\forall}\newcommand{\e}{\exists}\newcommand{\lxor}{\oplus}\newcommand{\liff}{\leftrightarrow}\newcommand{\lequiv}{\Leftrightarrow}\newcommand{\E}[1]{\mathbb{E}\left[#1\right]}\newcommand{\minimize}{\mathrm{minimize}}\newcommand{\subto}{\mathrm{subject\ to}}\newcommand{\minimize}{\mathrm{minimize}}
  \newcommand{\subto}{\mathrm{subject\ to}}
  \newcommand{\DKL}[2]{D_{\mathrm{KL}}\left(#1 \di\di #2\right)}
  \newcommand{\E}{\mathbb{E}}
  \newcommand{\expect}[1]{\E\left[#1\right]}
  \newcommand{\expectwith}[2]{\E_{#1}\left[#2\right]}
  \renewcommand{\P}{\mathbb{P}}
  \newcommand{\uniform}[2]{\mathrm{Uniform}\left(#1 \dots #2\right)}
  \newcommand{\sgn}{\text{sign}}
  \newcommand{\argmin}{\mathrm{argmin}}
  \newcommand{\argmax}{\mathrm{argmax}}
  \newcommand{\x}{\times}$$</p>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9M2LK7DWFS"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-9M2LK7DWFS');
    </script>
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Gratus907's Study Note
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/postings/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about-me/">About me</a>
            </li><li class="masthead__menu-item">
              <a href="/about-blog/">About Blog</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Wonseok Shin</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>2018- SNU CSE, interested in algorithms, mathematics</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">팔로우</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Seoul, Korea</span>
        </li>
      

      
        
          
        
          
        
          
            <li><a href="https://github.com/gratus907" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
      

      

      
        <li>
          <a href="mailto:gratus907@snu.ac.kr">
            <meta itemprop="email" content="gratus907@snu.ac.kr" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">이메일</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">토글 메뉴</label>
  <ul class="nav__items">
    
      <li>
        
          <a href="/cs-adventure/"><span class="nav__sub-title">CS 논문읽기</span></a>
        

        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Problem Solving</span>
        

        
        <ul>
          
            <li><a href="/ps-weekly/">PS Weekly</a></li>
          
            <li><a href="/find-contest/">문제 출처별로 보기</a></li>
          
            <li><a href="/ps-teatime/">PS Teatime</a></li>
          
            <li><a href="/competitive-programming-rounds/">Competitive Programming</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">주제별 노트정리</span>
        

        
        <ul>
          
            <li><a href="/ds-alg-note/">자료구조/알고리즘</a></li>
          
            <li><a href="/ds-alg-advanced/">고급 자료구조/알고리즘</a></li>
          
            <li><a href="/deep-learning-study/">Deep Learning Notes</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
    
    <nav class="toc">
      <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On This Page</h4></header>
      <ul class="toc__menu">
  <li><a href="#divide-and-conquer">Divide and Conquer</a>
    <ul>
      <li><a href="#merge-sort">Merge Sort</a></li>
      <li><a href="#빠른-거듭-제곱">빠른 거듭 제곱</a></li>
    </ul>
  </li>
  <li><a href="#dynamic-programming">Dynamic Programming</a>
    <ul>
      <li><a href="#memoization--top-down-dp">Memoization : Top Down DP</a></li>
      <li><a href="#bottom-up-dp">Bottom Up DP</a></li>
      <li><a href="#dp-예시--2차원-경로-문제">DP 예시 : 2차원 경로 문제</a></li>
    </ul>
  </li>
</ul>

    </nav>
    
    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="VIII. Dynamic Programming &amp; Divide and Conquer (1)">
    <meta itemprop="description" content="  Contents  Divide and Conquer          Merge Sort      빠른 거듭 제곱        Dynamic Programming          Memoization : Top Down DP      Bottom Up DP      DP 예시 : 2차원 경로 문제        Additional Topics / Problems* 오늘은 특별한 알고리즘을 배우는 것이 아니라, ‘방법론’ 에 가깝기때문에, Section과 Additional의 구분이 별로 없고 모두 소문제들로 구성되어있습니다. 여기 나온 모든 소문제를 고민해 보길 권합니다.Divide and Conquer어떤 문제들은 문제 자체가 재귀적입니다. 즉, 어떤 커다란 문제 X를풀기 위해, X를 여러 개의 작은 문제 $x_1, x_2, \dots x_k$로 나눈 다음,각각을 풀고, 합칠 수 있습니다. 프로그래밍으로 생각해 보자면, 재귀함수를쓰는 것이 자연스러운 문제들이 있습니다. 이러한 문제들에 대해, Divide andConquer (분할 정복) 이라는 기법이 매우 유용합니다.지금까지 여러분은 분할 정복을 쓰는 알고리즘을 상당히 많이 만나 보았기때문에, 분할 정복이라는 말이 익숙하지 않더라도 생각하는 방법 자체는그렇게 낯설지 않을 것입니다. 이 문제를 풀기 어렵지만, 작은 문제를 풀고합치는 게 더 쉬울 수도 있다면, 분할 정복을 생각해 볼 수 있겠습니다.Merge Sort병합 정렬 (Merge Sort) 는 대표적인 분할 정복 기법입니다. 앞서 말한 분할정복을 쓰는 이유가 가장 잘 나타납니다. $n$ 크기의 배열을 정렬하는것보다, $n/2$ 크기의 배열 2개를 정렬하고, 두 정렬된 배열을 정렬성을유지하면서 합치는 것이 더 빠르기 때문입니다.아래 예시와 Additional (1), (2) 모두 분할 정복을 이용하는 훌륭한예시입니다.빠른 거듭 제곱Divide and Conquer를 사용하는 다른 예시를 생각해 봅시다. 이번의 목표는,어떤 수 $x$의 $y$제곱을 계산하는 일입니다. 상식적으로, 곱셈을 $y$ 번하는 일이므로, $O(y)$에 하는 것이 자연스러워 보입니다.암호학, 특히 RSA 암호 체계에서는 $x^y \pmod{p}$를 계산할 일이 매우 많은데,$y$가 거대한 수인 경우도 많이 있습니다. 만약 $10,702,103$의$2,718,281,828$ 제곱 같은 것을 계산하려고 한다면, 어떨까요? 이때 우리는‘exponentiation by squaring’ 이라는 방법을 쓸 수 있습니다. 만약$x^y$에서 $y$가 홀수라면, $x^{y-1} \times x$로 식을 정리합니다. 만약$y$가 짝수라면, $(x^{y/2})^2$ 로 정리합니다. 이 방법이 $\order{\log y}$에 제곱을 수행한다는 사실을 생각해 봅시다.Dynamic ProgrammingMemoization : Top Down DP분할 정복은 정말 강력한 도구입니다. 예를 들어, 피보나치 수열도 분할정복으로 계산할 수 있습니다. fib(n)을 계산하기 위해, fib(n-1) 과fib(n-2)를 호출하면 됩니다. 그러나 이 방법의 시간 복잡도는 처참합니다.호출되는 과정을 보면, $f(n)$ 은 한 번 호출하더라도, $f(1)$ 이나 $f(2)$같은 함수들을 수없이 많이 호출하고 있기 때문입니다. 우리는 이런 중복되는과정을, 약간의 메모리를 이용하여, 한번만 계산하고 싶습니다.이를 위해 사용하는 기법이 Memoization입니다.1 미리 배열 fib[]에,매번 호출될 때마다 내가 계산한 값을 적어 놓습니다. 매번 함수가 호출될때마다, 혹시 이 값이 내가 본 적 있는 값인지 메모지를 확인하고, 메모지에적힌 값은 다시 계산하는 대신, 메모지를 보고 바로 답하는 것입니다.함수 호출의 순서를 보면, 큰 값들 (TOP) 이 먼저 호출되고, 그 과정에서작은 값들 (DOWN)의 값들의 계산이 필요함을 눈치챈 다음, 내려가면서 이값들을 계산하고 다시 올라오면서 문제를 해결하는 과정을 볼 수 있습니다.이 과정을 TOP-DOWN 방식의 Dynamic Programming 이라고 부릅니다.Bottom Up DP물론, 피보나치 수열을 계산하기 위해 꼭 저런 방식을 쓸 필요는 없습니다.작은 값들을 이용해서 큰 값을 계산할 수만 있다면, 다음과 같이 간단하게코딩해도 됩니다.      for (int i = 2; i&lt;=n; i++)    fib[i] = fib[i-1] + fib[i-2]  이 방법은, 계산 순서를 볼 때, 작은 값들을 먼저 계산해놓고 그걸 이용해서위로 올라가며 계산하는 방법입니다. 이를 Bottom-UP 방식의 DynamicProgramming이라고 부릅니다.Top-Down과 Bottom-Up 중 무엇이 더 구현하기 편하고, 어느쪽이 유리한지는그때그때 다르기 때문에, 상황에 따라 다른 방법을 사용해야 합니다. 중요한것은 다음의 원칙입니다.      Optimal Substructure : 큰 문제 $f(X)$를 해결하기 위해, $f(Y)$ suchthat $Y &lt; X$의 답을 이용하는 것입니다.2 즉, 작은 문제의 답이 항상더 큰 문제의 답을 제공하는데 도움이 되는 경우를 의미합니다. 이조건은 Divide and Conquer과 Dynamic Programming 모두에 적용됩니다.        Overlapping Subproblem : 위 Overlapping Substructure를 적용함에있어서, 겹치는 문제를 여러번 풀어야 해서 이를 최적화하고 싶은 경우를의미합니다. Fibonacci가 대표적입니다. 이 원칙은 DynamicProgramming의 기본 원리입니다.  DP 예시 : 2차원 경로 문제양수로 이루어진 $n \times n$ 행렬이 주어져 있습니다. 이때, 우리는$(1, 1)$ 에서 출발하여, $(n, n)$ 위치까지 이동하되, 아래쪽 또는오른쪽으로만 이동할 수 있습니다. 이동하는 과정에서, 행렬의 방문한 칸에쓰여 있는 숫자들을 더한 값이 이 경로의 최종 점수입니다. 점수를최대화하는 이동 경로를 찾아 봅시다.Optimal Substructure를 생각해 봅시다. 어떤 칸 $(i, j)$ 에 도착하기위해서는, $(i-1, j)$ 또는 $(i, j-1)$ 에서 와야 합니다. 이때, $(i-1, j)$까지 어떻게 왔는지는 별로 관심이 없지만, 이 시점까지 온 점수가 최대가되면 좋을 것 같습니다. 즉, 경로와 무관하게 일단 어떻게든 최선을 다해$(i-1, j)$ 또는 $(i, j-1)$ 까지 왔다면, 그 경로들에서 한칸을 연장하여$(i, j)$ 에 오는 최적 경로가 나타나기 때문입니다. 즉, 다음과 같은 DP를구상합니다. (C_{ij} = \begin{cases}    0 &amp; \text{if } i = 0 \text{ or } j = 0    \max({C_{i-1, j}, C_{i, j-1}}) + M_{ij} &amp; \text{otherwise}\end{cases}) 만약 $C_{44}$를 계산하려고 한다면, $C_{34}$와 $C_{43}$ 을계산해야하고, 그러면 $C_{33}, C_{24}, C_{33}, C_{42}$ 를 계산해야합니다. 벌써 $C_{33}$ 을 두번 계산했습니다! Overlapping Substructure가보입니다. 이를 최적화하여 계산해도 좋고, 아래와 같이 Bottom-Up DP를생각해도 됩니다.      for (int i = 1; i&lt;=n; i++)    for (int j = 1; j&lt;=n; j++)        C[i][j] = M[i][j] + max(C[i-1][j], C[i][j-1]);  이렇게 하면 Dynamic Programming을 이용, $O(n^2)$ 에 계산하게 됩니다.방금 본 것처럼, 2차원 그리드 위에서도 합리적인 DP 순서를 줄 수 있으면(왼쪽 위부터 오른쪽 아래) 다이나믹 프로그래밍이 가능합니다. 이외에도DP는 정말 다양한 형태로 등장하고, 유용하기 때문에 많은 연습이필요합니다.추천문제 : 아래 (3), (4), (5) 이후에도 더 풀어보고 싶다면, BOJ 기준1005, 11066, 9251번을 확인해 보세요.Additional Topics / Problems      Karatsuba Algorithm 우리가 곱셈은 $O(1)$에 수행된다고 믿었지만,사실 생각해 보면 상식적으로 그럴 리가 없습니다. 10억 자리 수를곱하는 일과 $3 \times 5$를 하는 일이 같은 시간에 수행될 리는 없기때문입니다. 일상적으로 사용하는 수의 범위에서, 특히 C++의 int 나long long 범위에서 곱셈이 자연스럽게 상수 비슷한 시간에 수행되기때문에 우리는 앞으로도 $O(1)$에 기본 사칙연산이 작동한다는 믿음을갖고 말하겠지만, 여기서는 잠깐만 이 부분을 의심해 봅시다. 다음흐름을 따라가며, Karatsuba의 아이디어와, 이 아이디어를 처음 들었던유명한 수학자 Kolmogorov3가 받았던 충격을 느껴봅시다.    (1) 초등학교에서 배운 방법대로 $139 \times 312$를 계산해 보고, 이    방법을 그대로 컴퓨터로 구현해 낸다면 $n$자리 수를 곱셈하는데    어느정도의 시간이 들지 예측해 보세요.    (2) 이하, $x, y$는 $B$진법의 $n$자리 수라고 합시다. 먼저, 적당한    $m &lt; n$을 골라, $x = x_1 B^m + x_0$, $y = y_1 B^m + y_0$ 이라고    씁시다. $m$을 $n$의 절반이 되게 고르면 됩니다.4    (3) 이제, $xy$ 가 $(x_1 B^m + x_0) (y_1 B^m + y_0)$ 이므로,    $x_1y_1 B^{2m} + (x_1y_0 + x_0y_1)B^m + x_0y_0$으로 나타납니다.    $x_1y_1, x_0y_0$은 그대로 계산하고, 가운데 항을 계산하는 대신,    $(x_1 + x_0) (y_1 + y_0)$을 계산하고 앞 두개를 빼면 같은 항을    얻습니다.    (4) 이 알고리즘의 시간 복잡도를 증명하세요. Week 1의 Master Theorem.        ($\star$)Closest Pair Problem : BOJ 2261다음 문제를 고민하고 해결해 봅시다. $\R^2$ 상의 점 $n$개에 대하여,가장 가까운 두 점 간의 거리를 찾고자 합니다. 조금 더 수학적으로는,$l = \min_{i, j} d(p_i, p_j)$ 을 찾는 문제입니다. 흐름을 따라가며,분할 정복이 얼마나 강력한 툴인지 다시한번 느껴봅시다.    (1) 자명한 ‘쉬운 알고리즘’ 은 $O(n^2)$ 입니다. 우리는 이 문제에 대해    $O(n \log^2 n)$, 나아가 $O(n \log n)$ 알고리즘을 생각하려고    합니다.    (2) 먼저, Divide and Conquer를 생각하기 위해, $x$축을 기준으로    반으로 자르겠습니다.    (3) 그러면, [두 점이 왼쪽에 있는 경우], [두 점이 오른쪽에 있는    경우], [양쪽에서 하나씩 뽑는 경우] 를 각각 풀면 됩니다. 이    방법이 시간 복잡도에 전혀 발전이 없음을 보이세요.    (4) 그러나, [양쪽] 케이스를 정말 모두 확인해야 할까요? 얇은    Strip만 보면 충분함을 관찰하세요.    (5) Challenge 양쪽 케이스에서, Strip 안의 점 $p_i$에 대해, 최대    7번의 비교로 충분함을 보이세요.    (6) 이 방법의 시간 복잡도를 증명하고, 어떻게 더 줄일지 생각해    보세요.        행렬 곱셈 순서 : BOJ 11049BOJ 11049번을 보고, 이 문제를 어떻게 해결할 수 있는지 생각해 봅시다.    (1) 단순하게는 풀 방법이 잘 떠오르지 않습니다. 하나 가능한 방법은    모든 가능한 행렬 곱셈 순서를 Naive하게 나열하고 확인하는 것인데,    이 방법에서 확인해야 할 곱셈 순서가 몇 가지일까요? 이걸 계산하는    문제는 상당히 어렵습니다. 언젠가 수학 세션을 하게 되면 생각해    보기로 합시다.    (2) 마지막 곱셈의 위치를 기준으로 생각해 봅시다.    마지막 곱셈의 위치가 $(A_1 A_2 \dots A_k)$와    $(A_{k+1} A_{k+2} \dots A_n)$ 을 곱하는 것일 때...    (3) DP[i][j] = i번째부터 j번째까지의 행렬을 최대한 잘 곱했을    때의 최소 비용 이라고 정의합시다. 점화식을 세워 보고, 그    점화식을 어떻게 빨리 계산할 수 있을지 고민해 보세요.        Knapsack Problem : BOJ 12865이 문제는 매우 유명한 0-1 Knapsack이라는 문제입니다. 각 물품마다$w_i$의 무게와 $v_i$의 가치가 있고, 가방에 무게가 $W$ 이하가 되게넣어야 할 때 가치를 최대화하세요.    (1) Heuristic은 매우 중요한 알고리즘의 일부이지만 이 문제에서 먹히지    않습니다. 혹시 Naive하게 $v_i / w_i$ 가 최대인것부터    밀어넣는다는 생각을 하셨나요? 가방에 2의 무게만 넣을 수 있고,    무게가 1, 가치가 5인 물건과 무게가 2, 가치가 6인 물건이 있는    경우를 생각해 보세요.    (2) DP 문제를 접근하는 좋은 방법은, DP 테이블을 먼저 구상하는    것입니다. DP[i][j] 를 다음과 같이 정의할 때... 라고    시작합시다. 어떻게 정의해야 할까요? 힌트 : DP 칸수를 $N \times W$ 로 시도해 봅시다.        DP on data structures : BOJ 15681고정관념을 버리면 쉽게 풀 수 있습니다. 루트 있는 트리에서, 노드$x$에 대해, 그 노드를 루트로 하는 서브트리의 정점의 수를 빠르게답하려면 어떻게 할까요?                  이 문제는 쿼리형 문제 라고 부르는 형태인데, “쿼리” 라고 불리는“질문”이 $Q$개 주어지고 이 쿼리들에 답해야 하는 상황입니다.자료구조에 대해 얘기할 때, OO에 대한 쿼리를 빠르게 처리하는자료구조 라는 식으로 이해한 기억이 있을 것입니다.                    쿼리가 들어올 때마다 트리를 돌아보면서 대답하면, 한 쿼리를해결하는 데 $O(n)$ 시간이 들고 (루트만 계속 물어볼 수도있으니까), 전체 $O(qn)$ 시간이 든다는 의미입니다. 당연히 이복잡도는 용납할 수 없습니다.                    쿼리당 $O(1)$ 에 해결하기 위해, 미리 시간을 좀 써서 전처리(Preprocessing) 하고, 쿼리가 들어오면 그때그때 답해주면어떨까요? 즉, $O(n + q)$ 에 해결하겠다는 의미입니다.                        ‘기억하다’ 라는 뜻의 memorization이 아닙니다. ‘메모하다’ 라고받아들여 주세요 &#8617;              이렇게 써놓기는 했지만 $X, Y$가 수일 때만 사용가능한 것은아닙니다. 합리적인 Order를 줄 수 있으면 되겠죠? &#8617;              Andrey Kolmogorov. 주로 확률론을 연구했지만 알고리즘에도 상당히많은 관심을 가졌던 수학자입니다 &#8617;              아직 “$n$이 홀수면 어떻게 하지” 라는 고민이 든다면, Big-ONotation에 대한 “철학” 이 부족한 것입니다. ㅎㅎ &#8617;      ">
    <meta itemprop="datePublished" content="2021-08-25T00:00:00+09:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">VIII. Dynamic Programming &amp; Divide and Conquer (1)
</h1>
          

  <p class="page__meta">
    

    
    

    
      
      
      
      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
          1548 words
      </span>
    
  </p>


        </header>
      
      <img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgratus907.github.io/ds-alg-note/08-dp-dnc-1/&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=hits&edge_flat=false"/></a> </div> <br/>
      <div style="display:none;"> <span id="busuanzi_container_site_pv" style="display:none;"><span id="busuanzi_value_site_pv" style="display:none;"></span></span></div>
      <section class="page__content" itemprop="text"> 
        <div id="toc">
  <p>Contents</p>
</div>
<ul id="markdown-toc">
  <li><a href="#divide-and-conquer" id="markdown-toc-divide-and-conquer">Divide and Conquer</a>    <ul>
      <li><a href="#merge-sort" id="markdown-toc-merge-sort">Merge Sort</a></li>
      <li><a href="#빠른-거듭-제곱" id="markdown-toc-빠른-거듭-제곱">빠른 거듭 제곱</a></li>
    </ul>
  </li>
  <li><a href="#dynamic-programming" id="markdown-toc-dynamic-programming">Dynamic Programming</a>    <ul>
      <li><a href="#memoization--top-down-dp" id="markdown-toc-memoization--top-down-dp">Memoization : Top Down DP</a></li>
      <li><a href="#bottom-up-dp" id="markdown-toc-bottom-up-dp">Bottom Up DP</a></li>
      <li><a href="#dp-예시--2차원-경로-문제" id="markdown-toc-dp-예시--2차원-경로-문제">DP 예시 : 2차원 경로 문제</a></li>
    </ul>
  </li>
  <li><a href="#additional-topics--problems" id="markdown-toc-additional-topics--problems">Additional Topics / Problems</a></li>
</ul>
<hr />

<p>* 오늘은 특별한 알고리즘을 배우는 것이 아니라, ‘방법론’ 에 가깝기
때문에, Section과 Additional의 구분이 별로 없고 모두 소문제들로 구성되어
있습니다. 여기 나온 모든 소문제를 고민해 보길 권합니다.</p>

<h2 id="divide-and-conquer">Divide and Conquer</h2>

<p>어떤 문제들은 문제 자체가 <strong>재귀적</strong>입니다. 즉, 어떤 커다란 문제 X를
풀기 위해, X를 여러 개의 작은 문제 $x_1, x_2, \dots x_k$로 나눈 다음,
각각을 풀고, 합칠 수 있습니다. 프로그래밍으로 생각해 보자면, 재귀함수를
쓰는 것이 자연스러운 문제들이 있습니다. 이러한 문제들에 대해, Divide and
Conquer (분할 정복) 이라는 기법이 매우 유용합니다.<br />
지금까지 여러분은 분할 정복을 쓰는 알고리즘을 상당히 많이 만나 보았기
때문에, 분할 정복이라는 말이 익숙하지 않더라도 생각하는 방법 자체는
그렇게 낯설지 않을 것입니다. 이 문제를 풀기 어렵지만, 작은 문제를 풀고
합치는 게 더 쉬울 수도 있다면, 분할 정복을 생각해 볼 수 있겠습니다.</p>

<h3 id="merge-sort">Merge Sort</h3>

<p>병합 정렬 (Merge Sort) 는 대표적인 분할 정복 기법입니다. 앞서 말한 분할
정복을 쓰는 이유가 가장 잘 나타납니다. $n$ 크기의 배열을 정렬하는
것보다, $n/2$ 크기의 배열 2개를 정렬하고, 두 정렬된 배열을 정렬성을
유지하면서 합치는 것이 더 빠르기 때문입니다.<br />
아래 예시와 Additional (1), (2) 모두 분할 정복을 이용하는 훌륭한
예시입니다.</p>

<h3 id="빠른-거듭-제곱">빠른 거듭 제곱</h3>

<p>Divide and Conquer를 사용하는 다른 예시를 생각해 봅시다. 이번의 목표는,
어떤 수 $x$의 $y$제곱을 계산하는 일입니다. 상식적으로, 곱셈을 $y$ 번
하는 일이므로, $O(y)$에 하는 것이 자연스러워 보입니다.<br />
암호학, 특히 RSA 암호 체계에서는 $x^y \pmod{p}$를 계산할 일이 매우 많은데,
$y$가 거대한 수인 경우도 많이 있습니다. 만약 $10,702,103$의
$2,718,281,828$ 제곱 같은 것을 계산하려고 한다면, 어떨까요? 이때 우리는
‘exponentiation by squaring’ 이라는 방법을 쓸 수 있습니다. 만약
$x^y$에서 $y$가 홀수라면, $x^{y-1} \times x$로 식을 정리합니다. 만약
$y$가 짝수라면, $(x^{y/2})^2$ 로 정리합니다. 이 방법이 $\order{\log y}$
에 제곱을 수행한다는 사실을 생각해 봅시다.</p>

<h2 id="dynamic-programming">Dynamic Programming</h2>

<h3 id="memoization--top-down-dp">Memoization : Top Down DP</h3>

<p>분할 정복은 정말 강력한 도구입니다. 예를 들어, 피보나치 수열도 분할
정복으로 계산할 수 있습니다. fib(n)을 계산하기 위해, fib(n-1) 과
fib(n-2)를 호출하면 됩니다. 그러나 이 방법의 시간 복잡도는 처참합니다.
호출되는 과정을 보면, $f(n)$ 은 한 번 호출하더라도, $f(1)$ 이나 $f(2)$
같은 함수들을 수없이 많이 호출하고 있기 때문입니다. 우리는 이런 중복되는
과정을, 약간의 메모리를 이용하여, 한번만 계산하고 싶습니다.<br />
이를 위해 사용하는 기법이 Memoization입니다.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup> 미리 배열 fib[]에,
매번 호출될 때마다 내가 계산한 값을 적어 놓습니다. 매번 함수가 호출될
때마다, 혹시 이 값이 내가 본 적 있는 값인지 메모지를 확인하고, 메모지에
적힌 값은 다시 계산하는 대신, 메모지를 보고 바로 답하는 것입니다.<br />
함수 호출의 순서를 보면, 큰 값들 (TOP) 이 먼저 호출되고, 그 과정에서
작은 값들 (DOWN)의 값들의 계산이 필요함을 눈치챈 다음, 내려가면서 이
값들을 계산하고 다시 올라오면서 문제를 해결하는 과정을 볼 수 있습니다.
이 과정을 TOP-DOWN 방식의 Dynamic Programming 이라고 부릅니다.</p>

<h3 id="bottom-up-dp">Bottom Up DP</h3>

<p>물론, 피보나치 수열을 계산하기 위해 꼭 저런 방식을 쓸 필요는 없습니다.
작은 값들을 이용해서 큰 값을 계산할 수만 있다면, 다음과 같이 간단하게
코딩해도 됩니다.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">fib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fib</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>이 방법은, 계산 순서를 볼 때, 작은 값들을 먼저 계산해놓고 그걸 이용해서
위로 올라가며 계산하는 방법입니다. 이를 Bottom-UP 방식의 Dynamic
Programming이라고 부릅니다.<br />
Top-Down과 Bottom-Up 중 무엇이 더 구현하기 편하고, 어느쪽이 유리한지는
그때그때 다르기 때문에, 상황에 따라 다른 방법을 사용해야 합니다. 중요한
것은 다음의 원칙입니다.</p>

<ul>
  <li>
    <p>Optimal Substructure : 큰 문제 $f(X)$를 해결하기 위해, $f(Y)$ such
that $Y &lt; X$의 답을 이용하는 것입니다.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup> 즉, 작은 문제의 답이 항상
더 큰 문제의 답을 제공하는데 도움이 되는 경우를 의미합니다. 이
조건은 Divide and Conquer과 Dynamic Programming 모두에 적용됩니다.</p>
  </li>
  <li>
    <p>Overlapping Subproblem : 위 Overlapping Substructure를 적용함에
있어서, 겹치는 문제를 여러번 풀어야 해서 이를 최적화하고 싶은 경우를
의미합니다. Fibonacci가 대표적입니다. 이 원칙은 Dynamic
Programming의 기본 원리입니다.</p>
  </li>
</ul>

<h3 id="dp-예시--2차원-경로-문제">DP 예시 : 2차원 경로 문제</h3>

<p>양수로 이루어진 $n \times n$ 행렬이 주어져 있습니다. 이때, 우리는
$(1, 1)$ 에서 출발하여, $(n, n)$ 위치까지 이동하되, 아래쪽 또는
오른쪽으로만 이동할 수 있습니다. 이동하는 과정에서, 행렬의 방문한 칸에
쓰여 있는 숫자들을 더한 값이 이 경로의 최종 점수입니다. 점수를
최대화하는 이동 경로를 찾아 봅시다.<br />
Optimal Substructure를 생각해 봅시다. 어떤 칸 $(i, j)$ 에 도착하기
위해서는, $(i-1, j)$ 또는 $(i, j-1)$ 에서 와야 합니다. 이때, $(i-1, j)$
까지 어떻게 왔는지는 별로 관심이 없지만, 이 시점까지 온 점수가 최대가
되면 좋을 것 같습니다. 즉, 경로와 무관하게 일단 어떻게든 최선을 다해
$(i-1, j)$ 또는 $(i, j-1)$ 까지 왔다면, 그 경로들에서 한칸을 연장하여
$(i, j)$ 에 오는 최적 경로가 나타나기 때문입니다. 즉, 다음과 같은 DP를
구상합니다. \(C_{ij} = \begin{cases}
    0 &amp; \text{if } i = 0 \text{ or } j = 0\\
    \max({C_{i-1, j}, C_{i, j-1}}) + M_{ij} &amp; \text{otherwise}
\end{cases}\) 만약 $C_{44}$를 계산하려고 한다면, $C_{34}$와 $C_{43}$ 을
계산해야하고, 그러면 $C_{33}, C_{24}, C_{33}, C_{42}$ 를 계산해야
합니다. 벌써 $C_{33}$ 을 두번 계산했습니다! Overlapping Substructure가
보입니다. 이를 최적화하여 계산해도 좋고, 아래와 같이 Bottom-Up DP를
생각해도 됩니다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div></div>

<p>이렇게 하면 Dynamic Programming을 이용, $O(n^2)$ 에 계산하게 됩니다.<br />
방금 본 것처럼, 2차원 그리드 위에서도 합리적인 DP 순서를 줄 수 있으면
(왼쪽 위부터 오른쪽 아래) 다이나믹 프로그래밍이 가능합니다. 이외에도
DP는 정말 다양한 형태로 등장하고, 유용하기 때문에 많은 연습이
필요합니다.</p>

<p>추천문제 : 아래 (3), (4), (5) 이후에도 더 풀어보고 싶다면, BOJ 기준
1005, 11066, 9251번을 확인해 보세요.</p>

<h1 id="additional-topics--problems">Additional Topics / Problems</h1>

<ol>
  <li>
    <p><strong>Karatsuba Algorithm</strong> 우리가 곱셈은 $O(1)$에 수행된다고 믿었지만,
사실 생각해 보면 상식적으로 그럴 리가 없습니다. 10억 자리 수를
곱하는 일과 $3 \times 5$를 하는 일이 같은 시간에 수행될 리는 없기
때문입니다. 일상적으로 사용하는 수의 범위에서, 특히 C++의 int 나
long long 범위에서 곱셈이 자연스럽게 상수 비슷한 시간에 수행되기
때문에 우리는 앞으로도 $O(1)$에 기본 사칙연산이 작동한다는 믿음을
갖고 말하겠지만, 여기서는 잠깐만 이 부분을 의심해 봅시다. 다음
흐름을 따라가며, Karatsuba의 아이디어와, 이 아이디어를 처음 들었던
유명한 수학자 Kolmogorov<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup>가 받았던 충격을 느껴봅시다.</p>

    <p>(1) 초등학교에서 배운 방법대로 $139 \times 312$를 계산해 보고, 이
    방법을 그대로 컴퓨터로 구현해 낸다면 $n$자리 수를 곱셈하는데
    어느정도의 시간이 들지 예측해 보세요.</p>

    <p>(2) 이하, $x, y$는 $B$진법의 $n$자리 수라고 합시다. 먼저, 적당한
    $m &lt; n$을 골라, $x = x_1 B^m + x_0$, $y = y_1 B^m + y_0$ 이라고
    씁시다. $m$을 $n$의 절반이 되게 고르면 됩니다.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">4</a></sup></p>

    <p>(3) 이제, $xy$ 가 $(x_1 B^m + x_0) (y_1 B^m + y_0)$ 이므로,
    $x_1y_1 B^{2m} + (x_1y_0 + x_0y_1)B^m + x_0y_0$으로 나타납니다.
    $x_1y_1, x_0y_0$은 그대로 계산하고, 가운데 항을 계산하는 대신,
    $(x_1 + x_0) (y_1 + y_0)$을 계산하고 앞 두개를 빼면 같은 항을
    얻습니다.</p>

    <p>(4) 이 알고리즘의 시간 복잡도를 증명하세요. Week 1의 Master Theorem.</p>
  </li>
  <li>
    <p>($\star$)<strong>Closest Pair Problem : BOJ 2261</strong><br />
다음 문제를 고민하고 해결해 봅시다. $\R^2$ 상의 점 $n$개에 대하여,
가장 가까운 두 점 간의 거리를 찾고자 합니다. 조금 더 수학적으로는,
$l = \min_{i, j} d(p_i, p_j)$ 을 찾는 문제입니다. 흐름을 따라가며,
분할 정복이 얼마나 강력한 툴인지 다시한번 느껴봅시다.</p>

    <p>(1) 자명한 ‘쉬운 알고리즘’ 은 $O(n^2)$ 입니다. 우리는 이 문제에 대해
    $O(n \log^2 n)$, 나아가 $O(n \log n)$ 알고리즘을 생각하려고
    합니다.</p>

    <p>(2) 먼저, Divide and Conquer를 생각하기 위해, $x$축을 기준으로
    반으로 자르겠습니다.</p>

    <p>(3) 그러면, [두 점이 왼쪽에 있는 경우], [두 점이 오른쪽에 있는
    경우], [양쪽에서 하나씩 뽑는 경우] 를 각각 풀면 됩니다. 이
    방법이 시간 복잡도에 전혀 발전이 없음을 보이세요.</p>

    <p>(4) 그러나, [양쪽] 케이스를 정말 모두 확인해야 할까요? 얇은
    Strip만 보면 충분함을 관찰하세요.</p>

    <p>(5) <strong>Challenge</strong> 양쪽 케이스에서, Strip 안의 점 $p_i$에 대해, 최대
    7번의 비교로 충분함을 보이세요.</p>

    <p>(6) 이 방법의 시간 복잡도를 증명하고, 어떻게 더 줄일지 생각해
    보세요.</p>
  </li>
  <li>
    <p><strong>행렬 곱셈 순서 : BOJ 11049</strong><br />
BOJ 11049번을 보고, 이 문제를 어떻게 해결할 수 있는지 생각해 봅시다.</p>

    <p>(1) 단순하게는 풀 방법이 잘 떠오르지 않습니다. 하나 가능한 방법은
    모든 가능한 행렬 곱셈 순서를 Naive하게 나열하고 확인하는 것인데,
    이 방법에서 확인해야 할 곱셈 순서가 몇 가지일까요? 이걸 계산하는
    문제는 상당히 어렵습니다. 언젠가 수학 세션을 하게 되면 생각해
    보기로 합시다.</p>

    <p>(2) 마지막 곱셈의 위치를 기준으로 생각해 봅시다.<br />
    마지막 곱셈의 위치가 $(A_1 A_2 \dots A_k)$와
    $(A_{k+1} A_{k+2} \dots A_n)$ 을 곱하는 것일 때...</p>

    <p>(3) DP[i][j] = i번째부터 j번째까지의 행렬을 최대한 잘 곱했을
    때의 최소 비용 이라고 정의합시다. 점화식을 세워 보고, 그
    점화식을 어떻게 빨리 계산할 수 있을지 고민해 보세요.</p>
  </li>
  <li>
    <p><strong>Knapsack Problem : BOJ 12865</strong><br />
이 문제는 매우 유명한 0-1 Knapsack이라는 문제입니다. 각 물품마다
$w_i$의 무게와 $v_i$의 가치가 있고, 가방에 무게가 $W$ 이하가 되게
넣어야 할 때 가치를 최대화하세요.</p>

    <p>(1) Heuristic은 매우 중요한 알고리즘의 일부이지만 이 문제에서 먹히지
    않습니다. 혹시 Naive하게 $v_i / w_i$ 가 최대인것부터
    밀어넣는다는 생각을 하셨나요? 가방에 2의 무게만 넣을 수 있고,
    무게가 1, 가치가 5인 물건과 무게가 2, 가치가 6인 물건이 있는
    경우를 생각해 보세요.</p>

    <p>(2) DP 문제를 접근하는 좋은 방법은, DP 테이블을 먼저 구상하는
    것입니다. DP[i][j] 를 다음과 같이 정의할 때... 라고
    시작합시다. 어떻게 정의해야 할까요? 힌트 : DP 칸수를 $N \times W$ 로 시도해 봅시다.</p>
  </li>
  <li>
    <p><strong>DP on data structures : BOJ 15681</strong><br />
고정관념을 버리면 쉽게 풀 수 있습니다. 루트 있는 트리에서, 노드
$x$에 대해, 그 노드를 루트로 하는 서브트리의 정점의 수를 빠르게
답하려면 어떻게 할까요?</p>

    <ul>
      <li>
        <p>이 문제는 쿼리형 문제 라고 부르는 형태인데, “쿼리” 라고 불리는
“질문”이 $Q$개 주어지고 이 쿼리들에 답해야 하는 상황입니다.
자료구조에 대해 얘기할 때, OO에 대한 쿼리를 빠르게 처리하는
자료구조 라는 식으로 이해한 기억이 있을 것입니다.</p>
      </li>
      <li>
        <p>쿼리가 들어올 때마다 트리를 돌아보면서 대답하면, 한 쿼리를
해결하는 데 $O(n)$ 시간이 들고 (루트만 계속 물어볼 수도
있으니까), 전체 $O(qn)$ 시간이 든다는 의미입니다. 당연히 이
복잡도는 용납할 수 없습니다.</p>
      </li>
      <li>
        <p>쿼리당 $O(1)$ 에 해결하기 위해, 미리 시간을 좀 써서 전처리
(Preprocessing) 하고, 쿼리가 들어오면 그때그때 답해주면
어떨까요? 즉, $O(n + q)$ 에 해결하겠다는 의미입니다.</p>
      </li>
    </ul>
  </li>
</ol>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>‘기억하다’ 라는 뜻의 memorization이 <strong>아닙니다</strong>. ‘메모하다’ 라고
받아들여 주세요 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>이렇게 써놓기는 했지만 $X, Y$가 수일 때만 사용가능한 것은
아닙니다. 합리적인 Order를 줄 수 있으면 되겠죠? <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Andrey Kolmogorov. 주로 확률론을 연구했지만 알고리즘에도 상당히
많은 관심을 가졌던 수학자입니다 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>아직 “$n$이 홀수면 어떻게 하지” 라는 고민이 든다면, Big-O
Notation에 대한 “철학” 이 부족한 것입니다. ㅎㅎ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

        
      </section>

      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#ds-alg-note" class="page__taxonomy-item" rel="tag">ds-alg-note</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time datetime="2021-08-25T00:00:00+09:00">August 25, 2021</time></p>


      </footer>
      
  <nav class="pagination">
    
      <a href="/ds-alg-note/06-bst-unionfind/" class="pagination--pager" title="VI. Binary Search Tree &amp; Union Find
">이전</a>
    
    
      <a href="/ds-alg-note/09-dp-dnc-2/" class="pagination--pager" title="IX. Dynamic Programming &amp; Divide and Conquer (2)
">다음</a>
    
  </nav>

      
      <div id="disqus_thread"></div>
      <script>
        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */

        var disqus_config = function () {
            this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://gratus907-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
    
    

    
      <div class="page__related">
        <h4 class="page__related-title">참고</h4>
        <div class="grid__wrapper">
          
            



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/deep-learning-study/softmax-regression/" rel="permalink">[P] Softmax Regression
</a>
      
    </h2>
    

  <p class="page__meta">
    

    
    

    
      
      
      
      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
          499 words
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
  Contents


  Softmax Regression



심층 신경망의 수학적 기초 6강 (9월 23일) 에 기반합니다.

이 글은 SVM과 Logistic Regression 링크 에 이어지는 내용입니다.

나중에 설명을 보강해서 다시 작성될 예정입니다.



데이터 ...</p>
  </article>
</div>

          
            



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/deep-learning-study/multilayer-perceptron/" rel="permalink">[P] Multi Layer Perceptron
</a>
      
    </h2>
    

  <p class="page__meta">
    

    
    

    
      
      
      
      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
          472 words
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
  Contents


  Linear Layer
  Multi Layer Perceptron
  Weight Initialization
  Gradient Computation : Back propagation



심층 신경망의 수학적 기초 6강 (9월 23일) 에 기반합니다...</p>
  </article>
</div>

          
            



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/cp-rounds/icpc-2021-prelim/" rel="permalink">ICPC Korea First Round 2021 후기 / 풀이
</a>
      
    </h2>
    

  <p class="page__meta">
    

    
    

    
      
      
      
      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
          3102 words
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
  Contents


  Preperation / Our Team
  본 대회    
      Problem I : Sport Climbing Combined
      Problem E : Histogram
      Problem J : Ten
      Problem H...</p>
  </article>
</div>

          
            



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/deep-learning-study/mnist-mlp/" rel="permalink">Softmax Regression / MLP로 MNIST 풀어보기
</a>
      
    </h2>
    

  <p class="page__meta">
    

    
    

    
      
      
      
      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
          747 words
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
  Contents


  Problem / Dataset
  Softmax Regression
  Multi-Layer Perceptron



심층 신경망의 수학적 기초 5강, 6강 (9월 16일, 23일) 에 기반합니다. 이번 내용은 대부분이 코드에 대한 내용이라서, $\L...</p>
  </article>
</div>

          
        </div>
      </div>
    
    
  </div>
</article>
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Wonseok Shin. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>. Version 06051a3b3b961ab25d3a3695579dd7b075a69858</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>





  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'G-TNVQ3G5D5B']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>







    <script>
    
    var elements = document.querySelectorAll('p');
    Array.prototype.forEach.call(elements, function(el, i){
        if(el.innerHTML=='[expand]') {
            var parentcontent = el.parentNode.innerHTML.replace('<p>[expand]</p>','<div class="expand" style="display: none; height: 0; overflow: hidden;">').replace('<p>[/expand]</p>','</div>');
            el.parentNode.innerHTML = parentcontent;
        }
    });

    var elements = document.querySelectorAll('div.expand');
    Array.prototype.forEach.call(elements, function(el, i){
        el.previousElementSibling.innerHTML = el.previousElementSibling.innerHTML + '<span>..&nbsp; <a href="#" style="cursor: pointer;" onclick="this.parentNode.parentNode.nextElementSibling.style.display = \'block\'; this.parentNode.parentNode.nextElementSibling.style.height = \'auto\'; this.parentNode.style.display = \'none\';">read&nbsp;more&nbsp;&rarr;</a></span>';
    });

</script>

  </body>
</html>
