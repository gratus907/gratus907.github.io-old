<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-07-14T21:18:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gratus907’s Study Note</title><subtitle>Hello World!</subtitle><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><entry><title type="html">2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1</title><link href="http://localhost:4000/cp_practice/team_practice_1/" rel="alternate" type="text/html" title="2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1" /><published>2021-07-14T00:00:00+09:00</published><updated>2021-07-14T00:00:00+09:00</updated><id>http://localhost:4000/cp_practice/team_practice_1</id><content type="html" xml:base="http://localhost:4000/cp_practice/team_practice_1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#our-team&quot; id=&quot;markdown-toc-our-team&quot;&gt;Our Team&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#practice--sogang-2020-div1&quot; id=&quot;markdown-toc-practice--sogang-2020-div1&quot;&gt;Practice : Sogang 2020 Div1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-0--start&quot; id=&quot;markdown-toc-phase-0--start&quot;&gt;Phase 0 : Start&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-1--easy-problems&quot; id=&quot;markdown-toc-phase-1--easy-problems&quot;&gt;Phase 1 : Easy Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#a-파일-정리&quot; id=&quot;markdown-toc-a-파일-정리&quot;&gt;A. 파일 정리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#f-폰친구&quot; id=&quot;markdown-toc-f-폰친구&quot;&gt;F. 폰친구&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#c-연료가-부족해&quot; id=&quot;markdown-toc-c-연료가-부족해&quot;&gt;C. 연료가 부족해&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#b-컨설팅&quot; id=&quot;markdown-toc-b-컨설팅&quot;&gt;B. 컨설팅&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-2--3-graph-problems&quot; id=&quot;markdown-toc-phase-2--3-graph-problems&quot;&gt;Phase 2 : 3 Graph Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#c-사탕-배달&quot; id=&quot;markdown-toc-c-사탕-배달&quot;&gt;C. 사탕 배달&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#a-에어컨-설치&quot; id=&quot;markdown-toc-a-에어컨-설치&quot;&gt;A. 에어컨 설치&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#g-confuzzle&quot; id=&quot;markdown-toc-g-confuzzle&quot;&gt;G. Confuzzle&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-3--pizza-madness&quot; id=&quot;markdown-toc-phase-3--pizza-madness&quot;&gt;Phase 3 : Pizza Madness&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#후기&quot; id=&quot;markdown-toc-후기&quot;&gt;후기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;our-team&quot;&gt;Our Team&lt;/h2&gt;
&lt;p&gt;이번 UCPC 팀은 이렇게 구성되게 되었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt; : DGIST에서 석사과정을 올 8월에 마무리하고 졸업합니다. ICPC는 석사 1년차까지, UCPC는 석사과정 (석박통합 2년차까지) 임을 감안하면 사실상 이번 UCPC가 대학생 프로그래밍 대회의 마지막을 장식하게 될 것인지라, 저 개인적으로 매우 영광으로 생각하고 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; : 병특 중에 있습니다. 제 블로그에도 여러번 언급되었지만… 해시코드를 함께하고 있는 Little Piplup 팀으로, 둘이서 1:1 연습을 많이 해봤습니다만 전통적인 CP대회를 같이뛰는건 처음입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세명의 Codeforces max rating은 2100+지만, 저랑 dlwocks는 파킹에 실패해서 퍼플로 낙하했습니다. 퍼플+퍼플+오렌지 팀 정도로 볼 수 있을것 같습니다.&lt;/p&gt;

&lt;p&gt;전력을 잠깐 생각해 보자면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님의 스타일은 제가 잘 모르지만 저랑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;은 동일 레이팅의 2인 팀치고는 아마도 꽤 강할 것 같습니다. 제가 상대적으로 조합/정수를 잘 풀고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;이 자료구조/구현 문제를 잘 풀다 보니… 그래서, 3인팀도 나름대로 스타일은 명확하고 잘 맞는것 같습니다.&lt;/p&gt;

&lt;p&gt;작년에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coffeetea&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diordhd&lt;/code&gt; 팀이 2020 ICPC 예선에서 12등인가 하는 놀라운 성적을 얻었는데, 객관적인 전력은 그 근처 어딘가라고 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;practice--sogang-2020-div1&quot;&gt;Practice : Sogang 2020 Div1&lt;/h2&gt;
&lt;p&gt;3시간 정도밖에 시간이 없어서, 돌만한 셋이 별로 없었습니다. Japan ICPC 예선전 정도가 3시간인데, 난이도가 널뛰기하는데다가 백준에서 푼사람이 아무도 없어서 데이터의 올바름을 확신하기 어렵기도 하고… 
서강대학교 대회는 Div 1 과 Div 2로 나뉘어 있고, 원래는 개인대회 3시간짜리 대회입니다. 난이도가 실-골-플-다 문제가 1-2-3-2로 분포된 형태가 UCPC 예선이랑 비슷할것이라고 판단, 이 대회를 3시간 3PC로 돌아보기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;phase-0--start&quot;&gt;Phase 0 : Start&lt;/h2&gt;
&lt;p&gt;리얼리티를 위해 문제 순서를 Random shuffle 하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni-gratus907-dlwocks31&lt;/code&gt; 순서로 3 3 2씩 나눠 읽기로 랬습니다.&lt;/p&gt;

&lt;h2 id=&quot;phase-1--easy-problems&quot;&gt;Phase 1 : Easy Problems&lt;/h2&gt;
&lt;h3 id=&quot;a-파일-정리&quot;&gt;A. 파일 정리&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; (00:07)
‘쉬운 구현문제니까 그냥 잡을게요’ 라고 말하고 7분에 AC를 받아왔습니다. 무슨문제인지 안읽어서 모르겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;f-폰친구&quot;&gt;F. 폰친구&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt; (00:30) 
재밌는 조합 문제였습니다.&lt;br /&gt;
$N$ 명에게 $K$ 개를 나눠주는데 1인당 $m$개 이상 $M$개 이하를 받는 경우의 수를 계산하는 문제입니다. 미리 $m$개씩 나눠주고 시작하면, $L = K - mN$ 개의 사탕을 $N$명에게 나눠주되 각자가 $x = M - m$ 개 이하로만 받는 경우의 수를 세면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저, $x$개 조건이 없다면 답은 중복조합을 이용하여 $_N H _L$ 개입니다. $x$개 조건은 여사건을 이용하여 계산할 수 있습니다. 반대로, ‘누가 $x+1$개 이상을 받을지’ 를 미리 정하고 갑시다. $u$명이 $x+1$개 이상을 받는다면, 미리 얘네들한테 $x+1$개씩 나눠주고 나머지들에게 사탕을 잘 나눠주는 경우를 생각하면 됩니다. 따라서, $_N H _{L - (x+1)u}$ 가 될 것입니다.&lt;/p&gt;

&lt;p&gt;그러나, 이 방법의 문제는 ‘나머지들에게 잘 나눠줄때’ 나머지들 중에 또 $x+1$개 이상을 받는 사람이 있을수도 있다는 것입니다. 이를 포함-배제 원리를 이용하여, 다음과 같이 처리하면 됩니다.
\(\sum_{u = 1}^{n} (-1)^u \times {_N C _u} \times {_N H _{L - (x + 1)u}}\)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;c-연료가-부족해&quot;&gt;C. 연료가 부족해&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt; (00:33, 1WA)
역시 쉬운문제라고 판단하고 30분 정도 시간에 AC를 받았습니다. DP였다고 합니다. 역시 무슨문제인지 안읽어서 잘 모르겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;b-컨설팅&quot;&gt;B. 컨설팅&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt; (00:58, 1WA)
쉬운 문제인데 구현이 귀찮아서 조금 시간이 걸렸습니다. 요점은, Greedy하게 정말 필요할때만 WAIT를 걸어주면 된다는 것을 어렵지 않게 알 수 있고, WRITE의 시작점들 / 도착점들 / (시작, 도착)Pair 들을 각각, READ의 대상을 하나. 이렇게 해서 집합들을 관리하고 조건을 잘 그대로 코딩하면 됩니다. 파이썬 썼는데 set같은걸 shallow copy한다는걸 까먹어서 1틀했습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;phase-2--3-graph-problems&quot;&gt;Phase 2 : 3 Graph Problems&lt;/h2&gt;
&lt;h3 id=&quot;c-사탕-배달&quot;&gt;C. 사탕 배달&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; (00:52, 1WA)
뭔지 잘 모르겠지만 트리에서 뭔가를 하는 문제입니다. 제가 파이썬 구현으로 싸우고 있는 사이에 팀원 두명이 AC를 받아왔습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;a-에어컨-설치&quot;&gt;A. 에어컨 설치&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt; (01:36)
문제는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$\Z^3$에 정점들이 뿌려져 있고 거리가 1인 정점들을 ‘인접하다’ 고 정의하여 그래프를 만듭니다.&lt;/li&gt;
  &lt;li&gt;그래프에 ‘에어컨’ 을 설치합니다. 이 에어컨 한 대는 설치한 정점과 그 인접한 정점을 커버합니다.&lt;/li&gt;
  &lt;li&gt;이제, 최소 개수의 에어컨을 달아서 모든 정점을 커버하는 문제입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;제가 B번을 맞고 갔을때는 이미 어느정도 둘이 솔루션을 discuss하고 있었던 중이었습니다. 여기에 같이 아이디어를 구상하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님이 코딩을 바로 들어갔습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;먼저, 어차피 각 connected component별로 생각해야 하므로 그래프가 연결되어 있다고 하겠습니다.&lt;/li&gt;
  &lt;li&gt;이제, 이 문제는 &lt;strong&gt;최소 버텍스 커버&lt;/strong&gt; 와 같은 문제임을 압니다.&lt;/li&gt;
  &lt;li&gt;이 문제는 NP-Complete이지만, 이분 그래프에 대해서는 빨리 풀 수 있음이 알려져 있습니다.&lt;/li&gt;
  &lt;li&gt;$(a, b, c)$ 에 대해, $a + b + c$의 홀짝성에 따라 정점에 색깔을 칠해주면 이 그래프가 이분 그래프임을 보일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;따라서, 이 그래프에서 최소 버텍스 커버를 짜면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저는 이걸 알아도 이분그래프에서 최소 버텍스 커버를 어떻게 짜는지 자신이 없었지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님이 그건 짤수 있다고 확신을 줬기 때문에 (:fan:) 맡기고 저랑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;은 남은 2문제를 잡으러 갔습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;코딩을 맡긴게 대략 01:00 시점쯤이고, 5AC에 1문제는 코딩만 남은 상황이었기 때문에 난이도에 대해 심각한 의심이 있었습니다. 실버 1, 골드 2, 플레 2문제 + 1문제 구상까지를 1시간에 밀었다는것도 그렇지만, 지금까지 문제들 중 플레급이라고 생각이 드는건 A번 정도였기 때문입니다. C번은 제가 직접 문제를 보지 않아서 뭐라고 할수가 없고, F번은 나중에 생각해보면 포함배제 쓰는 조합문제가 익숙하지 않다면 어려울것 같기도 합니다만 그럭저럭 꽤 많이 나온 스타일의 문제였지 않나 싶습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;g-confuzzle&quot;&gt;G. Confuzzle&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정점 $n$개의 트리가 주어지고, 각 노드가 $1 \leq c_i \leq n$ 의 색깔을 가집니다. 이때, 색깔이 같은 노드 페어 $v_i, v_j$들 중, 서로의 거리가 가장 가까운 노드 간의 거리를 계산하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;트리에서 두 정점 사이의 거리는 LCA를 이용하면 ($O(n \log n)$ 전처리를 하고) $O(\log n)$에 계산할 수 있습니다. Range Minimum Query를 잘 이용하면 $O(1)$에도 할 수 있음이 알려져 있지만, 실제로 이게 필요한 상황은 본적이 없는것 같습니다.&lt;/li&gt;
  &lt;li&gt;다만, 이때 $O(n^2)$ 개의 pair를 확인해야 하므로, $O(n^2 \log n)$ 시간이 걸리는데, 이는 도저히 답이 없는 복잡도입니다.&lt;/li&gt;
  &lt;li&gt;각 점마다 map에, “이 노드를 루트로 하는 서브트리에서, 색깔이 $c$ 인 노드들 중 이 노드에서 가장 가까운 노드까지의 거리” 를 저장한다고 생각합니다. 이를 $M_i$ 맵이라고 생각하겠습니다.&lt;/li&gt;
  &lt;li&gt;내 자녀 노드의 $M_i$들을 모두 알고 있다면, 이들을 합치는 과정에서 두개 이상의 서브트리가 같은 색깔의 노드를 가지고 있다면 이들까지의 거리를 이용하여 페어의 거리를 계산할 수 있습니다. 이 방법이 최단 거리 페어를 항상 찾을 수 있음은 서브트리에 대해 재귀적으로 증명 가능합니다.&lt;/li&gt;
  &lt;li&gt;그러나, 이 방법은 잘 생각해보면 맵을 합치는 데 $O(n \log n)$ 시간까지 걸리기 때문에, $O(n^2 \log n)$ 시간이 걸립니다.&lt;/li&gt;
  &lt;li&gt;트리에서 두 Map을 합치는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;small-to-large&lt;/code&gt; 테크닉을 적용 &lt;a href=&quot;/algorithms/BOJ4002/&quot;&gt;(ex : BOJ 4002번 풀이 링크)&lt;/a&gt; 하면, $O(n \log^2 n)$ 시간으로 줄일 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Small to Large 테크닉을 적용하자는 말을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;이 거의 5분만에 했고(:fan:), 10분만에 코딩했으나 사소한 실수로 디버깅에 40분이 걸렸습니다. 무려 $n^2 \log n$ 솔루션을 코딩해서 스트레스테스트로 반례를 찾아야만 했습니다. :(&lt;br /&gt;
별론으로, 정해가 상당히 멋집니다. 각 색깔에 대해 그 색깔의 노드가 몇개 없으면 ($k \leq \sqrt{n}$) $O(k^2 \log k)$ 알고리즘을 돌리고, 노드가 많으면 멀티소스 BFS를 돌리는… sqrt decomp스타일 아이디어였습니다.&lt;br /&gt;
하지만 여전히 dlwocks31의 스몰투라지가 복잡도면에서 더 좋은 풀이일 뿐 아니라, 코딩도 매우 간단합니다. :fan:&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;phase-3--pizza-madness&quot;&gt;Phase 3 : Pizza Madness&lt;/h2&gt;

&lt;p&gt;해결하지 못한 H번에 대한 이야기입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 수열 $A$와 작은 수열 $B$가 주어지고, $A$를 원형으로 연결했을 때 $B$에 해당하는 패턴을 매칭하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단, 패턴이 실제로 맞을 필요는 없고, ‘원소들 간의 순서’ 가 맞으면 됩니다. 예를 들어, (4, 3, 6) 과 (2, 1, 3) 을 매칭된 것으로 본다는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다양한 아이디어들이 등장했습니다. 각 수를 좌표압축해서, 좌표압축된 $n$개의 수를 라빈카프처럼 해싱하자는 아이디어라던가…&lt;/li&gt;
  &lt;li&gt;해싱된 수열의 일부를 오른쪽 / 왼쪽으로 미는 연산이 기존의 해싱에서 불가능합니다.&lt;/li&gt;
  &lt;li&gt;미는 부분이 구간을 연산한다는 점에 착안하여 각 노드가 구간의 라빈카프 해시값을 가지고 있는 세그먼트 트리 같은 아이디어가 나오고&lt;/li&gt;
  &lt;li&gt;세그먼트 트리도 중간에 노드를 날리지는 못하기 때문에, 여기에 무슨 스플레이 트리를 써서…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 이게 될리가 없습니다. 그렇게 한시간동안 셋이서 해괴한 트리들을 꺼내다가 연습을 종료했습니다.&lt;br /&gt;
결국 답은 KMP 알고리즘의 변형이던데, 꽤 멋진 문제인것 같네요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;비대면 팀연습이지만 굉장히 재밌었습니다. 배울것도 많았고..ㅋㅋㅋ 특히 작년 ICPC같은경우는 제가 나이로나 PS짬밥으로나 맏이였는데 이번에는 양쪽으로 다 막내인 팀이라서 (?) ㅋㅋㅋ 또 색다른 팀인듯 합니다.&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp_practice" /><summary type="html">Contents</summary></entry><entry><title type="html">논문읽기 : DELTACON</title><link href="http://localhost:4000/cs-adventure/deltacon/" rel="alternate" type="text/html" title="논문읽기 : DELTACON" /><published>2021-07-12T00:00:00+09:00</published><updated>2021-07-12T00:00:00+09:00</updated><id>http://localhost:4000/cs-adventure/deltacon</id><content type="html" xml:base="http://localhost:4000/cs-adventure/deltacon/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;처음으로 정리해볼 논문은 2013년 SDM(SIAM International Conference on Data Mining)에 발표된 DeltaCon입니다.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;두 그래프 $G_1 = (V_1, E_1), G_2 = (V_2, E_2)$ 가 주어졌을 때, 우리는 두 그래프의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유사도&lt;/code&gt; 를 측정하는 어떤 좋은 메트릭을 갖고 싶습니다. 이 메트릭이 있으면&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cs-adventure" /><category term="graph theory" /><summary type="html">Contents</summary></entry><entry><title type="html">7월 1-2주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21Jul1/" rel="alternate" type="text/html" title="7월 1-2주차 Weekly PS" /><published>2021-07-08T00:00:00+09:00</published><updated>2021-07-08T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21Jul1</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21Jul1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#recent-updates&quot; id=&quot;markdown-toc-recent-updates&quot;&gt;Recent Updates&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rounds&quot; id=&quot;markdown-toc-rounds&quot;&gt;Rounds&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#atcoder-beginner-round-208&quot; id=&quot;markdown-toc-atcoder-beginner-round-208&quot;&gt;Atcoder Beginner Round 208&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#virtual-codeforces-round-490-div3&quot; id=&quot;markdown-toc-virtual-codeforces-round-490-div3&quot;&gt;(Virtual) Codeforces Round 490 (Div.3)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problems&quot; id=&quot;markdown-toc-problems&quot;&gt;Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#icpc-mid-atlantic-2006-boj-1849-순열&quot; id=&quot;markdown-toc-icpc-mid-atlantic-2006-boj-1849-순열&quot;&gt;ICPC Mid Atlantic 2006, BOJ 1849 순열&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cerc-2010d-boj-3429-방어선&quot; id=&quot;markdown-toc-cerc-2010d-boj-3429-방어선&quot;&gt;CERC 2010D, BOJ 3429 방어선&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ucpc-2018-예선f-boj-15899-트리와-색깔&quot; id=&quot;markdown-toc-ucpc-2018-예선f-boj-15899-트리와-색깔&quot;&gt;UCPC 2018 예선F, BOJ 15899 트리와 색깔&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-14287-회사-문화-3&quot; id=&quot;markdown-toc-boj-14287-회사-문화-3&quot;&gt;BOJ 14287 회사 문화 3&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#bapc-2005e-boj-5419-북서풍&quot; id=&quot;markdown-toc-bapc-2005e-boj-5419-북서풍&quot;&gt;BAPC 2005E, BOJ 5419 북서풍&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sccc-2019e-boj-17131-여우가-정보섬에-올라온-이유&quot; id=&quot;markdown-toc-sccc-2019e-boj-17131-여우가-정보섬에-올라온-이유&quot;&gt;SCCC 2019E, BOJ 17131 여우가 정보섬에 올라온 이유&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-16993-연속합과-쿼리&quot; id=&quot;markdown-toc-boj-16993-연속합과-쿼리&quot;&gt;BOJ 16993, 연속합과 쿼리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#review&quot; id=&quot;markdown-toc-review&quot;&gt;Review&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;July 01 - July 11, 2021&lt;/p&gt;

&lt;h2 id=&quot;recent-updates&quot;&gt;Recent Updates&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2021 UCPC에 (팀명은 미정) 참여할 예정입니다. 현재 계획된 팀원은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt; 로, dlwocks31은 지난 2년간 PS를 같이 돌아왔었고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님과는 2019 UCPC쯤에 팀연습 스파링(?) 으로 만나본적이 있습니다.&lt;/li&gt;
  &lt;li&gt;2021 SCPC도 일단은 출전합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rounds&quot;&gt;Rounds&lt;/h2&gt;
&lt;h3 id=&quot;atcoder-beginner-round-208&quot;&gt;Atcoder Beginner Round 208&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc208/tasks&quot;&gt;라운드 링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;420등, +4 (1840 -&amp;gt; 1844).&lt;/li&gt;
  &lt;li&gt;D번까지 무난하게 풀었는데 E번 구현에서 너무 심하게 말렸습니다. 딱히 재밌지는 않고… F번은 좀 재밌는 수학문제같던데 E에 말려서 읽어보지도 못했네요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;virtual-codeforces-round-490-div3&quot;&gt;(Virtual) Codeforces Round 490 (Div.3)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;E번이 좀 재밌는 문제였습니다. 나머지는 딱히.&lt;/li&gt;
  &lt;li&gt;Directed Graph가 주어지고, 정점 $s$가 있어서 여기서 모든 점이 도달가능하기 위해 최소 개수의 간선을 추가하는 문항입니다. $n, m$은 5천으로 $O(nm)$ 풀이가 무난한 정도 크기.&lt;/li&gt;
  &lt;li&gt;모든 점에서 BFS를 돌아서 도달가능한 점들을 미리 계산하여, 각 점에서 도달가능한 집합 $R_i$를 들고있기로 합시다. 이제, $s$에서 도달 불가능한 점들을 $T$라고 하고, 어차피 도달가능한 점들은 의미가 없으므로 $R_i$ 대신 $R_i \cap T$를 생각함으로써 모든 $R_i \subset T$가 되게 합니다. 그러면 $R_i$들 중 최소 개수의 집합으로 $T$를 덮는 문제가 됩니다.&lt;/li&gt;
  &lt;li&gt;이는 set cover라는 매우 유명한 NP-complete 문제이므로 당연히 그대로는 풀 수 없습니다. 그러나, $R_i$들에 대해 순서가 존재함을 기억합시다.&lt;/li&gt;
  &lt;li&gt;$a$에서 $b$로 갈 수 있다면, $R_a$는 $R_b$를 포함합니다.&lt;/li&gt;
  &lt;li&gt;따라서, 서로 도달가능한 점들을 묶고 나면, 남은 $R$들은 set inclusion에 의해 어떤 partial order를 이룹니다.&lt;/li&gt;
  &lt;li&gt;어차피 점 한개를 먹는다면, partial order의 체인을 생각할때 무조건 각 체인의 가장 위에 있는 점들을 먹는것이 이득입니다.&lt;/li&gt;
  &lt;li&gt;이들을 어떻게 구분할 수 있을까요? 가장 간단한 방법은, $R_i$ 들 중 큰 것부터 먹으면 됩니다. 체인의 머리는 그 아래 노드들보다 크므로, 이렇게 하면 머리를 안 먹은 체인에서 아래 노드를 먹을 일은 없습니다. 머리를 이미 먹었는데 그 아래 노드를 먹는 일을 방지하기 위해, 노드를 먹으면서 그 노드에서 도달가능한 ($R_i$에 포함된) 모든 정점들은 지웁니다.&lt;/li&gt;
  &lt;li&gt;이 방법이 왜 정당한지 증명은 어렵지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://codeforces.com/contest/999/submission/122143517&quot;&gt;구현 링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;별개로, SCC를 잘 활용하면 직접 모든 점에서 BFS를 돌지 않는 Linear time 풀이가 있다고 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;
&lt;p&gt;집나간 실력을 되찾기 위한 목적으로 몇개 밀었습니다. 주로 세그먼트 트리 문제를 밀기로 했습니다 :)&lt;/p&gt;

&lt;p&gt;세그먼트 트리 구현은 재귀 트리와 비재귀 트리를 섞어 쓰는 편입니다. 간단히 논의하자면, 양쪽에는 다음과 같은 장단점이 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;재귀트리는 밑바닥부터 제가 짰기 때문에, 동작을 보다 정확하게 이해하고 있어 변형문제를 풀기에 편합니다.&lt;/li&gt;
  &lt;li&gt;재귀트리가 근본적으로 (Fundamentally의 좋은 번역어가 떠오르지 않네요) 좀더 직관적입니다.&lt;/li&gt;
  &lt;li&gt;반면, 비재귀트리는 확실히 더 빠릅니다. 상수가 영향을 주는 문제를 많이 본적은 없지만, $O(n \log n)$ 솔루션이 있는 문제의 경우 가끔 빠른 $O(n \log^2 n)$은 통과하고 똑같은 솔루션에 상수가 크면 짤립니다. 이떄 가끔 유용합니다.&lt;/li&gt;
  &lt;li&gt;비재귀트리는 널리 알려진 구현체인 &lt;a href=&quot;https://codeforces.com/blog/entry/18051&quot;&gt;Efficient and Easy Segment Trees&lt;/a&gt; 를 가져와서 조금 고쳐 쓰고 있습니다. 많은 사람들이 공유하는 라이브러리를 쓴다는 것은 그 자체로 장점입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;제가 쓰는 재귀트리 구현체는 쿼리를 $[l, r]$ 에다 날리고, 비재귀트리 구현체는 가져온 코드라서 $[l, r)$ 에다 날립니다. 혹시 제 코드를 보실일이 있다면 참고해주세요..? ㅋㅋㅋ&lt;/p&gt;

&lt;h3 id=&quot;icpc-mid-atlantic-2006-boj-1849-순열&quot;&gt;ICPC Mid Atlantic 2006, BOJ 1849 순열&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 : Platinum 4&lt;/li&gt;
  &lt;li&gt;$1, 2, \dots n$ 의 permutation을 찾는 문제인데, 각 $i$에 대해, $i$ 앞에 있는 수들 중 $i$보다 큰 수의 개수 $A_i$ 가 주어집니다.&lt;/li&gt;
  &lt;li&gt;기본적인 아이디어는, 각 $i$가 들어갈 위치를 찾아주는 것입니다. 1을 제외한 모든 수가 1보다 크기 때문에, $A_1$이 주어지면 1이 들어가야 할 위치를 그냥 알 수 있습니다. 1을 찾고 나면, 2는 남은 자리들 중 $A_2$번째 자리에 들어가야 한다는 것을 어렵지 않게 알 수 있습니다.&lt;/li&gt;
  &lt;li&gt;결국은 $1, 2, \dots n$ 에 대해, 이 집합에서 수를 하나 뽑아내고, 남아 있는 수들 중 $k$번째를 빠르게 구하는 자료구조가 필요합니다.&lt;/li&gt;
  &lt;li&gt;Order statistics tree를 이용하여 $O(n \log n)$에 쉽게 해결할 수 있고, segment tree로도 같은 복잡도로 구현할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cerc-2010d-boj-3429-방어선&quot;&gt;CERC 2010D, BOJ 3429 방어선&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 : Platinum 4&lt;/li&gt;
  &lt;li&gt;수열 $A_i$가 하나 주어지고, 수열에서 &lt;strong&gt;최장 길이의 연속하는 증가 부분&lt;/strong&gt; 을 찾는 문제입니다. 단, 딱 한 번 원래 수열에서 연속한 부분 하나를 들어낼 수 있습니다.&lt;/li&gt;
  &lt;li&gt;예를 들어, 5, 3, 4, 9, 2, 8, 6, 7, 1 에서 (9, 2, 8) 부분을 떼어내고 가운데 3, 4, 6, 7을 취하는 식입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DP1[i]&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DP2[i]&lt;/code&gt; 를 각각 $i$번째를 오른쪽 / 왼쪽 끝으로 하는 최장 길이의 연속하는 증가 부분이라고 합시다. 이제, 우리가 원하는 값은 모든 $i &amp;lt; j$, $A_i &amp;lt; A_j$에 대해, $D_1(i) + D_2(j)$ 를 계산하여 이를 maximize하는 것입니다.&lt;/li&gt;
  &lt;li&gt;위 표현을 Naive하게 계산하려고 시도하면 ‘모든 $i &amp;lt; j$, $A_i &amp;lt; A_j$’ 에서 이미 $O(n^2)$ 시간이 걸립니다.&lt;/li&gt;
  &lt;li&gt;대신, $A_i$가 큰 것부터 $D_2(i)$의 값들을 세그먼트 트리 같은 자료구조에 업데이트하고, 여기에 $[i, n]$ 구간의 최댓값을 쿼리하는 식으로 생각하면 $O(n \log n)$ 시간에 문제를 해결할 수 있습니다. 코어 로직의 코드는…
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arr[i].second&lt;/code&gt; 는 $A_i$ 순으로 정렬한 후 다시 인덱스를 가져오기 위함입니다. 대략적인 업데이트 순서는 바로 눈으로 보는 대로입니다.&lt;/li&gt;
  &lt;li&gt;주의할 점은, $A_i = A_j$ 인 $i, j$가 없음이 보장되어있지 않기 때문에, 쿼리할 때 업데이트 순서를 조심해야 합니다. $A_i$가 같을 때 뭐부터 $D_2(i)$ 를 세그트리에 넣어주는지가 중요한데, $A_i = A_j$이면 $D_2(i)$의 유무가 후속하는 $j$ 쿼리에 영향을 줄 수 없도록, 왼쪽부터 업데이트해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ucpc-2018-예선f-boj-15899-트리와-색깔&quot;&gt;UCPC 2018 예선F, BOJ 15899 트리와 색깔&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 : Platinum 2&lt;/li&gt;
  &lt;li&gt;트리의 각 정점이 1부터 $C$ 사이의 색깔을 가지고 있고, $f(v, c)$ 를 $v$를 루트로 하는 서브트리에서 색깔이 $c$이하인 정점의 개수로 정의할 때 이를 빨리 계산하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;Euler Tour 라는 테크닉을 이용, 트리를 배열로 펴 주면 서브트리에 대한 쿼리가 우리가 잘 이해하고 있는 구간에 대한 쿼리로 바뀝니다.&lt;/li&gt;
  &lt;li&gt;쿼리를 오프라인 처리해서, 색깔이 작은 쿼리부터 처리하겠습니다.&lt;/li&gt;
  &lt;li&gt;이제, 색깔이 작은 것부터 업데이트하면서 중간중간 타이밍이 될때마다 쿼리를 처리해 주면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;boj-14287-회사-문화-3&quot;&gt;BOJ 14287 회사 문화 3&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 : Platinum 4&lt;/li&gt;
  &lt;li&gt;위 문제와 똑같이 Euler Tour 를 이용하여 트리를 배열로 펴고&lt;/li&gt;
  &lt;li&gt;칭찬받은 노드에 값을 더한 다음&lt;/li&gt;
  &lt;li&gt;쿼리가 들어오면 그 노드의 서브트리가 받은 칭찬의 값을 합하면 끝입니다.&lt;/li&gt;
  &lt;li&gt;구현이 매우 단순해서, 오일러투어 구현을 확인하기에 적절합니다.&lt;/li&gt;
  &lt;li&gt;나름대로 깨끗하게 구현하려고 노력한 &lt;a href=&quot;https://www.acmicpc.net/source/30906316&quot;&gt;링크&lt;/a&gt; 참고.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bapc-2005e-boj-5419-북서풍&quot;&gt;BAPC 2005E, BOJ 5419 북서풍&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 : Platinum 4&lt;/li&gt;
  &lt;li&gt;전형적인 ‘스위핑 + 세그트리’ 입니다.&lt;/li&gt;
  &lt;li&gt;문제를 단순화하기 위해, 좌표평면에 N개의 점이 있고, 남동쪽 대신 북동쪽으로 간다고 생각해 봅시다. 좌표압축을 한다음 Y좌표들을 뒤집어 버리면 이렇게 만드는 것은 어렵지 않게 가능합니다.&lt;/li&gt;
  &lt;li&gt;이제, 각 점들을 $(x_i, y_i)$ 라고 하고, 1차원 세그먼트 트리 하나를 만듭니다. 각 점을 세그트리의 $x_i$ 번 위치에 추가할 것입니다.&lt;/li&gt;
  &lt;li&gt;우리가 원하는 것은, $(x_i, y_i)$에 서서 세그트리에 $[x_i, \infty]$ 쿼리를 날렸을때 여기서부터 북동쪽으로 갈수있는 점의 개수를 얻는 것입니다. 그러나 우리의 세그트리는 $y$좌표를 기억하지 않고 그냥 무작정 점의 개수를 세기 때문에, $y$좌표는 우리가 스위핑해야 합니다.&lt;/li&gt;
  &lt;li&gt;$y$좌표가 큰 순서대로, 즉 위에서부터 세그트리에 점을 하나씩 넣으면서, 이 점까지 넣은 다음 동쪽을 바라보면 나보다 아래 (y좌표 기준) 점들을 아직 아예 추가가 되지 않았기 때문에 북동쪽 점들만 보이게 됩니다.&lt;/li&gt;
  &lt;li&gt;주의할 점은, 점을 정확히 세기 위해서는 $y$좌표가 같은 점들은 $x$좌표가 큰 쪽부터 처리해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sccc-2019e-boj-17131-여우가-정보섬에-올라온-이유&quot;&gt;SCCC 2019E, BOJ 17131 여우가 정보섬에 올라온 이유&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 : Platinum 4&lt;/li&gt;
  &lt;li&gt;바로 위 문제와 거의 똑같습니다.&lt;/li&gt;
  &lt;li&gt;$y$ 좌표 순서대로 내려오면서 업데이트하고 쿼리합니다. 이문제는 $[0, x_i - 1]$ 과 $[x_i+1, \infty]$ 를 쿼리해서 곱하는 방식입니다.&lt;/li&gt;
  &lt;li&gt;딱 하나 주의할 점은, 위 문제와는 달리 $y$좌표가 같은 점들을 업데이트하는 순서를 어떻게 줘도 꼬이게 됩니다. $y$좌표가 같은 점들을 따로 기억해 놨다가 한번에 업데이트해야 합니다. 코드를 참고해 주세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;boj-16993-연속합과-쿼리&quot;&gt;BOJ 16993, 연속합과 쿼리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 : Platinum 2&lt;/li&gt;
  &lt;li&gt;연속합과 쿼리는 소위 ‘금광세그’ 를 이용하여 풀 수 있음이 매우 잘 알려져 있습니다.&lt;/li&gt;
  &lt;li&gt;세그먼트 트리를 사용하되, 다음과 같은 정보들을 저장합니다. 세그트리의 한 노드가 구간 $[l, r]$ 에 대응한다는 사실을 기억합시다.
    &lt;ul&gt;
      &lt;li&gt;자기가 담당하는 구간의 왼쪽 끝에서 시작해서 얻을 수 있는 최대 구간합&lt;/li&gt;
      &lt;li&gt;자기가 담당하는 구간의 오른쪽 끝에서 시작해서 얻을 수 있는 최대 구간합&lt;/li&gt;
      &lt;li&gt;자기가 담당하는 구간의 최대 구간합&lt;/li&gt;
      &lt;li&gt;자기가 담당하는 구간의 합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 네 정보를 ls, rs, ms, s라고 하면, 두 노드를 합칠 때 다음과 같이 생각하면 됩니다.
    &lt;ul&gt;
      &lt;li&gt;노드 $a$, $b$를 합쳐서 $e$로 만들 때,&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.s&lt;/code&gt; 는 자명합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.ls&lt;/code&gt; 는, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;의 왼쪽 끝에서 시작해야 하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.ls&lt;/code&gt; 가 답일 수도 있고, a를 다 먹고 b의 왼쪽 일부를 먹는 경우가 답일 수도 있습니다. 후자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.s + b.ls&lt;/code&gt; 가 최대일 것입니다 (ls의 정의). 따라서, 두 값 중 최대를 취합니다.&lt;/li&gt;
      &lt;li&gt;같은 원리로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.rs&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b.rs&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b.s + a.rs&lt;/code&gt; 중 큰 값을 고르면 됩니다.&lt;/li&gt;
      &lt;li&gt;마지막은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.ms&lt;/code&gt; 입니다. 이는 다시 경우를 나누어 생각하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;구간에 포함된 답을 갖거나 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.ms&lt;/code&gt;), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;구간에 포함된 답을 갖거나 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b.ms&lt;/code&gt;), 두 구간에 걸친 답을 갖거나 (이 답이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.rs + b.ls&lt;/code&gt;가 최선임을 관찰합니다) 세가지 경우 (대칭을 제외하면 두가지) 밖에 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서, 상수배의 시간을 지불하여 모든 정보를 관리할 수 있고, 연속합 쿼리를 똑같이 날려줄 수 있습니다.&lt;/li&gt;
  &lt;li&gt;두 노드를 합칠때, 단순합에서는 좌우가 상관없지만 이런 특수한 연산을 할 때는 좌우를 조심해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;review&quot;&gt;Review&lt;/h2&gt;
&lt;p&gt;세그먼트 트리 문제를 오랜만에 밀면서 자료구조에 대한 이해를 되짚었다는 정도의 의의가 있는것 같습니다.&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 1학기 종강</title><link href="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/" rel="alternate" type="text/html" title="2021 1학기 종강" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>http://localhost:4000/retrospects-and-plans/finishing-2021-spring</id><content type="html" xml:base="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/">&lt;p&gt;이번학기도 무사히…ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;academic&quot;&gt;Academic&lt;/h2&gt;

&lt;h3 id=&quot;spring-semester-courses&quot;&gt;Spring Semester Courses&lt;/h3&gt;

&lt;h4 id=&quot;hardware-system-design-cse-3&quot;&gt;Hardware System Design (CSE, 3)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Verilog를 이용하여 행렬곱셈 하드웨어 가속기를 만들고, CNN을 빨리돌리는..뭐 그런걸 배우는 과목입니다.&lt;/li&gt;
  &lt;li&gt;저는 베릴로그 코딩을 굉장히 힘들어하기 때문에 팀원이 좀 많이 고생했습니다. 논리설계때 좀 열심히 들을걸 하는 깊은 후회와 미안함을 느끼고 있어서, 창통설은 제가 좀더 나서서 고생할 계획입니다 (아마도…)&lt;/li&gt;
  &lt;li&gt;그와는 별개로 배우는 내용은 매우 흥미로웠는데, 저한테는 좀 힘들었습니다. 제 관심 분야와는 멀다보니 전선이었다면 안 들었을 것 같은데 전필이라 (내 선택에 맡겼다면 있는지도 몰랐을 것들을) 배울 수 있었다는 데 의의가 있다고 생각합니다. 솔직히 NPU, 딥러닝용 FPGA 등이 매우 전망있고 미래에 중요한 기술일 거라는 생각은 듭니다. 다만 제가 개척할 미래는 아니고, 다른 훌륭한 엔지니어들이 수십배 빠른 NPU를 만들어 줄거라고 믿어 의심치 않습니다.&lt;/li&gt;
  &lt;li&gt;프로젝트가 정말 빡세지만 끝나고 보니 그럭저럭 재밌기도 했습니다. 다만 조금 힘들었던 부분들에 대해서는 언젠가 제 시간이 허락하고 팀원이 동의하면 셀프 검열을 좀 거쳐서 얘기해보고 싶습니다. 소개원실 프로젝트는 이렇게 말하고 영원히 검열을 통과하지 못했는데, 하시설은 그정도로 고통스럽지는 않았기 때문에 언젠가는 검열을 통과할수 있을 것 같습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;discrete-mathematics-cse-1&quot;&gt;Discrete Mathematics (CSE, 1)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CS 101인데 지금듣는 놀라운 역수강의 결과입니다. Subgraph Isomorphism에 대한 논문을 읽다가 graph가 뭐고 simple graph가 뭔지 배우는 등… 많은 괴리가 있었습니다.&lt;/li&gt;
  &lt;li&gt;다른 학교의 이산수학과는 달리 저희는 Group이 무엇인지, Lattice가 무엇인지 등 좀 신기한 것들을 많이 배웁니다. Lattice는 처음 듣는 내용이라 당황해서 (정수론의 Lattice가 아닌 집합론의 Lattice입니다) 다른학교 컴공과 친구들 몇명 붙잡고 이게도대체 뭐냐고 물어봤지만 아무도 모르던데, 나름 신기한 뭐가 많았습니다.&lt;/li&gt;
  &lt;li&gt;별개로, 1학년때 들었다면 좋았을것 같습니다. 저야 수학을 복수전공하니까 Proof의 구조나 Function, Relation 등에 대해 공부할 일이 어차피 있었기 때문에 그 효용이 크지 않았겠습니다만 저처럼 수학을 많이는 공부하고 싶지 않더라도 CS 전공자에게 필요한 수학을 단시간에 빠르게 습득할 수 있는 과목이었다는 생각이 듭니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;numerical-linear-algebra-math-3&quot;&gt;Numerical Linear Algebra (MATH, 3)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;수리과학부 수치해석 루트의 과목입니다. MATLAB 또는 Python을 이용한 프로그래밍도 해야 하고, 그냥 과제의 양이 정말 충격적으로 많았는데 그만큼 많이 배웠다고 생각합니다. 중간고사 때까지는 사실 많은 내용을 어디서 주워들은 것들이라고 생각했었는데, 중간고사를 보고 그렇지 않음을 깨달은 뒤 (…) 기말고사는 열심히 공부하고 봤습니다.&lt;/li&gt;
  &lt;li&gt;간단히 요약하자면, 행렬에 대한 알고리즘을 배우는 과목입니다. numpy의 수많은 알고리즘들을 그대로 가져다 쓸수도 있겠지만, 누군가는 그런것들을 만들어야 하니까요. 예를 들어, 1000 * 1000 행렬의 eigenvalue를 어떻게 구할지, eigenvalue 전부가 아니라 몇개만 필요하다면 어떻게 구할지… $Ax = b$는 정해진 해 $x = A^{-1} b$ 가 있지만, 세상에는 감히 역행렬을 구할 시도조차 할 수 없는 사이즈의 문제들이 있습니다. 그렇기에 iteration method 등 여러 clever 한 알고리즘들을 써야 하는데, 그런 부분들을 배웁니다.&lt;/li&gt;
  &lt;li&gt;컴퓨터공학부 알고리즘 수업은 아무래도 이산적인 구조에 집중하고, 다익스트라 알고리즘, 다이나믹 프로그래밍 등등을 배워야 하기 때문에 수치적 알고리즘은 다루지 않게 됩니다. 저희과는 수치해석에 대해서는 공학수학에서 조금 배우는 정도이기 때문에, 후반부 내용들은 굉장히 새로웠습니다.&lt;/li&gt;
  &lt;li&gt;필기노트를 언젠가 LaTeX로 바꿔서 블로그에 공유하고 싶은 과목으로 현재로서는 두번째에 있습니다 (첫번째는 지난학기에 들었던 최적화 이론입니다) 다만 가장 큰 문제는, LaTeX가 행렬 타이핑이 굉장히 어렵다는 점입니다. 고민해보고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;number-theory-math-2&quot;&gt;Number Theory (MATH, 2)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;수리과학부 2학년 과목이고, KMO 출신들을 이길수 없기 때문에 학점은 포기하고 들어야 하는 과목입니다. 다만 교수님께서 원래 Cryptography를 연구하시고, Pollard-Rho 알고리즘의 발전에 지대한 공헌을 하신 등 Computational Number Theory에 가까운 분이시기 때문에 저한테는 정말 재밌는 수업이었습니다. 수업중 Algorithmic한 부분들 - 예를들어 Lenstra의 소인수분해 등 - 에 대한 언급이 많았고, 격자이론이나 동형암호에 대한 특강 등 컴퓨터공학 전공인 저한테는 정말 배울게 많았습니다.&lt;/li&gt;
  &lt;li&gt;PS하면서 배운 정수론을 좀더 정확히 이해할 수 있었습니다. 초반에 빠르게 일반적인 정수론의 주제들 (중국인의 나머지 정리, 페르마 소정리, 오일러 피 함수, 르장드르 기호, 이차 잉여, 디리클레 합성곱 등) 을 달린 후, 후반에는 타원곡선, 무리수의 유리근사, 소수정리 등의 재밌는 주제들을 폭넓게 다루었는데 솔직히 80%도 채 소화하지 못한 것 같아 아쉽습니다. 언젠가 제가 ~정신을 잃고~ 대수적 정수론 같은걸 펴볼 날이 올까요?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;real-analysis-math-grad-1--undergrad-real-analysis-math-4&quot;&gt;Real Analysis (MATH, Grad 1) / Undergrad Real Analysis (MATH, 4)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;이번학기를 지배한 실해석/실변수 세트입니다. 실해석학은 워낙 유명한 과목으로 대학원 1년차 과목임에도 학부생 수강생이 훨씬더 많고 타과생도 많습니다만 제기억에 컴공과는 저밖에 없었습니다. 주로 해석학을 배워야 하는 통계학과, 경제학과가 많았습니다.&lt;/li&gt;
  &lt;li&gt;GRA / URA로 구분하자면, GRA는 루딘의 Real and Complex Analysis의 앞부분 반정도를 커버하고, URA는 Folland의 Real Analysis를 기준으로 그중 일부를 나갑니다. 두 과목의 가장 큰 차이는 ‘세팅’ 이었다고 생각하는데, GRA는 Locally Compact Hausdorff space X를 기본 세팅으로 두는데 비해 URA의 기본 세팅은 $\R$ 또는 $\R^2$ 입니다. 예를들어 Fourier Series를 이해하기 위해 URA에서는 직접 적분을 계산하고 Dirichlet Kernel, Fejer Kernel 등등을 이용하여 내용을 진행하는데 비해, GRA에서는 Hilbert space (완비내적공간)에 대한 일반적인 성질들을 공부하고 그걸 $L^2([-\pi, \pi])$ 에 적용하는 식입니다.&lt;/li&gt;
  &lt;li&gt;그렇다보니 Measure theory, Lebesgue 적분 등을 두가지 관점에서 동시에 보면서 (뚝배기가 박살나긴 했지만) 재밌게 공부할 수 있었습니다. 종합해서 해석학에 대한 이해를 높일 수 있었다고 생각합니다.&lt;/li&gt;
  &lt;li&gt;다만 저처럼 수학을 찍먹할 사람이면 모를까, 수학 전 분야에 대한 이해를 좀 가져야 할 수리과학 전공생들에게 권할만한 테크인지는 잘 모르겠습니다. Redundancy가 있는건 사실이니까요. 저는 복수전공자니까 전필만 듣고나면 제가 듣고싶은거 적당히 골라듣고 챙기면서 움직여도 뭐 되지 않을까요.&lt;/li&gt;
  &lt;li&gt;Measure theory를 공부하게 된 계기는, 3학년 2학기 때 수강했던 최적화 이론입니다. 최적화 이론에서 Martingale 등 놀라운 이론들을 통해 수렴성을 얻는게 좀 있었는데, 도대체 수렴하면 수렴하는거지 Almost surely converge한다는건 무슨소리인가??? 에 대해 답할 수 있게 되었습니다. 최적화이론 수업 이후 조언을 구하였을 때, measure theory와 stochastic differential equation에 대한 공부가 최적화 분야의 엄밀한 이해에 도움이 될 것이라는 조언을 얻을 수 있었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;extracurricular&quot;&gt;Extracurricular&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;지난 2학기 ~ 이번 4월까지 컴퓨터공학부 컴퓨터이론 및 응용 연구실에서 수행했던 UROP 결과로 작성에 참여한 논문을 한국정보과학회에서 주관하는 한국 컴퓨터 종합 학술대회 (Korea Computer Congress) 에 제출하여 발표 (발표는 제가 하는건 아니지만) 하게 되었습니다. 솔직히 짧은 경험과 부족한 지식, 코로나 시국이라 대부분이 비대면으로 진행된 현실 상 제가 뭔가 딥하게 할수 있었던건 별로 없고, 어떤식으로 이런 프로세스들이 돌아가는지 배웠다는 것, 논문 읽고 코드 좀 고쳐서 테스트해보면서 그래도 학교 공부와는 또 다른 느낌의 뭔가를 생각해봤다는데 의의가 있는게 아닌가 생각하기로 헀습니다.&lt;/li&gt;
  &lt;li&gt;연구실에서 감사하게도 KCC 참가비용을 지원해주셔서, 23-25일에는 발표도 듣고 그러게 되었습니다. 재밌는게 있으면 정리해서 뭘 배웠는지 또 포스팅 해보려고 합니다.&lt;/li&gt;
  &lt;li&gt;[UPD] KCC 2021에 결과물인 “부분 그래프 매칭 문제를 위한 향상된 동적 매칭 순서” 를 제출하여 Oral 발표 세션에서 발표될 예정입니다. (발표는 뭐 제가 하는건 아니고, 주저자이신 박사과정 연구원님께서 하십니다) 부족한 제게 정말 과분하게 좋은 경험이었고 감사하게 생각하고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;miscellaneous&quot;&gt;Miscellaneous&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;코로나 시국이라 Personal하게 크게 바뀔만한건 없는듯합니다.&lt;/li&gt;
  &lt;li&gt;가까운 친구/지인 몇명이 병특 등을 포기하고 군대를 갔습니다. 산업기능요원 TO 감소를 비롯하여 여러 이슈들이 겹쳐진것 같은데, 개인적으로 석전연/박전연 중 한쪽을 제 루트로 생각하고 있어서 현재는 입대는 계획에 없습니다. 그래도 유학 등 때문에 고민은 많네요…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2021-summer&quot;&gt;2021 Summer&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;졸업을 해야 하므로 (…) 과학 교양을 채워야 합니다. 실험 듣기 싫어서 미뤘던 죄값을 치를 순간이 왔습니다. 이번 여름에 일반생물학과 일반생물학 실험을 듣게 되었습니다. 고등학교 때 암기가 싫어서 생명과학 2를 고르느니 물리2 화학2 수능을 보고 말겠다고 선언하고 (가오에 지배당해서) 실제로 그렇게 했던 제게는 너무나 끔찍한 형벌이 아닐 수 없습니다.
    &lt;ul&gt;
      &lt;li&gt;그러나 늘 그렇듯 새로운걸 배우기 전까지는 알 수 없는 법입니다. 저는 제가 대학와서 수학을 이렇게 많이 공부할지 몰랐으니까요.&lt;/li&gt;
      &lt;li&gt;라고 셀프 세뇌하고 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수학과의 지인과 지식공유? 의 차원에서, 제가 자료구조/알고리즘과 C++ 프로그래밍을 좀 가르쳐주고 현대대수2의 내용을 좀 배우기로 했습니다. 다음학기에 현대대수2를 들을 예정인데 현대대수1을 모두 잊어버렸기 때문에 복습과 예습이 조금 필요합니다. 어제 그 지인분이 “그렇게 아예 잊어버리기야 했겠느냐”며,  ”Normal subgroup이 뭔지 기억하죠? Ideal이랑” 라고 물었을 때 ‘어…$g$랑 $g^{-1}$를 앞뒤로 곱했던거 같은데…’ 와 ‘아뇨 기억 안나는데요’ 로 대답하는 놀라운 당당함을 보여줬습니다. 모르긴 몰라도 이샛기는 붕어인가?? 하는 생각에 FACEPALM하고 있지 않을까요?&lt;/li&gt;
  &lt;li&gt;그외 계획은 아직 미정입니다. PS도 좀 하고 (이건 이제 반쯤 취미죠)…&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="retrospects-and-plans" /><summary type="html">이번학기도 무사히…ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.</summary></entry><entry><title type="html">Codejam 2021 Round 2</title><link href="http://localhost:4000/algorithms/Codejam-2021-R2/" rel="alternate" type="text/html" title="Codejam 2021 Round 2" /><published>2021-05-19T00:00:00+09:00</published><updated>2021-05-19T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/Codejam-2021-R2</id><content type="html" xml:base="http://localhost:4000/algorithms/Codejam-2021-R2/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#preperation&quot; id=&quot;markdown-toc-preperation&quot;&gt;Preperation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#preliminary--round-1&quot; id=&quot;markdown-toc-preliminary--round-1&quot;&gt;Preliminary &amp;amp; Round 1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problem-1--minimum-sort&quot; id=&quot;markdown-toc-problem-1--minimum-sort&quot;&gt;Problem 1 : Minimum Sort&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problem-2--matrygons&quot; id=&quot;markdown-toc-problem-2--matrygons&quot;&gt;Problem 2 : Matrygons&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problem-3--hidden-pancakes&quot; id=&quot;markdown-toc-problem-3--hidden-pancakes&quot;&gt;Problem 3 : Hidden Pancakes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#round-총평&quot; id=&quot;markdown-toc-round-총평&quot;&gt;Round 총평&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;올해 Codejam의 (나한테 있어) 사실상 마지막 round이므로 (R3 는 재밌게 하겠지만 competition으로써는 얻을게 없다) Hashcode 때처럼 prep과 과정을 좀 적어보려고 한다. 앞으로 메이저한 대회는 이렇게 적어볼 생각이다.&lt;/p&gt;

&lt;h2 id=&quot;preperation&quot;&gt;Preperation&lt;/h2&gt;
&lt;p&gt;그렇게 말하긴 했지만 준비할수 있었던건 딱히 없다. 올해는 CP에 쓰기에는 너무 할일이 많다.&lt;/p&gt;

&lt;p&gt;방학때면 모를까…학기중에 PS/CP에 많은 시간을 투자하기에는 아무래도 어려움이 많다. 그래도 작년 코드잼과 지금 비교했을때 (PS적인 측면에서) 어떤 점들이 나아졌는지 / 나아지지 않았는지 비교해보면 준비를 되새기는 측면에서 조금은 도움이 될것 같기도 하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Courses. Problem solving은 결국 아이디어와 지식이 둘 다 필요한데, 몇몇 내용들 - 작년 1학기에 들은 알고리즘, 지금 듣고있는 정수론 등 - 은 도움이 되는건 사실이다. 대충 다 아는 내용이긴 했지만 혼자서는 절대 하지 않을 revisit을 다시 해보는건 분명히 의미가 있다. General하게, 정수론 같은 파트들은 지식적인 측면보다는 그냥 고민해보는 시간을 갖는게 의미가 있다고 생각한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C++ 구현능력은 오히려 작년만 못하다. 2학기 소개원실이 분기점이 되어서 그런거 같은데, 돌아오려면 아직 멀었다고 생각한다. 2019년 ICPC 때 팀원들이 굉장히 구현을 힘들어해서 아니 멀쩡했던 사람들이 왜이러나 싶었는데, 대충 왜그런지 알거 같기도 하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그동안 CF rating은 답보를 거듭했는데, 한문제 잡고 푸는 능력은 작년에 비해 나아졌다고 생각한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhdroid&lt;/code&gt; 같은 경우에는 빠른 코딩 실력을 갖추지는 못했지만 어려운 문제를 고민하면 나보다 훨씬 체계적으로 관찰을 쌓아나가는 능력이 있는데, 같이 공부하면서 이런걸 많이 배웠다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;preliminary--round-1&quot;&gt;Preliminary &amp;amp; Round 1&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Preliminary는 30점 절대평가 형식이므로 카페에 앉아서 그냥 대충 앞 몇문제만 내보고 던졌다. 그때 꽤 바쁜 일정들이 있었기 때문에…&lt;/li&gt;
  &lt;li&gt;Round 1은 뭔가 항상 R1B를 치게 되는 기분이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-1--minimum-sort&quot;&gt;Problem 1 : Minimum Sort&lt;/h2&gt;
&lt;p&gt;Easy. 바로 떠오르는 Naive 풀이를 그냥 구현하면 된다.&lt;/p&gt;

&lt;p&gt;[1, 100] 중 가장 작은걸 뽑고, 맨 앞으로 보낸 다음, [2, 100] 중 가장 작은걸 뽑고…. 이렇게 하면 소모하는 코인 수는 $1/2 + 1/3 + \dots 1/100$ 개 정도이고, 이 값은 6보다 작으므로 이대로 짜서 내면 된다.&lt;/p&gt;

&lt;h2 id=&quot;problem-2--matrygons&quot;&gt;Problem 2 : Matrygons&lt;/h2&gt;
&lt;p&gt;$K$가 주어질 때, &lt;조건&gt;을 만족하는 distinct한 수열 $x_1, x_2, \dots x_N$ 중 $N$이 최대인 수열을 찾는 문제.&lt;/조건&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\sum_{i = 1}^{N} x_i = K$ 여야 하며&lt;/li&gt;
  &lt;li&gt;$x_1$ 이 $x_2$의 약수, $x_2$가 $x_3$의 약수…. $x_N$ 까지 이를 만족해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저, $K$ 가 $x_1$ 의 배수임을 쉽게 관찰할 수 있다. 또한, $K - x_1$ 은 $x_2$의 배수이고… 이를 반복할 수 있다는 것이 첫번째 관찰이다.&lt;/p&gt;

&lt;p&gt;두번째로, $N$이 reasonable하게 작음을 관찰하자. $2x_i \leq x_{i+1}$ 임을 확인할 수 있는데 (배수여야 하고, 같으면 안 되므로) 이를 보면, $N$은 많아야 $\log K$, 30 정도이다.&lt;/p&gt;

&lt;p&gt;이 두가지를 이용하면, $f(k, t)$ 를 “현재 $x = t$, $K = k$일 때 $x$ 부터 시작해서 수열을 만들어서 $k$를 만들고자 할 때, 최대의 $N$값” 으로 정의하면 $f(k, t)$ 를 재귀적으로 꽤 빠르게 계산할 수 있다. 설명하기가 굉장히 까다롭지만 코드는 매우 간단하므로 아래 코드를 참고하자.&lt;/p&gt;

&lt;p&gt;주의할 점은, 1각형이나 2각형은 없으므로 처음에는 3각형 이상으로 시작해야 함을 주의하자. (이걸로 1틀했다…)&lt;/p&gt;

&lt;p&gt;라운드가 끝나고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhdroid&lt;/code&gt; 와 discussion했는데 역시 DP황답게 나보다 훨씬 좋은 DP 솔루션을 가져왔다. :fan:&lt;/p&gt;

&lt;h2 id=&quot;problem-3--hidden-pancakes&quot;&gt;Problem 3 : Hidden Pancakes&lt;/h2&gt;
&lt;p&gt;이 문제의 경우, 주어진 문제 상황을 잘 이용하면 “$i$ 번이 $j$번보다 크다/작다” 형태의 정보를 많이 얻을 수 있다. 이러한 정보들이 consistent 하다면, transitivity에 의해 imply되는 정보들을 제외함으로써 Directed tree를 만들 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, 예제 2는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 1 2&lt;/code&gt; 인데, 이를 다음과 같이 볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 &amp;lt;1&amp;gt; 이 보이는 상황이다.&lt;/li&gt;
  &lt;li&gt;1 다음에 1이 온 시점에서, 보이는게 1개이므로 현재 보이는 것은 &amp;lt;2&amp;gt; 이다. 2번이 1번을 스택에서 쫓아냈으므로, 2번이 1번보다 크다.&lt;/li&gt;
  &lt;li&gt;그다음 2개가 보이므로 &amp;lt;2, 3&amp;gt; 이다. 3번이 2번을 쫓아내지 못했으므로 2번이 3번보다 크다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 트리로 그리면 2번이 루트가 되고, 1번과 3번이 2번의 child node인 트리가 된다.&lt;/p&gt;

&lt;p&gt;같은 방법으로, 예제 1인  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 2 2 1&lt;/code&gt; 을 보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 &amp;lt;1&amp;gt; 이 보이는 상황이다.&lt;/li&gt;
  &lt;li&gt;두번째 시점의 스택은 &amp;lt;1, 2&amp;gt; 이므로 1이 2보다 크다.&lt;/li&gt;
  &lt;li&gt;세번째 시점의 스택은 &amp;lt;1, 3&amp;gt; 인데, 스택에서 3이 2를 쫓아냈으므로 3이 2보다 크다. 또한, 3이 1보다는 작다.&lt;/li&gt;
  &lt;li&gt;마지막 시점에서 &amp;lt;4&amp;gt; 가 모두 쫓아냈으므로 4가 1보다 크다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서, 4 &amp;gt; 1 &amp;gt; 3 &amp;gt; 2 임을 알 수 있다. 이를 트리로 그리면 한 줄로 쭉 이어진 트리가 된다.&lt;/p&gt;

&lt;p&gt;이렇게 트리를 그리고 나면, 이 “트리가 제공하는 partial order”를 깨지 않으면서 $n$개의 팬케익 크기를 정하는 문제가 되는데, 이는 다시 말하면 1, 2, … $n$을 각 트리 노드에 써넣되 topological order를 깨지 않는 permutation의 개수를 찾는 문제가 된다.&lt;/p&gt;

&lt;p&gt;이는 즉, 현재 주어진 트리의 적법한 topological order의 개수를 세는 문제와 같다. 이 문제는 나름대로 well-known 이므로, 약간 구글링해보면 Tree DP 로 이를 해결하는 방법을 찾을 수 있다. 앳코더에 문제로도 나온 적 있다. &lt;a href=&quot;https://atcoder.jp/contests/abc160/tasks/abc160_f&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;분명 저 앳코더 문제를 풀때는 생각을 해서 ($O(n \log n)$이긴 했지만 이걸 혼자 찾아냈었는데, 왜인지 모르겠지만 라운드 때는 저런 생각을 전혀 못했다. :( Tree DP는 항상 너무 어려운듯…)&lt;/p&gt;

&lt;h2 id=&quot;round-총평&quot;&gt;Round 총평&lt;/h2&gt;
&lt;p&gt;올해의 첫 메이저 대회인데 나름 재밌었다. 작년이나 재작년 Round 2에 비하면 조금 쉬워진듯한데, 어차피 상대평가니까 큰 의미는 없을 수도…&lt;/p&gt;

&lt;p&gt;1000등이라는 커트를 정해놓고 시작하는 라운드다 보니 66점을 받은 시간으로 갈릴수밖에 없는데, 그래도 다행히 막 첫 태스크 빨리푼 시간 이런식으로 갈린 speed중심의 대회는 아니라서 약간 다행이다. 간단한 아이디어 / DP / 트리 DP 라는 첫 3문제의 세팅도 reasonable했다고 보고…&lt;/p&gt;

&lt;p&gt;R3도 재밌게 치고 후기정도는 올릴 계획이다 :P&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="competitive-programming" /><summary type="html">Contents</summary></entry><entry><title type="html">5월 2주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21may2/" rel="alternate" type="text/html" title="5월 2주차 Weekly PS" /><published>2021-05-18T00:00:00+09:00</published><updated>2021-05-18T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21may2</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21may2/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#google-codejam-2021-round-2&quot; id=&quot;markdown-toc-google-codejam-2021-round-2&quot;&gt;Google Codejam 2021, Round 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#virtual-google-codejam-2018-round-2&quot; id=&quot;markdown-toc-virtual-google-codejam-2018-round-2&quot;&gt;[Virtual] Google Codejam 2018, Round 2&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#falling-balls&quot; id=&quot;markdown-toc-falling-balls&quot;&gt;Falling Balls&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#graceful-chainsaw-jugglers-small&quot; id=&quot;markdown-toc-graceful-chainsaw-jugglers-small&quot;&gt;Graceful Chainsaw Jugglers (small)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#costume-change&quot; id=&quot;markdown-toc-costume-change&quot;&gt;Costume Change&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;May 10 - May 17, 2021.&lt;/p&gt;

&lt;h2 id=&quot;google-codejam-2021-round-2&quot;&gt;Google Codejam 2021, Round 2&lt;/h2&gt;
&lt;p&gt;PS를 시작하고 세 번째 Codejam이다. 처음으로 Round 3에 진출하고 Codejam 티셔츠를 얻었다.&lt;/p&gt;

&lt;p&gt;순위는 855등으로, 거의 막차를 탔지만 아무튼 티셔츠를 받았다는 사실이 매우 고무적이다 (?)&lt;/p&gt;

&lt;p&gt;나름대로 중요한 대회이므로 별도로 포스팅하기로 한다.&lt;/p&gt;

&lt;h2 id=&quot;virtual-google-codejam-2018-round-2&quot;&gt;[Virtual] Google Codejam 2018, Round 2&lt;/h2&gt;
&lt;p&gt;Codejam을 대비하기 위해 영원한 팽도리들 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhdroid&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; 과 함께 2018 Round 2를 virtual로 돌았다. 많은 부족함을 느꼈다.&lt;/p&gt;

&lt;h3 id=&quot;falling-balls&quot;&gt;Falling Balls&lt;/h3&gt;
&lt;p&gt;나름대로 재밌는 Greedy construction 문제이다. 먼저, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;에 대한 조건으로부터, 시작하는 공들이 교차해서 움직이지 못함을 관찰하자. 그러고 나면 결국 왼쪽에서 $k$번째라는 공의 상대적 위치가 잘 보존되므로, 어느 공이 어디로 가야 하는지를 정확하게 안다. 이를 맞추어 construct하기는 어렵지 않다.&lt;/p&gt;

&lt;h3 id=&quot;graceful-chainsaw-jugglers-small&quot;&gt;Graceful Chainsaw Jugglers (small)&lt;/h3&gt;
&lt;p&gt;$O(n^4)$ 의 자명한 DP를 이용하여 small을 긁었고, 어떻게든 이를 줄여보려고 이리저리 많은 고민을 했지만 성공하지 못했다.&lt;/p&gt;

&lt;p&gt;끝나고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhdroid&lt;/code&gt; 의 솔루션을 들었는데, DP의 차원을 줄이는 아이디어가 상당히 매력적이다. 뭔가 형태적으로 자주 보이는 DP인 듯 함에도 떠올리지 못한 점은 좀 아쉽다. 풀이에는 $O(n^{8/3})$ 의 놀라운 풀이가 적혀 있으나, $O(n^3)$ 도 문제 해결에 아무런 지장이 없고 훨씬 떠올리기 쉽다.&lt;/p&gt;

&lt;h3 id=&quot;costume-change&quot;&gt;Costume Change&lt;/h3&gt;
&lt;p&gt;중요한 포인트 하나는, 사실 색깔은 충분히 많다는 것이다. 즉, 현재의 ‘특별하지 않음’ 이라는 이슈만 resolve하면 된다.&lt;/p&gt;

&lt;p&gt;어떤 $n \times n$ 그리드 상에서, $k$개의 점들이 놓여 있을 때, 이중의 subset을 스도쿠스럽게 뽑는 방법 (각 행에 하나, 각 열에 하나 이하를 유지하는 방법) 은 비교적 well-known이다. 행을 표현하는 정점 $n$개와 열을 표현하는 정점 $n$개를 만들고, $(i, j)$ 에 점이 놓여 있음을 $r_i \to c_j$ 간선으로 표현한 다음, 이들간의 maximum bipartite matching을 찾으면 된다. 이것만 찾는 방법은 좋은 방법이 많이 있지만, 무지성 플로우가 가장 쉽게 구현할수 있다.&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">5월 1주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21may1/" rel="alternate" type="text/html" title="5월 1주차 Weekly PS" /><published>2021-05-11T00:00:00+09:00</published><updated>2021-05-11T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21may1</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21may1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#google-codejam-2021-round-1b&quot; id=&quot;markdown-toc-google-codejam-2021-round-1b&quot;&gt;Google Codejam 2021, Round 1B&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#broken-clock-small-middle&quot; id=&quot;markdown-toc-broken-clock-small-middle&quot;&gt;Broken Clock, Small-Middle&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#subtransmutation-full&quot; id=&quot;markdown-toc-subtransmutation-full&quot;&gt;Subtransmutation, Full&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problems&quot; id=&quot;markdown-toc-problems&quot;&gt;Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-20191-줄임말-koi-2020&quot; id=&quot;markdown-toc-boj-20191-줄임말-koi-2020&quot;&gt;BOJ 20191 줄임말 (KOI 2020)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-3006-터보소트-coci-2007&quot; id=&quot;markdown-toc-boj-3006-터보소트-coci-2007&quot;&gt;BOJ 3006 터보소트 (COCI 2007)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Apr 26 - May 09, 2021. 이번 주차는 4월 말 것들도 포함되어 있다.
이전 블로그에서 했었던 weekly PS를 다시 써보려고 한다. 알고리즘 공부도 요새 너무 못한거 같아서…
시험기간 2주씩을 제외하고, 5월에는 아마 1-4주차까지는 있을 예정이다.&lt;/p&gt;

&lt;h2 id=&quot;google-codejam-2021-round-1b&quot;&gt;Google Codejam 2021, Round 1B&lt;/h2&gt;
&lt;p&gt;1번 Broken clock의 small과 middle, 2번 subtransmutation의 small과 large를 풀고 1101등으로 1B를 통과했다. 올해는 Round 2에는 큰 의미를 두고 있지 않다 (요새 코딩 연습을 너무 못해서..)&lt;/p&gt;

&lt;p&gt;놀라운 구현 뇌절이 있을 예정이었기 때문에 미연에 방지하고자 python으로 뛰었고, 그럼에도 불구하고 Broken clock 구현에 1시간 반 정도를 박고 9번을 제출했지만 large를 맞지 못했다는건 좀 충격적이다.&lt;/p&gt;

&lt;p&gt;문제 풀이에 대해 간략히 얘기하자면…&lt;/p&gt;

&lt;h3 id=&quot;broken-clock-small-middle&quot;&gt;Broken Clock, Small-Middle&lt;/h3&gt;
&lt;p&gt;Middle까지는 가능한 시간이 정수 초 만큼이라서 43,200가지밖에 없고, 이 모든 경우를 직접 확인해도 넉넉한 시간이다.&lt;/p&gt;

&lt;p&gt;코드 : &lt;a href=&quot;https://github.com/gratus907/Gratus_PS/blob/master/Contests/Others/%5BGoogle%5D%20Google%20Codejam/2021/Round%201B/A_Broken_Clock.py&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;subtransmutation-full&quot;&gt;Subtransmutation, Full&lt;/h3&gt;
&lt;p&gt;왜 문제 순서가 이런지 잘 모르겠다. 넉넉히 $K$ 한개로 시작해서 만들 수 있는지를 매번 확인해도 시간이 넉넉하고, 이는 $K$부터 1번까지 거꾸로 오면서 Greedy하게 DP를 계산해주면 된다. 말이 조금 이상한데, 꼭 필요한 개수만큼 빼놓고 나머지는 전부 나중에 쓰일수도 있으니 작은걸로 분해해준다고 생각하면 간단하다. 말보다 코드가 훨씬 쉬운 문제.&lt;/p&gt;

&lt;p&gt;코드 : &lt;a href=&quot;https://github.com/gratus907/Gratus_PS/blob/master/Contests/Others/%5BGoogle%5D%20Google%20Codejam/2021/Round%201B/B_Subtransmutation.py&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;
&lt;h3 id=&quot;boj-20191-줄임말-koi-2020&quot;&gt;BOJ 20191 줄임말 (KOI 2020)&lt;/h3&gt;
&lt;p&gt;난이도 : Gold 3 (BOJ)&lt;/p&gt;

&lt;p&gt;문자열 S와 T가 주어질 때, T를 몇 번 concat해야 $T^n$ (concat) 이 $S$를 subseqeunce로 포함하는지 묻는 문제. S의 각 글자에 대해서, 이 글자가 T의 몇번째에 대응될 수 있는지 미리 모두 확인한다. Greedy하게, 내 이전 글자들보다 뒤에 있기만 하다면 대응할 수 있는 위치 중 최대한 앞에 대응해야 무조건 이득이 된다. 그러나 더이상 대응 가능한 위치가 없다면, 새로운 T를 하나 추가해서, 가능한 가장 앞에 대응해야 한다. 이를 이용하면 전처리 $O(S + T)$ 를 수행함으로써, $S$의 각 글자에 대해 $\log T$ 시간에 위치를 찾아줄 수 있으므로 $O(S \log T)$ 시간에 해결된다.&lt;/p&gt;

&lt;p&gt;코드 : &lt;a href=&quot;https://github.com/gratus907/Gratus_PS/blob/master/Contests/Olympiads/%5BKOI%5D%20Korean%20Olympiad%20of%20Informatics/KOI%202020/%EA%B3%A0%EB%93%B11-%EC%A4%84%EC%9E%84%EB%A7%90.cpp&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;boj-3006-터보소트-coci-2007&quot;&gt;BOJ 3006 터보소트 (COCI 2007)&lt;/h3&gt;
&lt;p&gt;난이도 : Platinum 4 (BOJ)&lt;/p&gt;

&lt;p&gt;세그먼트 트리에 각 element의 위치를 저장하고, segment tree를 이용하여 다이나믹하게 뭔가를 갱신하는 좋은 연습문제지만 기본적인 개념을 파악하고 나면 어렵지 않다. Segtree를 이용하면 구간 $(a, b)$ 의 1의 개수 (남아 있는 원소의 개수) 를 쉽게 셀 수 있다.&lt;/p&gt;

&lt;p&gt;코드 : &lt;a href=&quot;https://github.com/gratus907/Gratus_PS/blob/master/Contests/Olympiads/%5BCOCI%5D%20Croatian%20Open%20Competition%20in%20Informatics/COCI%202007-2008/2_TURBO.cpp&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">Iterative methods : Jacobi, GS, SOR</title><link href="http://localhost:4000/numerical-analysis/im-1/" rel="alternate" type="text/html" title="Iterative methods : Jacobi, GS, SOR" /><published>2021-04-28T00:00:00+09:00</published><updated>2021-04-28T00:00:00+09:00</updated><id>http://localhost:4000/numerical-analysis/im-1</id><content type="html" xml:base="http://localhost:4000/numerical-analysis/im-1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#iterative-methods&quot; id=&quot;markdown-toc-iterative-methods&quot;&gt;Iterative methods&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#convergence&quot; id=&quot;markdown-toc-convergence&quot;&gt;Convergence&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#richardson-method&quot; id=&quot;markdown-toc-richardson-method&quot;&gt;Richardson method&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#convergence-1&quot; id=&quot;markdown-toc-convergence-1&quot;&gt;Convergence&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jacobi-method&quot; id=&quot;markdown-toc-jacobi-method&quot;&gt;Jacobi method&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gauss-seidel-method&quot; id=&quot;markdown-toc-gauss-seidel-method&quot;&gt;Gauss-Seidel Method&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sor-successive-overrelaxation&quot; id=&quot;markdown-toc-sor-successive-overrelaxation&quot;&gt;SOR (Successive OverRelaxation)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;iterative-methods&quot;&gt;Iterative methods&lt;/h2&gt;
&lt;p&gt;수치선형대수 수업에서 배운 내용을 조금 정리해 보려고 한다. 구체적으로, 행렬 $A$와 벡터 $b$에 대해, $Ax = b$를 푸는 여러 방법들 중 iterative methods를 몇 포스팅에 걸쳐 다루어 본다.&lt;/p&gt;

&lt;p&gt;우선, 행렬 $A$ 의 inverse를 구하기가 쉽다면 $x = A^{-1} b$ 를 계산하면 간단하다. 당연히 이상한 방법을 필요로 하는 이유는 이 inverse를 구하기가 어렵기 때문이다. 어렵다는 것은 두 가지 의미가 있는데…&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Numerically unstable 해서 수치 오차가 우려되는 경우&lt;/li&gt;
  &lt;li&gt;Complexity 관점에서, 계산 시간이 큰 경우
두 경우 모두 “계산이 어렵다” 라는 말로 퉁치기로 하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;한번에 정확히 $x = A^{-1} b$를 구하는 대신, 임의의 $x_0$에서 시작해서, $x_i$들의 sequence가 $x$로 수렴하게 하려고 한다. 이때 $x_{i+1}$ 은 $x_i$ 및 그 이전 항들을 이용하여 귀납적으로 연산할 수 있어야 하고, 각 step은 계산이 쉬워야 할 것이다.&lt;/p&gt;

&lt;p&gt;어떤 행렬 $Q$에 대해, $A = Q - (Q - A)$ 로 쓰면, $Ax = b$의 해 $x$는 $Qx = (Q - A) x + b$ 를 만족해야 할 것이다. 따라서, $Qx_k = (Q - A)x_{k-1} + b$ 를 우리의 iteration으로 쓸 것이다.&lt;/p&gt;

&lt;p&gt;또한, $A = L + D + U$ 를, $L$을 diagonal 아래의 (strictly) lower triangular한 행렬로, $U$를 그 반대의 upper triangluar 행렬로, $D$를 $A$의 diagonal로 잡기로 한다.&lt;/p&gt;

&lt;p&gt;이번 포스팅에서는 가급적 증명들을 생략하고 method들에 대해서만 간략히 살펴보고, 증명은 나중에 여력이 되면 쓸 예정이다.&lt;/p&gt;

&lt;h3 id=&quot;convergence&quot;&gt;Convergence&lt;/h3&gt;
&lt;p&gt;위 iteration이 올바른 답을 낸다는 사실은 상당히 nontrivial하다. 우선 $x_k = Q^{-1}((Q-A)x_{k-1} + b) = f(x_{k-1})$ 이라고 쓰면, 우리의 목표는 $f$의 fixed point를 찾는 것임을 알 수 있다. 이 iteration은 사실 이러한 $f$에 대해 FPI (Fixed Point Iteration) 을 수행하는 과정으로 이해할 수 있다. FPI가 언제 어떻게 수렴하는지를 이해하는 것은 쉽지 않은데, $f$가 Lipschitz continuous w/ $L &amp;lt; 1$ 임을 보이거나, 훨씬 더 어려운 수학적 내용들을 공부해야 한다. 작년에 최적화 이론 수업에서 이러한 수렴 정리들을 배웠는데, Averaged operator에 대한 수렴정리가 상당히 어렵지만 재밌었던 기억이 있다. 직접 링크를 거는 것이 적절한지 모르겠는데, Ernest K. Ryu 교수님의 최적화 이론 수업 자료가 웹사이트에 공개되어 있으므로 찾아보면 (해석개론 정도의 해석학 지식 배경 위에서) 이해할 수 있을 것 같다. (&lt;strong&gt;Monotone Operators and Base Splitting Schemes&lt;/strong&gt; 의 &lt;strong&gt;Theorem 1&lt;/strong&gt; 부분을 확인하면 된다)&lt;/p&gt;

&lt;h2 id=&quot;richardson-method&quot;&gt;Richardson method&lt;/h2&gt;
&lt;p&gt;Richardson method는 $Q = \frac{1}{w}I$ 를 쓰는 방법이다. 즉, $x_k = (I - wA) x_{k-1} + wb$ 를 생각할 것이다. $I - wA$를 한번 구한 다음부터는 계속 행렬-벡터 곱셈만 반복해도 되므로, 각 step이 $O(n^2)$이고, $I - wA$를 한번 구하는데 $O(n^2)$ 이 들게 되므로 iteration 횟수 $m$에 대해 $O(n^2 m)$ 시간에 연산할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;convergence-1&quot;&gt;Convergence&lt;/h3&gt;
&lt;p&gt;$x_* - x_i$ 를 직접 계산하면, $(I - wA)x_* + wb - (I - wA)x_{i-1} - wb$ 가 되고, 이를 반복적으로 적용하면 다음 식을 얻는다.
\(x_* - x_k = (I - wA)^k (x_* - x_0)\)
편의상, $x_0$ 을 영벡터로 놓으면, 우리는 다음과 같은 식을 얻는다.
\(\norm{x_* - x_k} = \norm{(I - wA)^k x_*} \leq \norm{I - wA}^k \norm{x_*}\)
이제 $\norm{I - wA}$ 부분을 evaluate 해야 함을 알 수 있고, 선형대수의 지식을 잘 써서 계산해 보면 수렴 속도는 $\lambda_n / \lambda_1$, 즉 가장 큰 eigenvalue와 가장 작은 eigenvalue의 비에 의존함을 파악할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;jacobi-method&quot;&gt;Jacobi method&lt;/h2&gt;
&lt;h2 id=&quot;gauss-seidel-method&quot;&gt;Gauss-Seidel Method&lt;/h2&gt;
&lt;h2 id=&quot;sor-successive-overrelaxation&quot;&gt;SOR (Successive OverRelaxation)&lt;/h2&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="numerical-analysis" /><category term="algorithms" /><category term="mathematics" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 1학기 중간점검</title><link href="http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring/" rel="alternate" type="text/html" title="2021 1학기 중간점검" /><published>2021-04-23T00:00:00+09:00</published><updated>2021-04-23T00:00:00+09:00</updated><id>http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring</id><content type="html" xml:base="http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring/">&lt;p&gt;블로그 포스팅 오랜만이네요. 기록상 3월 19일에 폴라드-로 알고리즘에 대해 쓴 게 마지막이니, 대략 한달 만입니다. 과제랑 중간고사에 치여서 나름대로 바쁜 삶을 살고 있습니다.&lt;/p&gt;

&lt;p&gt;잠깐 이번학기 중간점검 하는 느낌으로, 쭉 적어보려고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;major-updates&quot;&gt;Major Updates&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;수리과학부 복수전공을 (원래도 계획하고 있었지만) 시작하게 되었습니다. 원래는 부전공 중이었는데 조금더 제대로 수학공부를 해보고 싶기도 했고 원래 계획은 복전이었으니까요. 다만 (여기에 적어도 되는지 모를만한 여러 가지로 인해) 복전이 실제로 가능할지는 조금 의문이었는데 잘 해결되었습니다. 별일없으면 초과학기 한 학기와, 인턴십 등으로 쓸 휴학 한 학기를 이용하여 5학년까지 다니고 2023년 2월에 졸업할 예정입니다.&lt;/li&gt;
  &lt;li&gt;Computer Theory Lab에서 수행했던 UROP (Undergraduate Research Oppertunity Program) 가 마무리되었습니다. 원래는 작년 8월 - 올해 2월이어야 했지만 어쩌다보니 좋은 기회가 생겨서 4월까지 이어졌습니다. 가능하다면 졸업후 이 연구실로 가고 싶다는 생각을 하고 있습니다.&lt;/li&gt;
  &lt;li&gt;컴퓨터공학부 보안 분야 학술 동아리 Guardian의 부회장을 맡게 되었습니다. 보안 분야로 진로를 잡았던 것은 아니지만 암호학 등에는 계속 조금씩 관심이 있었는데, 부끄럽지 않을만큼의 공부를 해야겠다는 생각이 듭니다. 솔직히 많이 부족한데 맡을사람이 없다보니…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;classes&quot;&gt;Classes&lt;/h2&gt;
&lt;p&gt;이번학기에는 이렇게 수강하고 있습니다. (학과, 학년)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하드웨어 시스템 설계 (컴퓨터공학부, 3) : 서류상 3학년 과목이지만 왜인지 모르겠습니다. 원래는 메모리 구조 등을 배우는 과목이었다고 하는데, 학과 전체가 AI에 잡아먹히는 과정에서 Verilog로 행렬 곱셈을 빠르게 수행하는 가속기를 FPGA에다 올려서 CNN을 빨리 돌리는…뭐 아무튼 그런 주제를 다루는 수업이 되었습니다. Implementation specific한 하드웨어라던가, Neural network에 특화한 칩 설계 같은건 하드웨어 분야 에서 매우 핫한 주제라고 알고 있지만 저는 하드웨어 분야에 소질이 없기 때문에 사실 잘 모르겠습니다. Verilog 프로그래밍은 매우 못 하지만 훌륭한 팀원이 있어 잘 따라가는 중입니다.&lt;/li&gt;
  &lt;li&gt;실변수함수론 (수리과학부, 4) : 해석학 정통 테크의 과목입니다. 아래 실해석학이랑 같이 듣고 있어서 조금은 편하게 공부하고 있습니다. Measure theory, $L^p$ space, 르벡 적분 등을 배웠습니다.&lt;/li&gt;
  &lt;li&gt;실해석학 (수리과학부, G1) : 실변수함수론보다 한단계 높은 과목으로 배우는 내용이 조금 어렵습니다. 다만 실제로 선수관계라기보다는 같은 과목의 학부 4 / 대학원 1 버전이라, 그냥 저냥 들을 만 합니다. 워낙 유명하고 평이 좋은 과목이라 학부생들도 많이 듣습니다. 실변수함수론 내용을 업글해서 배우는 느낌이라 같이 따라가기 좋고… 엄청 어렵습니다. 해석학 베이스가 없다는걸 많이 느낍니다.&lt;/li&gt;
  &lt;li&gt;정수론 (수리과학부, 2) : 정수론 수업은 진도가 상당히 빠르고 많은 내용을 다루며, 교수님께서 원래 Cryptography를 전공하셨기 때문에 저한테는 매우 흥미로운 주제들이 많았습니다. Computational한 주제들이 많아서 재밌습니다.&lt;/li&gt;
  &lt;li&gt;수치선형대수 (수리과학부, 3) : 선형대수의 여러 계산들을 수치적으로 하는 방법을 배웁니다. 뒤에는 뭔가 새로운 내용을 배우는거 같은데 잘 모르겠고… QR분해, SVD 등 다양한 선형대수의 지식을 Computational하게 접근하는 과목입니다. MATLAB 프로그래밍을 익히는게 조금 어색합니다.&lt;/li&gt;
  &lt;li&gt;이산수학 (컴퓨터공학부, 1) : ㅋㅋㅋㅋ 자구 알골 듣고 이산수학 역수강 ㅋㅋㅋㅋ 테크가 꼬여서 4학년에 이산수학을 듣고 있는데, 컴공과 CS테크를 타고 수학과 과목을 20학점 정도 들은 뒤라 그냥 편안하게 가고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;extracurricular&quot;&gt;Extracurricular&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Guardian에서 C언어 기초 스터디 자료를 작성하게 되었습니다.&lt;/li&gt;
  &lt;li&gt;Codejam 은 Round 1A를 일정상 걸렀는데, 1B에서 올라가면 되니까 별로 부담은 없긴합니다&lt;/li&gt;
  &lt;li&gt;PS는 거의 못하고 있는데, 뭐 조금씩은 다시 해보려고 합니다. 가능하면 여기에 포스팅도 조금 자주 하구요… 난이도 있는 문제들 위주로 포스팅할 계획입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;for-fun&quot;&gt;For fun&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;온라인 체스를 꽤 재밌게 두고 있습니다. Lichess랑 Chess.com 둘다 가끔 하는데 레이팅은 1700 / 1400 정도. 그냥저냥 하는 정도인거 같습니다. 언젠가 여기에 체스 관련 포스팅 할 수도?&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="retrospects-and-plans" /><summary type="html">블로그 포스팅 오랜만이네요. 기록상 3월 19일에 폴라드-로 알고리즘에 대해 쓴 게 마지막이니, 대략 한달 만입니다. 과제랑 중간고사에 치여서 나름대로 바쁜 삶을 살고 있습니다.</summary></entry><entry><title type="html">폴라드-로 소인수분해 알고리즘</title><link href="http://localhost:4000/algorithms/Pollards-Rho/" rel="alternate" type="text/html" title="폴라드-로 소인수분해 알고리즘" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/Pollards-Rho</id><content type="html" xml:base="http://localhost:4000/algorithms/Pollards-Rho/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#motivation&quot; id=&quot;markdown-toc-motivation&quot;&gt;Motivation&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#생일-문제-birthday-problem&quot; id=&quot;markdown-toc-생일-문제-birthday-problem&quot;&gt;생일 문제 (Birthday Problem)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#가정&quot; id=&quot;markdown-toc-가정&quot;&gt;가정&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#algorithm&quot; id=&quot;markdown-toc-algorithm&quot;&gt;Algorithm&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#예시&quot; id=&quot;markdown-toc-예시&quot;&gt;예시&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#구현&quot; id=&quot;markdown-toc-구현&quot;&gt;구현&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#시간-복잡도&quot; id=&quot;markdown-toc-시간-복잡도&quot;&gt;시간 복잡도&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;motivation&quot;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;소인수분해는 매우 어려운 과정이다. 실제로 소인수분해는 (입력 비트 수에 대해) 다항 시간에 결정론적으로 풀 수 있는 방법이 알려져 있지 않다.&lt;/p&gt;

&lt;p&gt;그러나, 약간의 랜덤성 (확률에 대한 의존) 을 허용한다면 상당히 clever한 알고리즘을 통해 빠르게 소인수분해를 할 수 있는데, 이 방법이 바로 Pollard’s Rho($\rho$) 알고리즘이다.&lt;/p&gt;

&lt;h3 id=&quot;생일-문제-birthday-problem&quot;&gt;생일 문제 (Birthday Problem)&lt;/h3&gt;
&lt;p&gt;고등학교 확/통 교과서에도 실려있는 유명한 문제인데, 다음 문제에 답해 보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;23명의 사람이 한 방에 모여 있다. 이 중, 적어도 한 쌍 이상이 생일이 겹칠 확률은 얼마인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;계산을 직접 해 본다면, 별로 직관적이지 못한 결론을 얻는다. 대략 50%가 넘어가는데, 365개의 생일 중 23명이 골랐을 뿐인데 이렇게 높은 확률이라는 것이 비직관적이기 때문에 이 결과를 Birthday Paradox라고도 부른다.&lt;/p&gt;

&lt;p&gt;이 문제의 핵심은, &lt;strong&gt;마구 랜덤하게 뽑으면 생각보다 많이 겹친다&lt;/strong&gt; 라는 정보이다. 이를 이용하여, 어떻게 소인수분해를 할 수 있는지 알아보고자 한다.&lt;/p&gt;

&lt;p&gt;구체적으로, $\sqrt{n}$ 정도의 사람이 필요하다는 사실을 기억하자. 즉, $n$개 중 $k$개를 뽑아서, 겹치는 쌍을 만들고자 한다면, $k = O(\sqrt{n})$ 정도 뽑으면 겹치는 쌍을 기대할 수 있다. 증명은 생략.&lt;/p&gt;

&lt;h3 id=&quot;가정&quot;&gt;가정&lt;/h3&gt;
&lt;p&gt;폴라드-로 알고리즘이 잘 작동하기 위해서는, 큰 수 $m$을 소인수분해하되, $m$의 가장 작은 소인수 $p$가 작아야 한다. 예를 들어, RSA에서 쓰는 좋은 N - 즉, 큰 소수 2개를 곱한 수에서는 그 효율이 현저히 낮다. 100자리 소수를 2개 곱해서 얻은 200자리 합성수보다는, 20자리 소수 10개를 곱해서 얻은 수를 잘 소인수분해하는 알고리즘임을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h2&gt;
&lt;p&gt;$k$개의 정수 $u_1, u_2, \dots u_k$ 를 랜덤하게 선택하자. 이때, 생일 문제에 의해, $u_i \equiv u_j \mod p$ 인 $i, j$를 얻을 가능성이 상당히 높다. 그런데, 이는 다시 말하면 $u_i - u_j$가 (일반성을 잃지 않고 양수라고 하자) $m$과 $p$를 공약수로 가질 가능성이 상당히 높다는 뜻이다. 우리는 두 수의 gcd를 입력 비트 수에 대한 다항 시간에 찾는 유클리드 알고리즘을 잘 알고 있으므로, $m$의 어떤 소인수를 빠르게 찾을 수 있다는 의미가 된다. 다시 말해, $\binom{k}{2}$개의 $u_i - u_j$들과 $m$의 gcd를 확인함으로서 $m$의 어떤 약수를 얻을 확률이 상당히 높다는 뜻이다.&lt;/p&gt;

&lt;p&gt;그러나, $O(k^2)$ 개의 조합을 모두 검토하기는 너무 느리다. 폴라드-로 아이디어는 이 과정을 줄이는 것인데, $u_i$를 랜덤하게 뽑는 대신 $u_{i+1} = u_i^2 + 1$ 을 사용하는 것이다. 이 다항식 $f(x) = x^2 + 1$ 은 사실 어떤 다항식이든 크게 상관은 없으나, mod $p$에 대한 랜덤성을 해치지 않아야 하고, 계산이 너무 오래 걸리지 않아야 한다. 일반적으로 저렇게 생긴 다항식이 잘 작동함이 알려져 있으나 $x^2 + x + 1$ 같은걸 쓴다고 큰 문제는 없고… 다만 1차식을 쓰면 안 된다는 사실도 잘 알려져 있다.&lt;/p&gt;

&lt;p&gt;이런식으로 결정론적으로 계산하는 것의 장점은, $u_i$ 의 수열이 주기성을 갖게 된다. 우리가 어떤 주기성을 갖는 수열 $u_i$에서 주기를 찾고자 할 때는 Tortoise and Hare 라는 좋은 방법을 쓸 수 있는데, 이 방법은 다음과 같다.&lt;/p&gt;

&lt;p&gt;수열의 주기를 $r$이라고 할 때, $s \equiv t \mod r \Rightarrow u_s = u_t$ 가 된다. 따라서, $s$를 적당히 큰 (주기성을 보이는) $r$의 배수로 잡고, $t = 2s$로 잡으면 항상 $u_s \equiv u_{2s}$ 이다. 따라서, 우리는 $k$를 하나씩 늘리면서 $u_{2k} - u_k$ 만 확인하여도 반드시 주기를 놓치지 않음이 보장되며, 이때 주기성을 가지는 첫번째 $r$의 배수가 대략 $O(\sqrt{p})$ 정도 스케일이기 때문에 $k = O(\sqrt p)$ 정도 확인하면 그 안에 gcd$(u_{2k} - u_k, m)$ 가 1이 아닌 $k$를 기대할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;
&lt;p&gt;Niven 의 정수론 책에 수록된 예시는 다음과 같다.&lt;/p&gt;

&lt;p&gt;$m = 36,287$, $f(x) = x^2 + 1 \mod m$, $u_0 = 1$일 때, $u$의 수열을 계산하면…&lt;br /&gt;
$1, 2, 5, 26, 677, 22886, 2439, 33941, 24380, 3341, 22173, 25652, 26685, 29425, 22806$… 이다. 이때, 각 $k$에 대해 gcd$(u_{2k} - u_k, m)$ 를 계산하면, $u_{14} - u_7$에서 gcd$(u_{14} - u_7, m) = 131$ 이다. 131은 $m$의 약수이다.&lt;/p&gt;

&lt;h3 id=&quot;구현&quot;&gt;구현&lt;/h3&gt;
&lt;p&gt;위 알고리즘을 그대로 코드로 옮기면 된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;단, $u$ 수열을 미리 구해놓고 Tortoise-Hare를 돌리는 것은 어디까지 구해야 할지 모르는 상황에서는 별로 적절하지 않다. $x^2 + 1$ 은 구하기 쉬운 다항식이므로, 매 스텝마다 $y$는 두 스텝씩, $x$는 한 스텝씩 나간다고 생각하면서 진행시키자.&lt;/li&gt;
  &lt;li&gt;$u_0$는 랜덤하게 뽑았는데, 별로 상관은 없다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_prime&lt;/code&gt; 부분은 일반적인 소수 판정 함수를 쓰면 된다. 보통은 밀러-라빈 판정법을 많이 쓴다 (그냥 판정하면 느리니까).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mulmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__int128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PollardRho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mulmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mulmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mulmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_prime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PollardRho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h2&gt;
&lt;p&gt;앞서 설명한 바와 같이, Birthday Paradox에 의해 실제로 구해야 하는 $u$의 값은 $O(\sqrt p)$개이다. $n$에 대해서는 $p \leq \sqrt{n}$ 임을 가정하면 (소수가 아님은 밀러라빈 등으로 확인하자) $O(n^{1/4})$ 알고리즘이라고 할 수 있다. 이는 다항식 $x^2 + 1$ 이 진짜 랜덤한 수들을 준다는 가정 하에 이루어진 계산인데, 실제로는 당연히 뭔가 더 복잡하고 끔찍한 분석이 필요하다. 이쪽은 잘 모르기도 하니 일단은 넘어가기로 하자.&lt;/p&gt;

&lt;p&gt;당연히, 매우 큰 수를 다룰 때는 곱셈이나 모듈러 등이 유의미하게 오래 걸린다. 이 경우 적절하게 시간 복잡도에도 이런 항들을 곱해야 할 것이다. 우선은 64비트 (곱셈이 $O(1)$에 수행) 가정 하에서의 복잡도가 위와 같다고 알아두면 된다.&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="number-theory" /><category term="algorithms" /><summary type="html">Contents</summary></entry></feed>