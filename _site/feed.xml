<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-07-17T14:31:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gratus907’s Study Note</title><subtitle>Hello World!</subtitle><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><entry><title type="html">삼성 SCPC 예선 1라운드 풀이 / 후기</title><link href="http://localhost:4000/cp_rounds/SCPC-2021-Round1/" rel="alternate" type="text/html" title="삼성 SCPC 예선 1라운드 풀이 / 후기" /><published>2021-07-16T00:00:00+09:00</published><updated>2021-07-16T00:00:00+09:00</updated><id>http://localhost:4000/cp_rounds/SCPC-2021-Round1</id><content type="html" xml:base="http://localhost:4000/cp_rounds/SCPC-2021-Round1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#scpc&quot; id=&quot;markdown-toc-scpc&quot;&gt;SCPC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#문제-풀이--후기&quot; id=&quot;markdown-toc-문제-풀이--후기&quot;&gt;문제 풀이 / 후기&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-1-친구들&quot; id=&quot;markdown-toc-problem-1-친구들&quot;&gt;Problem 1. 친구들&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명&quot; id=&quot;markdown-toc-문제설명&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-disjoint-set&quot; id=&quot;markdown-toc-풀이-disjoint-set&quot;&gt;풀이 (Disjoint Set)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-2-이진수&quot; id=&quot;markdown-toc-problem-2-이진수&quot;&gt;Problem 2. 이진수&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명-1&quot; id=&quot;markdown-toc-문제설명-1&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-greedy&quot; id=&quot;markdown-toc-풀이-greedy&quot;&gt;풀이 (Greedy)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-3-no-cycle&quot; id=&quot;markdown-toc-problem-3-no-cycle&quot;&gt;Problem 3. No Cycle&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명-2&quot; id=&quot;markdown-toc-문제설명-2&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-greedy--graph&quot; id=&quot;markdown-toc-풀이-greedy--graph&quot;&gt;풀이 (Greedy + Graph)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-4-예약-시스템&quot; id=&quot;markdown-toc-problem-4-예약-시스템&quot;&gt;Problem 4. 예약 시스템&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명-3&quot; id=&quot;markdown-toc-문제설명-3&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-greedy--casework&quot; id=&quot;markdown-toc-풀이-greedy--casework&quot;&gt;풀이 (Greedy + Casework)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-5&quot; id=&quot;markdown-toc-problem-5&quot;&gt;Problem 5&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제-설명&quot; id=&quot;markdown-toc-문제-설명&quot;&gt;문제 설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-dsu-based&quot; id=&quot;markdown-toc-풀이-dsu-based&quot;&gt;풀이 (DSU-based)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#후기&quot; id=&quot;markdown-toc-후기&quot;&gt;후기&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#부록--버퍼-이야기-scpc-주의사항&quot; id=&quot;markdown-toc-부록--버퍼-이야기-scpc-주의사항&quot;&gt;부록 : 버퍼 이야기 (SCPC 주의사항)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;scpc&quot;&gt;SCPC&lt;/h1&gt;
&lt;p&gt;SCPC는 삼성전자 (정확히는 Samsung Research) 가 주관하는 알고리즘 문제풀이 대회로, 한국에서 열리는 기업 대회중 가장 큰 규모를 자랑하는 대회입니다. 한국의 코드잼이라고나 할까요.&lt;/p&gt;

&lt;p&gt;ICPC, UCPC 등 팀대회와는 달리 개인전이고, 예선 1라운드 - 예선 2라운드 - 본선으로 구성됩니다.&lt;/p&gt;

&lt;p&gt;예선 1라운드는 24시간, 예선 2라운드는 12시간이라는 엄청난 시간이 주어지고 지구력을 강하게 요구합니다. 또한 제출 기회가 10번(문제에 따라 20번)으로 제한되어 있다는 점도 특징입니다.&lt;/p&gt;

&lt;p&gt;참고로, 2020년 대회는 예선 1라운드를 통과하고 2라운드를 멋지게 말아먹었습니다. 저는 부분점수 시스템을 탓하기로 했습니다만 작년 대회 문제를 다시 stress-test 해보니 꼭 그렇지는 않은 모양입니다. 작년 대회에 대한 (감정이 많이 실린) 후기는 &lt;a href=&quot;https://gratus-blog.tistory.com/121&quot;&gt;여기&lt;/a&gt; 에 적혀 있습니다.&lt;/p&gt;

&lt;p&gt;작년에는 1차 예선 5번을 해결하지 못했지만, 올해는 시작 약 4시간 만에 모든 문제에서 만점을 받을 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/1884fd79ae1d82e347df360ba2645a98a53fe3170016d0cd18a3e88a4a4dfdd5.png&quot; alt=&quot;picture 1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;문제-풀이--후기&quot;&gt;문제 풀이 / 후기&lt;/h1&gt;
&lt;p&gt;시간복잡도에 대한 모든 언급은 테스트케이스 한개당 복잡도입니다.&lt;/p&gt;

&lt;p&gt;구현체를 업로드하긴 하곘지만, 대회중 구현한 코드라서 굉장히 바보같은 실수와 redundant한 구현이 있습니다.&lt;br /&gt;
코드를 정리해서 쓰지 않고 incremental하게 생각해서 그런데, codeground에 연습이 올라오면 정리를 해볼지도 모르겠습니다. 현재 코드가 라운드 중 제 생각의 과정을 그대로 반영해서 오히려 이런 글에 더 적절하다는 생각도 듭니다.&lt;/p&gt;
&lt;h2 id=&quot;problem-1-친구들&quot;&gt;Problem 1. 친구들&lt;/h2&gt;
&lt;h3 id=&quot;문제설명&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;$i$ 번 사람이 $i + D_i$ 번과 친구이고, 친구관계가 equivalence relation을 이룰 때, 친구 관계인 극대 그룹의 개수를 출력하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;극대 그룹이란 “현재 이 그룹 안에서 뽑은 임의의 2명이 서로 친구이면서”, “이 성질을 깨지 않고 이 그룹에 누군가를 추가할 수 없음” 을 말합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-disjoint-set&quot;&gt;풀이 (Disjoint Set)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;즉, equivalence class의 개수를 세는 문제입니다.&lt;/li&gt;
  &lt;li&gt;Disjoint Set Union (DSU) 또는 Union Find (UF) 라고 알려진 자료구조를 써서 쉽게 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;DSU의 구현체와 마지막에 개수를 어떻게 세느냐에 따라 $O(n \log^* n)$ 에도 풀 수 있지만, 저는 그냥 평범하게 merge by size &amp;amp; path compression을 쓰고 set을 써서 $O(n \log n)$ 으로 구현했습니다. 단 한번도 UF가 느려서 문제가 생기는걸 본적이 없습니다.&lt;/li&gt;
  &lt;li&gt;대략 8분 정도 만에 AC를 받았던것 같습니다. 어떤 대회든 시작하면 순간 심박수가 확 높아지는 제 심각한 단점에 의해 필요 이상으로 힘들었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-2-이진수&quot;&gt;Problem 2. 이진수&lt;/h2&gt;
&lt;h3 id=&quot;문제설명-1&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;N비트 비트열 $A$로부터 $B$를 다음과 같이 만듭니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B[i] = A[i - t] || A[i + t]&lt;/code&gt; (단, 인덱스가 1 - N 범위를 벗어나면 무시)&lt;/li&gt;
  &lt;li&gt;B가 주어질 때, A를 복원하는 문제입니다. 가능한 A가 여러가지이므로 이진수로 볼 때 가장 작은 - 즉, 사전순으로 가장 앞서는 답을 출력해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-greedy&quot;&gt;풀이 (Greedy)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사전순이라는 조건 때문에, 앞비트를 0으로 만들 수 있다면 무조건 0으로 만들어야 합니다. 따라서, 최대한 앞비트에 0이 많이 오게 Greedy하게 풀면 됩니다.&lt;/li&gt;
  &lt;li&gt;주의할 점은, $B_i$가 0이면 $A_{i - t}$ 와 $A_{i + t}$ 가 무조건 0이어야 하므로, 어떤 $A_j$ 들은 0으로 고정당합니다. 이것 때문에 앞과 뒤 중 앞을 1로 만들어야만 하는 (사전순으로는 뒤를 1로 만들고 싶겠지만) 상황들이 발생합니다.&lt;/li&gt;
  &lt;li&gt;저는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fix&lt;/code&gt; 라는 배열을 관리하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fix&lt;/code&gt; 배열에 True가 켜져 있으면 손을 못댄다고 생각하는 방식으로 구현했습니다.&lt;/li&gt;
  &lt;li&gt;대략 30분 정도 만에 AC를 받았습니다. fix를 생각하지 않고 그리디하게 했다가 뭔가 답이 안나와서 잠깐 고민했고, 버퍼 이슈 때문에 한번 TLE를 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-3-no-cycle&quot;&gt;Problem 3. No Cycle&lt;/h2&gt;
&lt;h3 id=&quot;문제설명-2&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Directed Acyclic Graph $G$와, 방향이 정해지지 않은 간선들이 주어집니다.&lt;/li&gt;
  &lt;li&gt;간선들에 정방향 (입력방향) 또는 역방향 (입력 반대방향) 을 줍니다. (각각을 0과 1로 표시)&lt;/li&gt;
  &lt;li&gt;목표는 방향을 다 정해서, 결과 그래프가 여전히 Acyclic하게 만드는 것입니다. 당연히 여러 개의 답이 있는 경우들이 있으며, 이런 경우에는 간선들을 0 1 로 표시했을 때 사전순으로 가장 앞서는 답을 출력합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-greedy--graph&quot;&gt;풀이 (Greedy + Graph)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Subtask 1은 간선개수 10개, 정점개수 10개이므로 $2^{10}$가지 경우의 수를 확인하는 풀이가 가능합니다. 이걸로 41 / 180점을 받습니다.&lt;/li&gt;
  &lt;li&gt;사전순을 일단 생각하지 말고, 사이클 없는 간선 방향 정하기만 생각해 봅시다. 여기까지는 굉장히 많이 알려진 문제이며, 주어진 DAG를 Topological sorting한 다음 Topological order를 기준으로 간선을 앞 -&amp;gt; 뒤로 모두 정해버리면 사이클이 발생하지 않습니다. 임의의 Directed Graph가 주어졌을때 사이클이 있는지 확인하는 방법 중, 위상정렬하고 back edge가 있는지 보는 방법이 있음을 알고 있다면 이 방법은 쉽게 떠올릴 수 있습니다. 제가 PS를 처음 시작하고 얼마 안되어 codeforces에 이 문제가 한번 나왔는데 한참 생각해서 풀고 기분이 꽤 좋았던 기억이 있습니다.&lt;/li&gt;
  &lt;li&gt;여기까지, Subtask 2를 해결할 수 있으며, 52 / 180점을 받습니다. 서브태스크 1과 함께하면 93 / 180점입니다.&lt;/li&gt;
  &lt;li&gt;문제 전체를 해결하기 위해서는 조금더 잘 생각해볼 필요가 있습니다. 먼저, 사전순 조건 때문에 만약 가능하다면 항상 앞간선에 0번방향을 부여하고 싶다는 사실을 기억합시다.&lt;/li&gt;
  &lt;li&gt;$n \times n$ 의 비트 행렬 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 이라는걸 생각하겠습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][j]&lt;/code&gt; 는, $i$ 에서 $j$로 가는 경로가 있음을 의미합니다.&lt;/li&gt;
  &lt;li&gt;$(u, v)$ 간선의 방향을 정하는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[v][u]&lt;/code&gt; 가 True이면 $u \to v$ 방향으로 간선을 줄 수 없습니다.&lt;/li&gt;
  &lt;li&gt;그렇지 않다면, $u \to v$ 방향으로 간선을 줄 수 있으므로 주어야 합니다.&lt;/li&gt;
  &lt;li&gt;이제, 간선을 추가했다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 업데이트해야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 업데이트하는 것은
    &lt;ul&gt;
      &lt;li&gt;$u$ 에 도달 가능한 모든 정점 $i$에 대해, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][u]&lt;/code&gt; 가 참인 모든 $i$에 대해&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][j]&lt;/code&gt; 에 $i \to u \to v \to j$ 경로의 존재성을 반영합니다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][j] |= R[v][j]&lt;/code&gt; 를 해줘야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서, 각 간선을 볼때마다 최대 $O(n^2)$ 칸의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 업데이트해야 하기 때문에, $O(n^2 k)$ 알고리즘이 됩니다.&lt;/li&gt;
  &lt;li&gt;$n = 500, k = 2000$ 이므로, 이 시간은 기분이 몹시 나쁩니다. $500 \times 500 \times 2000$ 짜리 테스트케이스 한개면 모를까, 그걸 70개 해결할 수는 없어 보입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::bitset&lt;/code&gt; 으로 관리하면, 시간복잡도는 줄어들지 않지만 비트연산을 묶어서 처리함으로써 64배 빨라집니다. 이를 이용하여, $O(n^2 k)$ 알고리즘을 시간내에 구겨넣을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;bitset을 쓰는 추한 풀이가 싫다면, 매번 간선을 추가할때마다 간선을 0-방향으로 추가해보고 사이클이 있는지 검증하고, 1-방향으로 추가해보는 식으로 $O(nk)$ 에도 풀 수 있다고 합니다. 어떻게 이걸 생각을 못했지????? 이건 라운드가 끝나고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhdroid&lt;/code&gt;랑 디스커션하다가 알았고, bitset을 쓰는 추한 풀이로 욕을 먹었습니다. ㅎㅎ;;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 처음에 바보같이 DFS로 계산하는 과정에서 실수를 해서, 이문제 AC를 받는데 무려 1시간 30분 정도가 걸렸습니다. (1시간 58분 AC) 중간에 혹시 못풀수도 있겠다는 공포에 52점을 먹는 등 (22.5시간이 남았음에도…) 24시간 대회는 대회 전략을 고려하지 않고 편한 마음으로 PS를 해야하는데 제가 그게 좀 안 됩니다. 작년 2차 3번의 악몽때문에 제출 기회 제한을 두려워하는 것도 좀 있습니다. 중간에 4번을 좀 생각하다가 돌아와서, 4번은 좀 빨리 풀었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-4-예약-시스템&quot;&gt;Problem 4. 예약 시스템&lt;/h2&gt;
&lt;h3 id=&quot;문제설명-3&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;$2$행 $m$열로 방들이 있고, 같은 열의 위아래 행들과 같은 행의 양 옆 열들을 ‘인접’ 하다고 정의합니다.&lt;/li&gt;
  &lt;li&gt;사람 $2m$ 명이 각각 스트레스 지수를 가지고 있고, $n$개 그룹으로 나뉘어 있습니다.&lt;/li&gt;
  &lt;li&gt;인접한 방에 다른 그룹의 사람을 배치하면, 그 두 방에 들어간 사람의 스트레스 지수 합만큼 페널티가 발생합니다.&lt;/li&gt;
  &lt;li&gt;이를 최소화하는 방 배치를 찾고자 합니다.&lt;/li&gt;
  &lt;li&gt;재밌게도, 각 그룹은 5명 이상이라는 조건이 있습니다. 이 조건이 없으면 문제가 정말 끔찍할 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-greedy--casework&quot;&gt;풀이 (Greedy + Casework)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어렵지만 재밌었습니다. 먼저, 그룹 $i$의 사람 숫자가 실제로 몇명인지보다는 홀수인지 짝수인지가 중요함을 관찰합니다.&lt;/li&gt;
  &lt;li&gt;왜냐면, 어차피 같은 그룹의 사람들끼리 붙여주면 그 벽에서는 페널티가 발생하지 않고, 페널티가 발생하는 경우는 아래 케이스들밖에 없기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../images/132e43e2b169d80f9b5245bff9986d0214096cfa2e192ee741ef2c06cb2d20bd.png&quot; alt=&quot;picture 1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;잘 관찰해 보면, 홀수 블록이든 짝수 블록이든 끝 4명정도만 중요합니다. 대신 홀수블록이 포함된 연산에서는 2번 페널티를 일으키는 사람이 있게 됩니다.&lt;/li&gt;
  &lt;li&gt;또한, 가장자리 블록은 스트레스를 덜 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;홀수 블록과 짝수 블록에 대해 다음을 계산합니다. 각 블록의 스트레스 지수가 작은 사람부터 정렬했다고 합시다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;(홀수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3 = 2 * s[0] + s[1]&lt;/code&gt; 은 가장자리 홀수 블록이 다른 홀수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(홀수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5 = 2 * s[0] + s[1] + s[2] + s[3]&lt;/code&gt; 은 가장자리가 아닌 홀수 블록이 한쪽으로 다른 홀수 블록과, 다른 쪽으로 짝수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(짝수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2 = s[0] + s[1]&lt;/code&gt; 은 가장자리 짝수 블록이 다른 짝수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(짝수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4 = s[0] + s[1] + s[2] + s[3]&lt;/code&gt; 은 가장자리가 아닌 짝수 블록이 좌우로 다른 짝수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(짝수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6 = 2 * s[0] + 2 * s[1] + s[2] + s[3]&lt;/code&gt; 은 가장자리가 아닌 짝수 블록이 좌우로 홀수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서브태스크 1, 모든 그룹이 짝수명일 때는 가장자리 두 블록은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt;, 나머지 블록들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 만큼 스트레스를 발생시킵니다. 따라서, 모든 블록의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 를 더한 다음, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2 - l4&lt;/code&gt; 값이 가장 작은 두 블록에 대해서만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt;로 바꿔치기하면 됩니다.&lt;/li&gt;
  &lt;li&gt;서브태스크 2, 모든 그룹이 홀수명일 때도 거의 똑같습니다. 다만 이때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3&lt;/code&gt;이 됩니다.&lt;/li&gt;
  &lt;li&gt;여기까지 해서 88 / 190점을 받을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이제, 다시 경우를 나눕니다. 여기서 하나 의문을 가질만한 것은, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt; 이 어떨때 필요한지 생각하는 것입니다.
    &lt;ul&gt;
      &lt;li&gt;(홀수, 짝수 블록 여러개, 홀수) 블록이 있는데, 이 블록들이 가장자리가 아닌 곳에 배치한다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5 + l6 + l6 + l6 + ... + l5&lt;/code&gt; 가 될 것입니다. (각 블록의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5, l6&lt;/code&gt; 값을 보고 있으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6 + l6&lt;/code&gt; 이 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;이 아니라, 각 블록의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;-값을 의미합니다)&lt;/li&gt;
      &lt;li&gt;그런데, (홀수, 홀수, 짝수….) 로 배치를 바꾸면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5 + l5 + l4 + l4 + .... + l4&lt;/code&gt; 를 지불하게 됩니다. 따라서, ‘가장자리 이득’ 을 보고 싶은 상황이 아니라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;은 아예 필요가 없습니다.&lt;/li&gt;
      &lt;li&gt;같은 방법으로 (벽, 홀수, 짝수, 짝수, … 홀수) 를 분석하면, 이것도 이득이 없습니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;이 말이 되는 유일한 상황은, (벽, 홀수, 짝수, 짝수, …., 홀수, 벽) 인 상황입니다.&lt;/li&gt;
      &lt;li&gt;또한, (홀수, 짝수, 짝수, …, 홀수, 홀수, 짝수, 짝수, … 홀수) 도 잘 분석해 보면 홀수블록들끼리 묶어주는게 이득임을 알 수 있기 때문에, 경우의 수를 잘 나누면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;이 말이 되는 유일한 상황은 위 상황에 추가로 홀수가 벽에 붙은 저 두개밖에 없어야 함을 압니다.
직관적으로 홀수블록의 세번째, 네번째 사람 스트레스값이 너무 커서 이 사람들한테 벽에 붙은 방을 주는게 갈등의 절대적인 개수를 줄이는 것보다 이득이라고 생각하면 됩니다.&lt;/li&gt;
      &lt;li&gt;따라서, 이 경우는 별도로 계산합니다. 홀수 블록 두개의 l3와 나머지의 l6을 더하는 경우가 되겠습니다.&lt;/li&gt;
      &lt;li&gt;이외에는, 한쪽 벽에 (홀수, 홀수) 블록이 박히는 경우를 생각해 줘야 합니다. 이것도 l3, l5 더하고 나머지는 다 l4를 더하다가 맨 오른쪽 끝 블록에서는 l2를 더하는 것이므로, 어렵지 않게 계산 가능합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;홀수블록이 2개보다 많이 있다고 가정합시다. 이제, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;은 아예 생각할 필요가 없습니다.&lt;/li&gt;
  &lt;li&gt;홀수블록은 가장자리에 들어가면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3&lt;/code&gt;, 그외에는 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5&lt;/code&gt;의 스트레스를, 짝수블록은 각각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;따라서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 들을 모두 더해주고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3&lt;/code&gt; 나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt; 로 바꿀 수 있는 기회를 두번 준다고 이해하면 됩니다. 이건 struct에 점수를 계산하는 함수를 몇개 구현하면 정말 이쁘게 구현할수 있습니다.&lt;/li&gt;
  &lt;li&gt;말하는것보다 코드를 보면 조금더 이해가 쉽습니다.&lt;/li&gt;
  &lt;li&gt;대략 1시간 정도 걸려서, 3시간 02분 시점에 AC를 받았습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;을 고려하지 못해서 2번 틀렸고, 단순 코딩 실수로 1번 틀렸습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-5&quot;&gt;Problem 5&lt;/h2&gt;
&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;두가지 쿼리가 주어집니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 i j k&lt;/code&gt; 쿼리는, $X_i - X_j = k$ 임을 의미합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2 i j&lt;/code&gt; 쿼리는 $X_i - X_j$ 값을 묻습니다.&lt;/li&gt;
  &lt;li&gt;1번쿼리로 주어진 상대적인 정보만을 가지고 2번쿼리의 값을 계산할 수 있다면 계산하고, 계산하지 못한다면 ‘비교 불가능’을 출력합니다.&lt;/li&gt;
  &lt;li&gt;단, 1번 쿼리가 inconsistent하게 주어질 수 있습니다. 만약 2번쿼리가 들어왔는데 $X_i - X_j$가 여러 가지가 가능해서 계산이 불가능하다면 이를 출력합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-dsu-based&quot;&gt;풀이 (DSU-based)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;의도한 것인지 알 수 없으나, 백준에 대단히 비슷한 문제가 있습니다. &lt;a href=&quot;https://www.acmicpc.net/problem/3830&quot;&gt;3830번&lt;/a&gt; 입니다.&lt;/li&gt;
  &lt;li&gt;3830번과 이 문제의 차이는 Inconsistency의 유무밖에 없습니다. 그 외에는 모든점에서 동일합니다.&lt;/li&gt;
  &lt;li&gt;3830번은 Platinum III 이긴 하지만, 비교적 많이 풀린 문제이므로 구글링해보면 솔루션은 많이 있습니다. 다시 설명하기는 너무 기니까 대충 요약하자면, DSU를 쓰되, DSU에 추가하면서 이 노드와 이 노드가 포함된 집합의 루트와의 차를 기억하면서 DSU를 쓰면 됩니다.&lt;/li&gt;
  &lt;li&gt;이 코드로 서브태스크 1, 3 (inconsistency 없음) 을 쉽게 풀 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이제, Inconsistency를 생각해 봅시다. 만약 현재 $x_1, x_2, x_3$ 에 대해 $x_1$ 을 0이라고 할 때 relatively $x_2 = 3, x_3 = 2, x_4 = 6$ 이라는 정보가 있다고 합시다.
    &lt;ul&gt;
      &lt;li&gt;$x_2 - x_3 = 1$ 이라는 정보가 주어지면 무시하면 됩니다.&lt;/li&gt;
      &lt;li&gt;만약, $x_2 - x_3 = 2$ 와 같이 틀린 정보가 주어지면, $x_2$의 relative한 값을 이제 알 수 없게 됩니다.&lt;/li&gt;
      &lt;li&gt;재밌는 사실은, 아무 상관 없어 보이는 $x_4$ 도 미지의 값이 된다는 점입니다. 그 이유는, $x_3$ 이 ?가 된 상황에서 위 정보로부터 $x_4 - x_3 = 4$ 와 같은 정보도 implicit하게 주어져 있다고 가정해야 하기 때문입니다.&lt;/li&gt;
      &lt;li&gt;따라서, ?와의 차이를 계산당하는 과정에서 $x_1$을 루트로 하는 트리 전체가 ?가 되어 버립니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그러므로 DSU를 하면서, 루트와의 차이 뿐 아니라 이 노드가 이미 망했는지 여부까지 같이 들고 다니면 됩니다. 모든 노드에 망했다는 정보를 뿌리기에는 시간이 너무 많이 들기 때문에, 루트에만 저장해 놓고 ‘이 트리가 통째로 망했다’ 라고 기억하면 됩니다. 저는 DSU에서 생각하다가 살짝 꼬여서 find하면서도 정보를 갱신하게 해놨는데 아마 필요 없는 것 같습니다.&lt;/li&gt;
  &lt;li&gt;3830을 풀어봤기때문에 1시간 정도 걸려서 4시간 쯤에 AC를 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;후기&quot;&gt;후기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;작년 1차보다는 문제가 많이 쉽다고 느껴졌습니다. 특히 후반 문제가 많이 쉬워졌습니다. 작년에는 1차 예선 4번에 금광세그가 출제되고, 5번문제가 충격적으로 어려워서 오전 9시에 시작한 대회가 저녁시간까지 5번 만점자가 한자리수, 4번이 30여명 정도밖에 없었던 기억이 있습니다. 작년에 비해 대회 4시간 만에 4번, 5번 만점자가 40여명 나왔네요.&lt;/li&gt;
  &lt;li&gt;작년에는 2번부터 DP를 prefix sum으로 최적화하는 등 ‘시간 복잡도를 낮추기 위한 아이디어’ 를 요구했었습니다. 그에 비하면 이번 2번은 그냥 그리디인것도 차이가 명확해 보입니다.&lt;/li&gt;
  &lt;li&gt;저는 체감상 4번이 5번보다 어려웠습니다. 실제 만점자수도 현재 (대회 절반 시점) 127 : 79인데, 보통 4번을 먼저 읽을 것임을 고려할때 이정도면 4번이 5번보다 어렵다고 느낄만한 여지도 충분하다고 생각합니다. 3번과 4번의 차이도 1.5배밖에 안 나네요.&lt;/li&gt;
  &lt;li&gt;재밌었습니다. 다만… 2차를 통과할 수 있을지는 솔직히 자신은 별로 없습니다. 반반 정도 봅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;부록--버퍼-이야기-scpc-주의사항&quot;&gt;부록 : 버퍼 이야기 (SCPC 주의사항)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주의 : 제 컴퓨터구조/시스템 프로그래밍 실력은 매우 미약하기 때문에 올바르지 않은 주장이나 사실이 있을 수 있습니다. 건설적인 피드백을 200% 환영합니다.&lt;/li&gt;
  &lt;li&gt;SCPC의 부분점수 시스템은 굉장히 특이합니다.&lt;/li&gt;
  &lt;li&gt;구체적으로, 문제가 모두 multi-testcase 형으로, 처음에 testcase의 개수 T를 받고 T개의 TC를 해결하는 식입니다. 예를 들어, TC i의 답이 i라고 하면, 다음과 같이 출력합니다.
    &lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Case #1
1
Case #2
2
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;서브태스크 1, 2, 3이 있고, 각각이 TC 10개 씩이라면, 1~10, 11~20, 21~30 이런 식입니다.&lt;/li&gt;
  &lt;li&gt;그래서, 23번 TC가 틀리고 그 전까지 다 맞았다면 서브태스크 1과 2의 점수를 받습니다.&lt;/li&gt;
  &lt;li&gt;여기서 시간 초과가 발생하는 상황을 생각해 보겠습니다. 예를 들어 23번 테스트케이스를 수행하다가 시간 초과가 났습니다. 우리의 직관은 23번 TC가 WA인것과 TLE인 것이 동치이므로, 역시 서브태스크 2에 대한 점수를 받을 것으로 예측할 것입니다.&lt;/li&gt;
  &lt;li&gt;하지만, C언어의 출력은 Buffered I/O이기 때문에, (어떤 이유로든) 17번 TC까지는 출력이 되었지만 18~22번 TC까지의 결과는 아직 버퍼에 들어 있을 수도 있습니다. 즉, “현재까지의 출력” 은 17번 TC까지의 정답을 가지고 있고, “버퍼” 가 18번~22번 TC까지의 정답을 가지고 있는데 TLE가 났으면, SCPC는 버퍼에 든 내용물을 무시하고 17번 TC까지 맞은것으로 간주, 서브태스크 1에 대한 점수만 받을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이러한 문제를 해결하기 위해, SCPC는 printf를 이용하는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setbuf(stdout, NULL)&lt;/code&gt; 할 것을 권하고 있습니다.&lt;/li&gt;
  &lt;li&gt;재밌는 사실은, 저걸 하면 매 printf마다 버퍼를 비우기 때문에, printf할 내용이 많으면 조심해야 합니다. 예를 들어, 5만글자짜리 string을 하나의 string으로 묶어서 출력하는 것에 비해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 를 5만번 호출하는 경우 후자는 버퍼를 5만번 처리하기 때문에 후자는 미친듯이 느립니다.&lt;/li&gt;
  &lt;li&gt;예를 들어, 오늘 2번(이진수) 의 제 코드 중, 이 부분은 시간 초과를 받습니다 ($n$ 은 5만입니다)
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;하지만, 이 부분을 이렇게 바꾸면 매우 넉넉하게 통과합니다.
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;사실 printf를 5만번 호출하면 원래 한번에 찍는것보다 느린게 맞습니다. 그러나, 버퍼를 매번 비우도록 강제하는 setbuf 때문에 원래 느려야 할 것보다 더 많이 느립니다.&lt;/li&gt;
  &lt;li&gt;결과적으로, 부분점수를 받기 위해서는 코드가 더 느려질 위험을 감수해야 합니다. 특히 출력물이 10만줄씩 되는 5번문제 같은 경우, ‘원래 맞을 수 있는 코드를 버퍼 비우다가 TLE나는게 아닌지’ 도 고민해야 합니다.&lt;/li&gt;
  &lt;li&gt;이런 방법으로 채점을 하는 장점에 대해서는 전혀 알지 못합니다. 구글 코드잼도 출력 양식이 거의 같은데, 내부적으로 같은 방법으로 채점하고 있는지도 모릅니다. 다만 이 방법이 절대적인 프로그램의 실행 횟수를 줄여서 채점 속도에는 조금 도움이 될 것 같습니다.&lt;/li&gt;
  &lt;li&gt;여튼, 작년에도 저는 SCPC 2차예선에서 저걸로 한번 당했습니다. 올해도 어김없이 이 이슈로 한번 틀렸기 때문에, 조심해야 할 부분을 같이 공유해보고 싶었습니다.&lt;/li&gt;
  &lt;li&gt;채점이 특이한 대회는 사실 이거 말고도 꽤 있습니다. 대표적으로 해커컵…&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp_rounds" /><category term="algorithms" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1</title><link href="http://localhost:4000/cp_practice/team_practice_1/" rel="alternate" type="text/html" title="2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1" /><published>2021-07-14T00:00:00+09:00</published><updated>2021-07-14T00:00:00+09:00</updated><id>http://localhost:4000/cp_practice/team_practice_1</id><content type="html" xml:base="http://localhost:4000/cp_practice/team_practice_1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## Our Team
이번 UCPC 팀은 이렇게 구성되게 되었습니다. 
- `gyuni` : DGIST에서 석사과정을 올 8월에 마무리하고 졸업합니다. ICPC는 석사 1년차까지, UCPC는 석사과정 (석박통합 2년차까지) 임을 감안하면 사실상 이번 UCPC가 대학생 프로그래밍 대회의 마지막을 장식하게 될 것인지라, 저 개인적으로 매우 영광으로 생각하고 있습니다.
- `dlwocks31` : 병특 중에 있습니다. 제 블로그에도 여러번 언급되었지만... 해시코드를 함께하고 있는 Little Piplup 팀으로, 둘이서 1:1 연습을 많이 해봤습니다만 전통적인 CP대회를 같이뛰는건 처음입니다.
- `gratus907`

세명의 Codeforces max rating은 2100+지만, 저랑 dlwocks는 파킹에 실패해서 퍼플로 낙하했습니다. 퍼플+퍼플+오렌지 팀 정도로 볼 수 있을것 같습니다.

전력을 잠깐 생각해 보자면, `gyuni`님의 스타일은 제가 잘 모르지만 저랑 `dlwocks31`은 동일 레이팅의 2인 팀치고는 아마도 꽤 강할 것 같습니다. 제가 상대적으로 조합/정수를 잘 풀고, `dlwocks31`이 자료구조/구현 문제를 잘 풀다 보니... 그래서, 3인팀도 나름대로 스타일은 명확하고 잘 맞는것 같습니다. 

작년에 `dlwocks31` / `coffeetea` / `diordhd` 팀이 2020 ICPC 예선에서 12등인가 하는 놀라운 성적을 얻었는데, 객관적인 전력은 그 근처 어딘가라고 생각합니다. 

## Practice : Sogang 2020 Div1
3시간 정도밖에 시간이 없어서, 돌만한 셋이 별로 없었습니다. Japan ICPC 예선전 정도가 3시간인데, 난이도가 널뛰기하는데다가 백준에서 푼사람이 아무도 없어서 데이터의 올바름을 확신하기 어렵기도 하고... 
서강대학교 대회는 Div 1 과 Div 2로 나뉘어 있고, 원래는 개인대회 3시간짜리 대회입니다. 난이도가 실-골-플-다 문제가 1-2-3-2로 분포된 형태가 UCPC 예선이랑 비슷할것이라고 판단, 이 대회를 3시간 3PC로 돌아보기로 했습니다.

## Phase 0 : Start 
리얼리티를 위해 문제 순서를 shuffle 하고, `gyuni-gratus907-dlwocks31` 순서로 3 3 2 나눠 읽기로 랬습니다. 

## Phase 1 : Easy Problems
### A. 파일 정리 
Solve : `dlwocks31`  
Code : `dlwocks31` (00:07)
'쉬운 구현문제니까 그냥 잡을게요' 라고 말하고 7분에 AC를 받아왔습니다. 무슨문제인지 안읽어서 모르겠습니다.

------

### F. 폰친구
Solve : `gratus907`  
Code : `gratus907` (00:30)  
재밌는 조합 문제였습니다.  
$N$ 명에게 $K$ 개를 나눠주는데 1인당 $m$개 이상 $M$개 이하를 받는 경우의 수를 계산하는 문제입니다. 미리 $m$개씩 나눠주고 시작하면, $L = K - mN$ 개의 사탕을 $N$명에게 나눠주되 각자가 $x = M - m$ 개 이하로만 받는 경우의 수를 세면 됩니다.  

먼저, $x$개 조건이 없다면 답은 중복조합을 이용하여 $_N H _L$ 개입니다. $x$개 조건은 여사건을 이용하여 계산할 수 있습니다. 반대로, '누가 $x+1$개 이상을 받을지' 를 미리 정하고 갑시다. $u$명이 $x+1$개 이상을 받는다면, 미리 얘네들한테 $x+1$개씩 나눠주고 나머지들에게 사탕을 잘 나눠주는 경우를 생각하면 됩니다. 따라서, $_N H _{L - (x+1)u}$ 가 될 것입니다.

그러나, 이 방법의 문제는 '나머지들에게 잘 나눠줄때' 나머지들 중에 또 $x+1$개 이상을 받는 사람이 있을수도 있다는 것입니다. 이를 포함-배제 원리를 이용하여, 다음과 같이 처리하면 됩니다.
$$\sum_{u = 1}^{n} (-1)^u \times {_N C _u} \times {_N H _{L - (x + 1)u}}$$

------

### C. 연료가 부족해
Solve : `gyuni`  
Code : `gyuni` (00:33, 1WA)  
역시 쉬운문제라고 판단하고 30분 정도 시간에 AC를 받았습니다. DP였다고 합니다. 역시 무슨문제인지 안읽어서 잘 모르겠습니다.

------

### B. 컨설팅 
Solve : `gratus907`  
Code : `gratus907` (00:58, 1WA)  
쉬운 문제인데 구현이 귀찮아서 조금 시간이 걸렸습니다. 요점은, Greedy하게 정말 필요할때만 WAIT를 걸어주면 된다는 것을 어렵지 않게 알 수 있고, WRITE의 시작점들 / 도착점들 / (시작, 도착)Pair 들을 각각, READ의 대상을 하나. 이렇게 해서 집합들을 관리하고 조건을 잘 그대로 코딩하면 됩니다. 파이썬 썼는데 set같은걸 shallow copy한다는걸 까먹어서 1틀했습니다.

------

## Phase 2 : 3 Graph Problems
### E. 사탕 배달 
Solve : `dlwocks31`, `gyuni`  
Code : `dlwocks31` (00:52, 1WA)  
뭔지 잘 모르겠지만 트리에서 뭔가를 하는 문제입니다. 제가 파이썬 구현으로 싸우고 있는 사이에 팀원 두명이 AC를 받아왔습니다. 

------

### D. 에어컨 설치
Solve : `gyuni`, `dlwocks31`, `gratus907`  
Code : `gyuni` (01:36)  
문제는 다음과 같습니다.
- $\Z^3$에 정점들이 뿌려져 있고 거리가 1인 정점들을 '인접하다' 고 정의하여 그래프를 만듭니다.
- 그래프에 '에어컨' 을 설치합니다. 이 에어컨 한 대는 설치한 정점과 그 인접한 정점을 커버합니다.
- 이제, 최소 개수의 에어컨을 달아서 모든 정점을 커버하는 문제입니다.

제가 B번을 맞고 갔을때는 이미 어느정도 둘이 솔루션을 discuss하고 있었던 중이었습니다. 여기에 같이 아이디어를 구상하고 `gyuni`님이 코딩을 바로 들어갔습니다.
- 먼저, 어차피 각 connected component별로 생각해야 하므로 그래프가 연결되어 있다고 하겠습니다.
- 이제, 이 문제는 **최소 버텍스 커버** 와 같은 문제임을 압니다.
- 이 문제는 NP-Complete이지만, 이분 그래프에 대해서는 빨리 풀 수 있음이 알려져 있습니다.
- $(a, b, c)$ 에 대해, $a + b + c$의 홀짝성에 따라 정점에 색깔을 칠해주면 이 그래프가 이분 그래프임을 보일 수 있습니다.
- 따라서, 이 그래프에서 최소 버텍스 커버를 짜면 됩니다.

저는 이걸 알아도 이분그래프에서 최소 버텍스 커버를 어떻게 짜는지 자신이 없었지만, `gyuni`님이 그건 짤수 있다고 확신을 줬기 때문에 (:fan:) 맡기고 저랑 `dlwocks31`은 남은 2문제를 잡으러 갔습니다.

------


코딩을 맡긴게 대략 01:00 시점쯤이고, 5AC에 1문제는 코딩만 남은 상황이었기 때문에 난이도에 대해 심각한 의심이 있었습니다. 실버 1, 골드 2, 플레 2문제 + 1문제 구상까지를 1시간에 밀었다는것도 그렇지만, 지금까지 문제들 중 플레급이라고 생각이 드는건 A번 정도였기 때문입니다. C번은 제가 직접 문제를 보지 않아서 뭐라고 할수가 없고, F번은 나중에 생각해보면 포함배제 쓰는 조합문제가 익숙하지 않다면 어려울것 같기도 합니다만 그럭저럭 꽤 많이 나온 스타일의 문제였지 않나 싶습니다.

------

### G. Confuzzle
Solve : `dlwocks31`, `gratus907`  
Code : `dlwocks31`  
- 정점 $n$개의 트리가 주어지고, 각 노드가 $1 \leq c_i \leq n$ 의 색깔을 가집니다. 이때, 색깔이 같은 노드 페어 $v_i, v_j$들 중, 서로의 거리가 가장 가까운 노드 간의 거리를 계산하는 문제입니다. 
- 트리에서 두 정점 사이의 거리는 LCA를 이용하면 ($O(n \log n)$ 전처리를 하고) $O(\log n)$에 계산할 수 있습니다. Range Minimum Query를 잘 이용하면 $O(1)$에도 할 수 있음이 알려져 있지만, 실제로 이게 필요한 상황은 본적이 없는것 같습니다. 
- 다만, 이때 $O(n^2)$ 개의 pair를 확인해야 하므로, $O(n^2 \log n)$ 시간이 걸리는데, 도저히 답이 없는 복잡도입니다.
- 각 점마다 map에, &quot;이 노드를 루트로 하는 서브트리에서, 색깔이 $c$ 인 노드들 중 이 노드에서 가장 가까운 노드까지의 거리&quot; 를 저장한다고 생각합니다. 이를 $M_i$ 맵이라고 생각하겠습니다.
- 내 자녀 노드의 $M_i$들을 모두 알고 있다면, 이들을 합치는 과정에서 두개 이상의 서브트리가 같은 색깔의 노드를 가지고 있다면 이들까지의 거리를 이용하여 페어의 거리를 계산할 수 있습니다. 이 방법이 최단 거리 페어를 항상 찾을 수 있음은 서브트리에 대해 재귀적으로 증명 가능합니다. 
- 그러나, 이 방법은 잘 생각해보면 맵을 합치는 데 $O(n \log n)$ 까지 걸리기 때문에, $O(n^2 \log n)$ 시간이 걸립니다.
- 트리에서 두 Map을 합치는데, `small-to-large` 테크닉을 적용 [(ex : BOJ 4002번 풀이 링크)](/algorithms/BOJ4002/) 하면, $O(n \log^2 n)$ 시간으로 줄일 수 있습니다.

Small to Large 테크닉을 적용하자는 말을 `dlwocks31`이 거의 5분만에 했고(:fan:), 10분만에 코딩했으나 사소한 실수로 디버깅에 40분이 걸렸습니다. 무려 $n^2 \log n$ 솔루션을 코딩해서 스트레스테스트로 반례를 찾아야만 했습니다. :(  
별론으로, 정해가 상당히 멋집니다. 각 색깔에 대해 그 색깔의 노드가 몇개 없으면 ($k \leq \sqrt{n}$) $O(k^2 \log k)$ 알고리즘을 돌리고, 노드가 많으면 멀티소스 BFS를 돌리는... sqrt decomp스타일 아이디어였습니다.  
하지만 여전히 dlwocks31의 스몰투라지가 복잡도면에서 더 좋은 풀이일 뿐 아니라, 코딩도 매우 간단합니다. :fan:

------

## Phase 3 : Pizza Madness

해결하지 못한 H번에 대한 이야기입니다.
- 어떤 수열 $A$와 작은 수열 $B$가 주어지고, $A$를 원형으로 연결했을 때 $B$에 해당하는 패턴을 매칭하는 문제입니다.
- 단, 패턴이 실제로 맞을 필요는 없고, '원소들 간의 순서' 가 맞으면 됩니다. 예를 들어, (4, 3, 6) 과 (2, 1, 3) 을 매칭된 것으로 본다는 것입니다. 

- 다양한 아이디어들이 등장했습니다. 각 수를 좌표압축해서, 좌표압축된 $n$개의 수를 라빈카프처럼 해싱하자는 아이디어라던가...
- 해싱된 수열의 일부를 오른쪽 / 왼쪽으로 미는 연산이 기존의 해싱에서 불가능합니다. 
- 미는 부분이 구간을 연산한다는 점에 착안하여 각 노드가 구간의 라빈카프 해시값을 가지고 있는 세그먼트 트리 같은 아이디어가 나오고
- 세그먼트 트리도 중간에 노드를 날리지는 못하기 때문에, 여기에 무슨 스플레이 트리를 써서...

=&gt; **이게 될리가 없습니다**. 그렇게 한시간동안 셋이서 해괴한 트리들을 꺼내다가 연습을 종료했습니다.  
결국 답은 KMP 알고리즘의 변형이던데, 꽤 멋진 문제인것 같네요.

------

## 후기 
비대면 팀연습이지만 굉장히 재밌었습니다. 배울것도 많았고..ㅋㅋㅋ 특히 작년 ICPC같은경우는 제가 나이로나 PS짬밥으로나 맏이였는데 이번에는 양쪽으로 다 막내인 팀이라서 (?) ㅋㅋㅋ 또 색다른 팀인듯 합니다.  
남은 기간 공부도 재밌게 하고, 무엇보다 대회를 즐길 수 있을 것 같아서 기대가 됩니다.  


Little Piplup을 2명 2명 (저랑 dlwocks / coffeetea와 dhdroid) 먼저 갈라놓고 새 팀원을 찾아보기로 했을때 얘기했던것중 하나가 PS를 즐길수 있었으면 한다는 것이었습니다. 사실 무슨 뉴텔라급이 아닌이상 UCPC는 수상할 수 있는 대회가 아니고, 지금으로써는 예선 통과를 걱정하는 상황도 아니기 때문에 순수하게 문제풀이의 즐거움을 추구하기로 했습니다. 2019년 말~2020년 초에는 정말 PS를 즐겼다고 생각하는데, 그후로 학교공부가 바빠지면서 그러지 못했다가 이제 다시 그때의 마음가짐이 돌아오는것 같아서 개인적으로 굉장히 행복합니다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp_practice" /><summary type="html">Contents</summary></entry><entry><title type="html">논문읽기 : DELTACON</title><link href="http://localhost:4000/cs-adventure/deltacon/" rel="alternate" type="text/html" title="논문읽기 : DELTACON" /><published>2021-07-12T00:00:00+09:00</published><updated>2021-07-12T00:00:00+09:00</updated><id>http://localhost:4000/cs-adventure/deltacon</id><content type="html" xml:base="http://localhost:4000/cs-adventure/deltacon/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

처음으로 정리해볼 논문은 2013년 SDM(SIAM International Conference on Data Mining)에 발표된 DeltaCon입니다. 

## Introduction
두 그래프 $G_1 = (V_1, E_1), G_2 = (V_2, E_2)$ 가 주어졌을 때, 우리는 두 그래프의 `유사도` 를 측정하는 어떤 좋은 메트릭을 갖고 싶습니다. 이 메트릭이 있으면</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cs-adventure" /><category term="graph theory" /><summary type="html">Contents</summary></entry><entry><title type="html">7월 1-2주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21Jul1/" rel="alternate" type="text/html" title="7월 1-2주차 Weekly PS" /><published>2021-07-08T00:00:00+09:00</published><updated>2021-07-08T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21Jul1</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21Jul1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

July 01 - July 11, 2021

## Recent Updates 
- 2021 UCPC에 (팀명은 미정) 참여할 예정입니다. 현재 계획된 팀원은 `dlwocks31` 과 `gyuni` 로, dlwocks31은 지난 2년간 PS를 같이 돌아왔었고 `gyuni`님과는 2019 UCPC쯤에 팀연습 스파링(?) 으로 만나본적이 있습니다.
- 2021 SCPC도 일단은 출전합니다. 

## Rounds 
### Atcoder Beginner Round 208
- [라운드 링크](https://atcoder.jp/contests/abc208/tasks)
- 420등, +4 (1840 -&gt; 1844).
- D번까지 무난하게 풀었는데 E번 구현에서 너무 심하게 말렸습니다. 딱히 재밌지는 않고... F번은 좀 재밌는 수학문제같던데 E에 말려서 읽어보지도 못했네요.

### (Virtual) Codeforces Round 490 (Div.3)
- E번이 좀 재밌는 문제였습니다. 나머지는 딱히.
- Directed Graph가 주어지고, 정점 $s$가 있어서 여기서 모든 점이 도달가능하기 위해 최소 개수의 간선을 추가하는 문항입니다. $n, m$은 5천으로 $O(nm)$ 풀이가 무난한 정도 크기.
- 모든 점에서 BFS를 돌아서 도달가능한 점들을 미리 계산하여, 각 점에서 도달가능한 집합 $R_i$를 들고있기로 합시다. 이제, $s$에서 도달 불가능한 점들을 $T$라고 하고, 어차피 도달가능한 점들은 의미가 없으므로 $R_i$ 대신 $R_i \cap T$를 생각함으로써 모든 $R_i \subset T$가 되게 합니다. 그러면 $R_i$들 중 최소 개수의 집합으로 $T$를 덮는 문제가 됩니다. 
- 이는 set cover라는 매우 유명한 NP-complete 문제이므로 당연히 그대로는 풀 수 없습니다. 그러나, $R_i$들에 대해 순서가 존재함을 기억합시다. 
- $a$에서 $b$로 갈 수 있다면, $R_a$는 $R_b$를 포함합니다.
- 따라서, 서로 도달가능한 점들을 묶고 나면, 남은 $R$들은 set inclusion에 의해 어떤 partial order를 이룹니다.
- 어차피 점 한개를 먹는다면, partial order의 체인을 생각할때 무조건 각 체인의 가장 위에 있는 점들을 먹는것이 이득입니다.
- 이들을 어떻게 구분할 수 있을까요? 가장 간단한 방법은, $R_i$ 들 중 큰 것부터 먹으면 됩니다. 체인의 머리는 그 아래 노드들보다 크므로, 이렇게 하면 머리를 안 먹은 체인에서 아래 노드를 먹을 일은 없습니다. 머리를 이미 먹었는데 그 아래 노드를 먹는 일을 방지하기 위해, 노드를 먹으면서 그 노드에서 도달가능한 ($R_i$에 포함된) 모든 정점들은 지웁니다. 
- 이 방법이 왜 정당한지 증명은 어렵지 않습니다. 
- [구현 링크](https://codeforces.com/contest/999/submission/122143517)
- 별개로, SCC를 잘 활용하면 직접 모든 점에서 BFS를 돌지 않는 Linear time 풀이가 있다고 합니다. 

## Problems
집나간 실력을 되찾기 위한 목적으로 몇개 밀었습니다. 주로 세그먼트 트리 문제를 밀기로 했습니다 :) 

세그먼트 트리 구현은 재귀 트리와 비재귀 트리를 섞어 쓰는 편입니다. 간단히 논의하자면, 양쪽에는 다음과 같은 장단점이 있습니다.
- 재귀트리는 밑바닥부터 제가 짰기 때문에, 동작을 보다 정확하게 이해하고 있어 변형문제를 풀기에 편합니다.
- 재귀트리가 근본적으로 (Fundamentally의 좋은 번역어가 떠오르지 않네요) 좀더 직관적입니다.
- 반면, 비재귀트리는 확실히 더 빠릅니다. 상수가 영향을 주는 문제를 많이 본적은 없지만, $O(n \log n)$ 솔루션이 있는 문제의 경우 가끔 빠른 $O(n \log^2 n)$은 통과하고 똑같은 솔루션에 상수가 크면 짤립니다. 이떄 가끔 유용합니다.
- 비재귀트리는 널리 알려진 구현체인 [Efficient and Easy Segment Trees](https://codeforces.com/blog/entry/18051) 를 가져와서 조금 고쳐 쓰고 있습니다. 많은 사람들이 공유하는 라이브러리를 쓴다는 것은 그 자체로 장점입니다.

제가 쓰는 재귀트리 구현체는 쿼리를 $[l, r]$ 에다 날리고, 비재귀트리 구현체는 가져온 코드라서 $[l, r)$ 에다 날립니다. 혹시 제 코드를 보실일이 있다면 참고해주세요..? ㅋㅋㅋ 

### ICPC Mid Atlantic 2006, BOJ 1849 순열 
- 난이도 : Platinum 4
- $1, 2, \dots n$ 의 permutation을 찾는 문제인데, 각 $i$에 대해, $i$ 앞에 있는 수들 중 $i$보다 큰 수의 개수 $A_i$ 가 주어집니다.
- 기본적인 아이디어는, 각 $i$가 들어갈 위치를 찾아주는 것입니다. 1을 제외한 모든 수가 1보다 크기 때문에, $A_1$이 주어지면 1이 들어가야 할 위치를 그냥 알 수 있습니다. 1을 찾고 나면, 2는 남은 자리들 중 $A_2$번째 자리에 들어가야 한다는 것을 어렵지 않게 알 수 있습니다.
- 결국은 $1, 2, \dots n$ 에 대해, 이 집합에서 수를 하나 뽑아내고, 남아 있는 수들 중 $k$번째를 빠르게 구하는 자료구조가 필요합니다.
- Order statistics tree를 이용하여 $O(n \log n)$에 쉽게 해결할 수 있고, segment tree로도 같은 복잡도로 구현할 수 있습니다. 

### CERC 2010D, BOJ 3429 방어선 
- 난이도 : Platinum 4
- 수열 $A_i$가 하나 주어지고, 수열에서 **최장 길이의 연속하는 증가 부분** 을 찾는 문제입니다. 단, 딱 한 번 원래 수열에서 연속한 부분 하나를 들어낼 수 있습니다.
- 예를 들어, 5, 3, 4, 9, 2, 8, 6, 7, 1 에서 (9, 2, 8) 부분을 떼어내고 가운데 3, 4, 6, 7을 취하는 식입니다.
- `DP1[i]`, `DP2[i]` 를 각각 $i$번째를 오른쪽 / 왼쪽 끝으로 하는 최장 길이의 연속하는 증가 부분이라고 합시다. 이제, 우리가 원하는 값은 모든 $i &lt; j$, $A_i &lt; A_j$에 대해, $D_1(i) + D_2(j)$ 를 계산하여 이를 maximize하는 것입니다.
- 위 표현을 Naive하게 계산하려고 시도하면 '모든 $i &lt; j$, $A_i &lt; A_j$' 에서 이미 $O(n^2)$ 시간이 걸립니다.
- 대신, $A_i$가 큰 것부터 $D_2(i)$의 값들을 세그먼트 트리 같은 자료구조에 업데이트하고, 여기에 $[i, n]$ 구간의 최댓값을 쿼리하는 식으로 생각하면 $O(n \log n)$ 시간에 문제를 해결할 수 있습니다. 코어 로직의 코드는...
```cpp
for (int i = n-1; i &gt;= 0; i--) {
        int u = arr[i].second;
        int q = s.query(u, n);
        s.modify(u, dp2[u]);
        dp[u] = dp1[u] + q;
        ans = max(ans, dp[u]);
    }
    cout &lt;&lt; ans &lt;&lt; '\n';
}
```
- `arr[i].second` 는 $A_i$ 순으로 정렬한 후 다시 인덱스를 가져오기 위함입니다. 대략적인 업데이트 순서는 바로 눈으로 보는 대로입니다. 
- 주의할 점은, $A_i = A_j$ 인 $i, j$가 없음이 보장되어있지 않기 때문에, 쿼리할 때 업데이트 순서를 조심해야 합니다. $A_i$가 같을 때 뭐부터 $D_2(i)$ 를 세그트리에 넣어주는지가 중요한데, $A_i = A_j$이면 $D_2(i)$의 유무가 후속하는 $j$ 쿼리에 영향을 줄 수 없도록, 왼쪽부터 업데이트해야 합니다.

### UCPC 2018 예선F, BOJ 15899 트리와 색깔
- 난이도 : Platinum 2
- 트리의 각 정점이 1부터 $C$ 사이의 색깔을 가지고 있고, $f(v, c)$ 를 $v$를 루트로 하는 서브트리에서 색깔이 $c$이하인 정점의 개수로 정의할 때 이를 빨리 계산하는 문제입니다.
- Euler Tour 라는 테크닉을 이용, 트리를 배열로 펴 주면 서브트리에 대한 쿼리가 우리가 잘 이해하고 있는 구간에 대한 쿼리로 바뀝니다.
- 쿼리를 오프라인 처리해서, 색깔이 작은 쿼리부터 처리하겠습니다.
- 이제, 색깔이 작은 것부터 업데이트하면서 중간중간 타이밍이 될때마다 쿼리를 처리해 주면 됩니다.

### BOJ 14287 회사 문화 3
- 난이도 : Platinum 4
- 위 문제와 똑같이 Euler Tour 를 이용하여 트리를 배열로 펴고
- 칭찬받은 노드에 값을 더한 다음
- 쿼리가 들어오면 그 노드의 서브트리가 받은 칭찬의 값을 합하면 끝입니다.
- 구현이 매우 단순해서, 오일러투어 구현을 확인하기에 적절합니다. 
- 나름대로 깨끗하게 구현하려고 노력한 [링크](https://www.acmicpc.net/source/30906316) 참고.

### BAPC 2005E, BOJ 5419 북서풍
- 난이도 : Platinum 4
- 전형적인 '스위핑 + 세그트리' 입니다. 
- 문제를 단순화하기 위해, 좌표평면에 N개의 점이 있고, 남동쪽 대신 북동쪽으로 간다고 생각해 봅시다. 좌표압축을 한다음 Y좌표들을 뒤집어 버리면 이렇게 만드는 것은 어렵지 않게 가능합니다. 
- 이제, 각 점들을 $(x_i, y_i)$ 라고 하고, 1차원 세그먼트 트리 하나를 만듭니다. 각 점을 세그트리의 $x_i$ 번 위치에 추가할 것입니다. 
- 우리가 원하는 것은, $(x_i, y_i)$에 서서 세그트리에 $[x_i, \infty]$ 쿼리를 날렸을때 여기서부터 북동쪽으로 갈수있는 점의 개수를 얻는 것입니다. 그러나 우리의 세그트리는 $y$좌표를 기억하지 않고 그냥 무작정 점의 개수를 세기 때문에, $y$좌표는 우리가 스위핑해야 합니다.
- $y$좌표가 큰 순서대로, 즉 위에서부터 세그트리에 점을 하나씩 넣으면서, 이 점까지 넣은 다음 동쪽을 바라보면 나보다 아래 (y좌표 기준) 점들을 아직 아예 추가가 되지 않았기 때문에 북동쪽 점들만 보이게 됩니다.
- 주의할 점은, 점을 정확히 세기 위해서는 $y$좌표가 같은 점들은 $x$좌표가 큰 쪽부터 처리해야 합니다.

### SCCC 2019E, BOJ 17131 여우가 정보섬에 올라온 이유
- 난이도 : Platinum 4
- 바로 위 문제와 거의 똑같습니다. 
- $y$ 좌표 순서대로 내려오면서 업데이트하고 쿼리합니다. 이문제는 $[0, x_i - 1]$ 과 $[x_i+1, \infty]$ 를 쿼리해서 곱하는 방식입니다.
- 딱 하나 주의할 점은, 위 문제와는 달리 $y$좌표가 같은 점들을 업데이트하는 순서를 어떻게 줘도 꼬이게 됩니다. $y$좌표가 같은 점들을 따로 기억해 놨다가 한번에 업데이트해야 합니다. 코드를 참고해 주세요.

### BOJ 16993, 연속합과 쿼리
- 난이도 : Platinum 2
- 연속합과 쿼리는 소위 '금광세그' 를 이용하여 풀 수 있음이 매우 잘 알려져 있습니다. 
- 세그먼트 트리를 사용하되, 다음과 같은 정보들을 저장합니다. 세그트리의 한 노드가 구간 $[l, r]$ 에 대응한다는 사실을 기억합시다.
  - 자기가 담당하는 구간의 왼쪽 끝에서 시작해서 얻을 수 있는 최대 구간합
  - 자기가 담당하는 구간의 오른쪽 끝에서 시작해서 얻을 수 있는 최대 구간합
  - 자기가 담당하는 구간의 최대 구간합
  - 자기가 담당하는 구간의 합
- 이 네 정보를 ls, rs, ms, s라고 하면, 두 노드를 합칠 때 다음과 같이 생각하면 됩니다.
  - 노드 $a$, $b$를 합쳐서 $e$로 만들 때,
  - `e.s` 는 자명합니다. 
  - `e.ls` 는, `e`의 왼쪽 끝에서 시작해야 하므로 `a.ls` 가 답일 수도 있고, a를 다 먹고 b의 왼쪽 일부를 먹는 경우가 답일 수도 있습니다. 후자는 `a.s + b.ls` 가 최대일 것입니다 (ls의 정의). 따라서, 두 값 중 최대를 취합니다.
  - 같은 원리로, `e.rs`는 `b.rs` 와 `b.s + a.rs` 중 큰 값을 고르면 됩니다.
  - 마지막은 `e.ms` 입니다. 이는 다시 경우를 나누어 생각하면, `a`구간에 포함된 답을 갖거나 (`a.ms`), `b`구간에 포함된 답을 갖거나 (`b.ms`), 두 구간에 걸친 답을 갖거나 (이 답이 `a.rs + b.ls`가 최선임을 관찰합니다) 세가지 경우 (대칭을 제외하면 두가지) 밖에 없습니다.
- 따라서, 상수배의 시간을 지불하여 모든 정보를 관리할 수 있고, 연속합 쿼리를 똑같이 날려줄 수 있습니다.
- 두 노드를 합칠때, 단순합에서는 좌우가 상관없지만 이런 특수한 연산을 할 때는 좌우를 조심해야 합니다. 

## Review
세그먼트 트리 문제를 오랜만에 밀면서 자료구조에 대한 이해를 되짚었다는 정도의 의의가 있는것 같습니다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 1학기 종강</title><link href="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/" rel="alternate" type="text/html" title="2021 1학기 종강" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>http://localhost:4000/retrospects-and-plans/finishing-2021-spring</id><content type="html" xml:base="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/">이번학기도 무사히...ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.

## Academic

### Spring Semester Courses

#### Hardware System Design (CSE, 3)

-   Verilog를 이용하여 행렬곱셈 하드웨어 가속기를 만들고, CNN을 빨리돌리는..뭐 그런걸 배우는 과목입니다.
-   저는 베릴로그 코딩을 굉장히 힘들어하기 때문에 팀원이 좀 많이 고생했습니다. 논리설계때 좀 열심히 들을걸 하는 깊은 후회와 미안함을 느끼고 있어서, 창통설은 제가 좀더 나서서 고생할 계획입니다 (아마도...)
-   그와는 별개로 배우는 내용은 매우 흥미로웠는데, 저한테는 좀 힘들었습니다. 제 관심 분야와는 멀다보니 전선이었다면 안 들었을 것 같은데 전필이라 (내 선택에 맡겼다면 있는지도 몰랐을 것들을) 배울 수 있었다는 데 의의가 있다고 생각합니다. 솔직히 NPU, 딥러닝용 FPGA 등이 매우 전망있고 미래에 중요한 기술일 거라는 생각은 듭니다. 다만 제가 개척할 미래는 아니고, 다른 훌륭한 엔지니어들이 수십배 빠른 NPU를 만들어 줄거라고 믿어 의심치 않습니다.
-   프로젝트가 정말 빡세지만 끝나고 보니 그럭저럭 재밌기도 했습니다. 다만 조금 힘들었던 부분들에 대해서는 언젠가 제 시간이 허락하고 팀원이 동의하면 셀프 검열을 좀 거쳐서 얘기해보고 싶습니다. 소개원실 프로젝트는 이렇게 말하고 영원히 검열을 통과하지 못했는데, 하시설은 그정도로 고통스럽지는 않았기 때문에 언젠가는 검열을 통과할수 있을 것 같습니다.

#### Discrete Mathematics (CSE, 1)

-   CS 101인데 지금듣는 놀라운 역수강의 결과입니다. Subgraph Isomorphism에 대한 논문을 읽다가 graph가 뭐고 simple graph가 뭔지 배우는 등... 많은 괴리가 있었습니다.
-   다른 학교의 이산수학과는 달리 저희는 Group이 무엇인지, Lattice가 무엇인지 등 좀 신기한 것들을 많이 배웁니다. Lattice는 처음 듣는 내용이라 당황해서 (정수론의 Lattice가 아닌 집합론의 Lattice입니다) 다른학교 컴공과 친구들 몇명 붙잡고 이게도대체 뭐냐고 물어봤지만 아무도 모르던데, 나름 신기한 뭐가 많았습니다.
-   별개로, 1학년때 들었다면 좋았을것 같습니다. 저야 수학을 복수전공하니까 Proof의 구조나 Function, Relation 등에 대해 공부할 일이 어차피 있었기 때문에 그 효용이 크지 않았겠습니다만 저처럼 수학을 많이는 공부하고 싶지 않더라도 CS 전공자에게 필요한 수학을 단시간에 빠르게 습득할 수 있는 과목이었다는 생각이 듭니다.

#### Numerical Linear Algebra (MATH, 3)

-   수리과학부 수치해석 루트의 과목입니다. MATLAB 또는 Python을 이용한 프로그래밍도 해야 하고, 그냥 과제의 양이 정말 충격적으로 많았는데 그만큼 많이 배웠다고 생각합니다. 중간고사 때까지는 사실 많은 내용을 어디서 주워들은 것들이라고 생각했었는데, 중간고사를 보고 그렇지 않음을 깨달은 뒤 (...) 기말고사는 열심히 공부하고 봤습니다.
-   간단히 요약하자면, 행렬에 대한 알고리즘을 배우는 과목입니다. numpy의 수많은 알고리즘들을 그대로 가져다 쓸수도 있겠지만, 누군가는 그런것들을 만들어야 하니까요. 예를 들어, 1000 \* 1000 행렬의 eigenvalue를 어떻게 구할지, eigenvalue 전부가 아니라 몇개만 필요하다면 어떻게 구할지... $Ax = b$는 정해진 해 $x = A^{-1} b$ 가 있지만, 세상에는 감히 역행렬을 구할 시도조차 할 수 없는 사이즈의 문제들이 있습니다. 그렇기에 iteration method 등 여러 clever 한 알고리즘들을 써야 하는데, 그런 부분들을 배웁니다.
-   컴퓨터공학부 알고리즘 수업은 아무래도 이산적인 구조에 집중하고, 다익스트라 알고리즘, 다이나믹 프로그래밍 등등을 배워야 하기 때문에 수치적 알고리즘은 다루지 않게 됩니다. 저희과는 수치해석에 대해서는 공학수학에서 조금 배우는 정도이기 때문에, 후반부 내용들은 굉장히 새로웠습니다.
-   필기노트를 언젠가 LaTeX로 바꿔서 블로그에 공유하고 싶은 과목으로 현재로서는 두번째에 있습니다 (첫번째는 지난학기에 들었던 최적화 이론입니다) 다만 가장 큰 문제는, LaTeX가 행렬 타이핑이 굉장히 어렵다는 점입니다. 고민해보고 있습니다.

#### Number Theory (MATH, 2)

-   수리과학부 2학년 과목이고, KMO 출신들을 이길수 없기 때문에 학점은 포기하고 들어야 하는 과목입니다. 다만 교수님께서 원래 Cryptography를 연구하시고, Pollard-Rho 알고리즘의 발전에 지대한 공헌을 하신 등 Computational Number Theory에 가까운 분이시기 때문에 저한테는 정말 재밌는 수업이었습니다. 수업중 Algorithmic한 부분들 - 예를들어 Lenstra의 소인수분해 등 - 에 대한 언급이 많았고, 격자이론이나 동형암호에 대한 특강 등 컴퓨터공학 전공인 저한테는 정말 배울게 많았습니다.
-   PS하면서 배운 정수론을 좀더 정확히 이해할 수 있었습니다. 초반에 빠르게 일반적인 정수론의 주제들 (중국인의 나머지 정리, 페르마 소정리, 오일러 피 함수, 르장드르 기호, 이차 잉여, 디리클레 합성곱 등) 을 달린 후, 후반에는 타원곡선, 무리수의 유리근사, 소수정리 등의 재밌는 주제들을 폭넓게 다루었는데 솔직히 80%도 채 소화하지 못한 것 같아 아쉽습니다. 언젠가 제가 ~정신을 잃고~ 대수적 정수론 같은걸 펴볼 날이 올까요?

#### Real Analysis (MATH, Grad 1) / Undergrad Real Analysis (MATH, 4)

-   이번학기를 지배한 실해석/실변수 세트입니다. 실해석학은 워낙 유명한 과목으로 대학원 1년차 과목임에도 학부생 수강생이 훨씬더 많고 타과생도 많습니다만 제기억에 컴공과는 저밖에 없었습니다. 주로 해석학을 배워야 하는 통계학과, 경제학과가 많았습니다.
-   GRA / URA로 구분하자면, GRA는 루딘의 Real and Complex Analysis의 앞부분 반정도를 커버하고, URA는 Folland의 Real Analysis를 기준으로 그중 일부를 나갑니다. 두 과목의 가장 큰 차이는 '세팅' 이었다고 생각하는데, GRA는 Locally Compact Hausdorff space X를 기본 세팅으로 두는데 비해 URA의 기본 세팅은 $\\R$ 또는 $\\R^2$ 입니다. 예를들어 Fourier Series를 이해하기 위해 URA에서는 직접 적분을 계산하고 Dirichlet Kernel, Fejer Kernel 등등을 이용하여 내용을 진행하는데 비해, GRA에서는 Hilbert space (완비내적공간)에 대한 일반적인 성질들을 공부하고 그걸 $L^2(\[-\\pi, \\pi\])$ 에 적용하는 식입니다.
-   그렇다보니 Measure theory, Lebesgue 적분 등을 두가지 관점에서 동시에 보면서 (뚝배기가 박살나긴 했지만) 재밌게 공부할 수 있었습니다. 종합해서 해석학에 대한 이해를 높일 수 있었다고 생각합니다.
-   다만 저처럼 수학을 찍먹할 사람이면 모를까, 수학 전 분야에 대한 이해를 좀 가져야 할 수리과학 전공생들에게 권할만한 테크인지는 잘 모르겠습니다. Redundancy가 있는건 사실이니까요. 저는 복수전공자니까 전필만 듣고나면 제가 듣고싶은거 적당히 골라듣고 챙기면서 움직여도 뭐 되지 않을까요.
-   Measure theory를 공부하게 된 계기는, 3학년 2학기 때 수강했던 최적화 이론입니다. 최적화 이론에서 Martingale 등 놀라운 이론들을 통해 수렴성을 얻는게 좀 있었는데, 도대체 수렴하면 수렴하는거지 Almost surely converge한다는건 무슨소리인가??? 에 대해 답할 수 있게 되었습니다. 최적화이론 수업 이후 조언을 구하였을 때, measure theory와 stochastic differential equation에 대한 공부가 최적화 분야의 엄밀한 이해에 도움이 될 것이라는 조언을 얻을 수 있었습니다.

### Extracurricular

-   지난 2학기 ~ 이번 4월까지 컴퓨터공학부 컴퓨터이론 및 응용 연구실에서 수행했던 UROP 결과로 작성에 참여한 논문을 한국정보과학회에서 주관하는 한국 컴퓨터 종합 학술대회 (Korea Computer Congress) 에 제출하여 발표 (발표는 제가 하는건 아니지만) 하게 되었습니다. 솔직히 짧은 경험과 부족한 지식, 코로나 시국이라 대부분이 비대면으로 진행된 현실 상 제가 뭔가 딥하게 할수 있었던건 별로 없고, 어떤식으로 이런 프로세스들이 돌아가는지 배웠다는 것, 논문 읽고 코드 좀 고쳐서 테스트해보면서 그래도 학교 공부와는 또 다른 느낌의 뭔가를 생각해봤다는데 의의가 있는게 아닌가 생각하기로 헀습니다.
-   연구실에서 감사하게도 KCC 참가비용을 지원해주셔서, 23-25일에는 발표도 듣고 그러게 되었습니다. 재밌는게 있으면 정리해서 뭘 배웠는지 또 포스팅 해보려고 합니다.
-   \[UPD\] KCC 2021에 결과물인 &quot;부분 그래프 매칭 문제를 위한 향상된 동적 매칭 순서&quot; 를 제출하여 Oral 발표 세션에서 발표될 예정입니다. (발표는 뭐 제가 하는건 아니고, 주저자이신 박사과정 연구원님께서 하십니다) 부족한 제게 정말 과분하게 좋은 경험이었고 감사하게 생각하고 있습니다.

### Miscellaneous

-   코로나 시국이라 Personal하게 크게 바뀔만한건 없는듯합니다.
-   가까운 친구/지인 몇명이 병특 등을 포기하고 군대를 갔습니다. 산업기능요원 TO 감소를 비롯하여 여러 이슈들이 겹쳐진것 같은데, 개인적으로 석전연/박전연 중 한쪽을 제 루트로 생각하고 있어서 현재는 입대는 계획에 없습니다. 그래도 유학 등 때문에 고민은 많네요...

## 2021 Summer

-   졸업을 해야 하므로 (...) 과학 교양을 채워야 합니다. 실험 듣기 싫어서 미뤘던 죄값을 치를 순간이 왔습니다. 이번 여름에 일반생물학과 일반생물학 실험을 듣게 되었습니다. 고등학교 때 암기가 싫어서 생명과학 2를 고르느니 물리2 화학2 수능을 보고 말겠다고 선언하고 (가오에 지배당해서) 실제로 그렇게 했던 제게는 너무나 끔찍한 형벌이 아닐 수 없습니다.
    -   그러나 늘 그렇듯 새로운걸 배우기 전까지는 알 수 없는 법입니다. 저는 제가 대학와서 수학을 이렇게 많이 공부할지 몰랐으니까요.
    -   라고 셀프 세뇌하고 있습니다.
-   수학과의 지인과 지식공유? 의 차원에서, 제가 자료구조/알고리즘과 C++ 프로그래밍을 좀 가르쳐주고 현대대수2의 내용을 좀 배우기로 했습니다. 다음학기에 현대대수2를 들을 예정인데 현대대수1을 모두 잊어버렸기 때문에 복습과 예습이 조금 필요합니다. 어제 그 지인분이 &quot;그렇게 아예 잊어버리기야 했겠느냐&quot;며,  &quot;Normal subgroup이 뭔지 기억하죠? Ideal이랑&quot; 라고 물었을 때 '어...$g$랑 $g^{-1}$를 앞뒤로 곱했던거 같은데...' 와 '아뇨 기억 안나는데요' 로 대답하는 놀라운 당당함을 보여줬습니다. 모르긴 몰라도 이샛기는 붕어인가?? 하는 생각에 FACEPALM하고 있지 않을까요?
-   그외 계획은 아직 미정입니다. PS도 좀 하고 (이건 이제 반쯤 취미죠)...</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="retrospects-and-plans" /><summary type="html">이번학기도 무사히…ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.</summary></entry><entry><title type="html">Codejam 2021 Round 2</title><link href="http://localhost:4000/algorithms/Codejam-2021-R2/" rel="alternate" type="text/html" title="Codejam 2021 Round 2" /><published>2021-05-19T00:00:00+09:00</published><updated>2021-05-19T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/Codejam-2021-R2</id><content type="html" xml:base="http://localhost:4000/algorithms/Codejam-2021-R2/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

올해 Codejam의 (나한테 있어) 사실상 마지막 round이므로 (R3 는 재밌게 하겠지만 competition으로써는 얻을게 없다) Hashcode 때처럼 prep과 과정을 좀 적어보려고 한다. 앞으로 메이저한 대회는 이렇게 적어볼 생각이다.

## Preperation
그렇게 말하긴 했지만 준비할수 있었던건 딱히 없다. 올해는 CP에 쓰기에는 너무 할일이 많다. 

방학때면 모를까...학기중에 PS/CP에 많은 시간을 투자하기에는 아무래도 어려움이 많다. 그래도 작년 코드잼과 지금 비교했을때 (PS적인 측면에서) 어떤 점들이 나아졌는지 / 나아지지 않았는지 비교해보면 준비를 되새기는 측면에서 조금은 도움이 될것 같기도 하다.

- Courses. Problem solving은 결국 아이디어와 지식이 둘 다 필요한데, 몇몇 내용들 - 작년 1학기에 들은 알고리즘, 지금 듣고있는 정수론 등 - 은 도움이 되는건 사실이다. 대충 다 아는 내용이긴 했지만 혼자서는 절대 하지 않을 revisit을 다시 해보는건 분명히 의미가 있다. General하게, 정수론 같은 파트들은 지식적인 측면보다는 그냥 고민해보는 시간을 갖는게 의미가 있다고 생각한다.

- C++ 구현능력은 오히려 작년만 못하다. 2학기 소개원실이 분기점이 되어서 그런거 같은데, 돌아오려면 아직 멀었다고 생각한다. 2019년 ICPC 때 팀원들이 굉장히 구현을 힘들어해서 아니 멀쩡했던 사람들이 왜이러나 싶었는데, 대충 왜그런지 알거 같기도 하다.

- 그동안 CF rating은 답보를 거듭했는데, 한문제 잡고 푸는 능력은 작년에 비해 나아졌다고 생각한다. `dhdroid` 같은 경우에는 빠른 코딩 실력을 갖추지는 못했지만 어려운 문제를 고민하면 나보다 훨씬 체계적으로 관찰을 쌓아나가는 능력이 있는데, 같이 공부하면서 이런걸 많이 배웠다.

## Preliminary &amp; Round 1
- Preliminary는 30점 절대평가 형식이므로 카페에 앉아서 그냥 대충 앞 몇문제만 내보고 던졌다. 그때 꽤 바쁜 일정들이 있었기 때문에...
- Round 1은 뭔가 항상 R1B를 치게 되는 기분이다. 

## Problem 1 : Minimum Sort
Easy. 바로 떠오르는 Naive 풀이를 그냥 구현하면 된다.

[1, 100] 중 가장 작은걸 뽑고, 맨 앞으로 보낸 다음, [2, 100] 중 가장 작은걸 뽑고.... 이렇게 하면 소모하는 코인 수는 $1/2 + 1/3 + \dots 1/100$ 개 정도이고, 이 값은 6보다 작으므로 이대로 짜서 내면 된다.

## Problem 2 : Matrygons
$K$가 주어질 때, &lt;조건&gt;을 만족하는 distinct한 수열 $x_1, x_2, \dots x_N$ 중 $N$이 최대인 수열을 찾는 문제.

- $\sum_{i = 1}^{N} x_i = K$ 여야 하며
- $x_1$ 이 $x_2$의 약수, $x_2$가 $x_3$의 약수.... $x_N$ 까지 이를 만족해야 한다.

먼저, $K$ 가 $x_1$ 의 배수임을 쉽게 관찰할 수 있다. 또한, $K - x_1$ 은 $x_2$의 배수이고... 이를 반복할 수 있다는 것이 첫번째 관찰이다.

두번째로, $N$이 reasonable하게 작음을 관찰하자. $2x_i \leq x_{i+1}$ 임을 확인할 수 있는데 (배수여야 하고, 같으면 안 되므로) 이를 보면, $N$은 많아야 $\log K$, 30 정도이다.

이 두가지를 이용하면, $f(k, t)$ 를 &quot;현재 $x = t$, $K = k$일 때 $x$ 부터 시작해서 수열을 만들어서 $k$를 만들고자 할 때, 최대의 $N$값&quot; 으로 정의하면 $f(k, t)$ 를 재귀적으로 꽤 빠르게 계산할 수 있다. 설명하기가 굉장히 까다롭지만 코드는 매우 간단하므로 아래 코드를 참고하자.

주의할 점은, 1각형이나 2각형은 없으므로 처음에는 3각형 이상으로 시작해야 함을 주의하자. (이걸로 1틀했다...)

라운드가 끝나고 `dhdroid` 와 discussion했는데 역시 DP황답게 나보다 훨씬 좋은 DP 솔루션을 가져왔다. :fan:

## Problem 3 : Hidden Pancakes
이 문제의 경우, 주어진 문제 상황을 잘 이용하면 &quot;$i$ 번이 $j$번보다 크다/작다&quot; 형태의 정보를 많이 얻을 수 있다. 이러한 정보들이 consistent 하다면, transitivity에 의해 imply되는 정보들을 제외함으로써 Directed tree를 만들 수 있다.

예를 들어, 예제 2는 `1 1 2` 인데, 이를 다음과 같이 볼 수 있다.

- 처음에는 &lt;1&gt; 이 보이는 상황이다.
- 1 다음에 1이 온 시점에서, 보이는게 1개이므로 현재 보이는 것은 &lt;2&gt; 이다. 2번이 1번을 스택에서 쫓아냈으므로, 2번이 1번보다 크다.
- 그다음 2개가 보이므로 &lt;2, 3&gt; 이다. 3번이 2번을 쫓아내지 못했으므로 2번이 3번보다 크다.

이를 트리로 그리면 2번이 루트가 되고, 1번과 3번이 2번의 child node인 트리가 된다. 

같은 방법으로, 예제 1인  `1 2 2 1` 을 보자.

- 처음에는 &lt;1&gt; 이 보이는 상황이다.
- 두번째 시점의 스택은 &lt;1, 2&gt; 이므로 1이 2보다 크다.
- 세번째 시점의 스택은 &lt;1, 3&gt; 인데, 스택에서 3이 2를 쫓아냈으므로 3이 2보다 크다. 또한, 3이 1보다는 작다.
- 마지막 시점에서 &lt;4&gt; 가 모두 쫓아냈으므로 4가 1보다 크다. 

따라서, 4 &gt; 1 &gt; 3 &gt; 2 임을 알 수 있다. 이를 트리로 그리면 한 줄로 쭉 이어진 트리가 된다.

이렇게 트리를 그리고 나면, 이 &quot;트리가 제공하는 partial order&quot;를 깨지 않으면서 $n$개의 팬케익 크기를 정하는 문제가 되는데, 이는 다시 말하면 1, 2, ... $n$을 각 트리 노드에 써넣되 topological order를 깨지 않는 permutation의 개수를 찾는 문제가 된다. 

이는 즉, 현재 주어진 트리의 적법한 topological order의 개수를 세는 문제와 같다. 이 문제는 나름대로 well-known 이므로, 약간 구글링해보면 Tree DP 로 이를 해결하는 방법을 찾을 수 있다. 앳코더에 문제로도 나온 적 있다. [문제 링크](https://atcoder.jp/contests/abc160/tasks/abc160_f)

분명 저 앳코더 문제를 풀때는 생각을 해서 ($O(n \log n)$이긴 했지만 이걸 혼자 찾아냈었는데, 왜인지 모르겠지만 라운드 때는 저런 생각을 전혀 못했다. :( Tree DP는 항상 너무 어려운듯...)

## Round 총평
올해의 첫 메이저 대회인데 나름 재밌었다. 작년이나 재작년 Round 2에 비하면 조금 쉬워진듯한데, 어차피 상대평가니까 큰 의미는 없을 수도...

1000등이라는 커트를 정해놓고 시작하는 라운드다 보니 66점을 받은 시간으로 갈릴수밖에 없는데, 그래도 다행히 막 첫 태스크 빨리푼 시간 이런식으로 갈린 speed중심의 대회는 아니라서 약간 다행이다. 간단한 아이디어 / DP / 트리 DP 라는 첫 3문제의 세팅도 reasonable했다고 보고...

R3도 재밌게 치고 후기정도는 올릴 계획이다 :P</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="competitive-programming" /><summary type="html">Contents</summary></entry><entry><title type="html">5월 2주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21may2/" rel="alternate" type="text/html" title="5월 2주차 Weekly PS" /><published>2021-05-18T00:00:00+09:00</published><updated>2021-05-18T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21may2</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21may2/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

May 10 - May 17, 2021.

## Google Codejam 2021, Round 2
PS를 시작하고 세 번째 Codejam이다. 처음으로 Round 3에 진출하고 Codejam 티셔츠를 얻었다.

순위는 855등으로, 거의 막차를 탔지만 아무튼 티셔츠를 받았다는 사실이 매우 고무적이다 (?) 

나름대로 중요한 대회이므로 별도로 포스팅하기로 한다.

## [Virtual] Google Codejam 2018, Round 2
Codejam을 대비하기 위해 영원한 팽도리들 `dhdroid`, `dlwocks31` 과 함께 2018 Round 2를 virtual로 돌았다. 많은 부족함을 느꼈다. 

### Falling Balls
나름대로 재밌는 Greedy construction 문제이다. 먼저, `/`과 `\`에 대한 조건으로부터, 시작하는 공들이 교차해서 움직이지 못함을 관찰하자. 그러고 나면 결국 왼쪽에서 $k$번째라는 공의 상대적 위치가 잘 보존되므로, 어느 공이 어디로 가야 하는지를 정확하게 안다. 이를 맞추어 construct하기는 어렵지 않다.

### Graceful Chainsaw Jugglers (small)
$O(n^4)$ 의 자명한 DP를 이용하여 small을 긁었고, 어떻게든 이를 줄여보려고 이리저리 많은 고민을 했지만 성공하지 못했다. 

끝나고 `dhdroid` 의 솔루션을 들었는데, DP의 차원을 줄이는 아이디어가 상당히 매력적이다. 뭔가 형태적으로 자주 보이는 DP인 듯 함에도 떠올리지 못한 점은 좀 아쉽다. 풀이에는 $O(n^{8/3})$ 의 놀라운 풀이가 적혀 있으나, $O(n^3)$ 도 문제 해결에 아무런 지장이 없고 훨씬 떠올리기 쉽다.

### Costume Change
중요한 포인트 하나는, 사실 색깔은 충분히 많다는 것이다. 즉, 현재의 '특별하지 않음' 이라는 이슈만 resolve하면 된다.

어떤 $n \times n$ 그리드 상에서, $k$개의 점들이 놓여 있을 때, 이중의 subset을 스도쿠스럽게 뽑는 방법 (각 행에 하나, 각 열에 하나 이하를 유지하는 방법) 은 비교적 well-known이다. 행을 표현하는 정점 $n$개와 열을 표현하는 정점 $n$개를 만들고, $(i, j)$ 에 점이 놓여 있음을 $r_i \to c_j$ 간선으로 표현한 다음, 이들간의 maximum bipartite matching을 찾으면 된다. 이것만 찾는 방법은 좋은 방법이 많이 있지만, 무지성 플로우가 가장 쉽게 구현할수 있다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">5월 1주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21may1/" rel="alternate" type="text/html" title="5월 1주차 Weekly PS" /><published>2021-05-11T00:00:00+09:00</published><updated>2021-05-11T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21may1</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21may1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

Apr 26 - May 09, 2021. 이번 주차는 4월 말 것들도 포함되어 있다.
이전 블로그에서 했었던 weekly PS를 다시 써보려고 한다. 알고리즘 공부도 요새 너무 못한거 같아서...
시험기간 2주씩을 제외하고, 5월에는 아마 1-4주차까지는 있을 예정이다. 

## Google Codejam 2021, Round 1B
1번 Broken clock의 small과 middle, 2번 subtransmutation의 small과 large를 풀고 1101등으로 1B를 통과했다. 올해는 Round 2에는 큰 의미를 두고 있지 않다 (요새 코딩 연습을 너무 못해서..)

놀라운 구현 뇌절이 있을 예정이었기 때문에 미연에 방지하고자 python으로 뛰었고, 그럼에도 불구하고 Broken clock 구현에 1시간 반 정도를 박고 9번을 제출했지만 large를 맞지 못했다는건 좀 충격적이다. 

문제 풀이에 대해 간략히 얘기하자면...

### Broken Clock, Small-Middle
Middle까지는 가능한 시간이 정수 초 만큼이라서 43,200가지밖에 없고, 이 모든 경우를 직접 확인해도 넉넉한 시간이다. 

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Others/%5BGoogle%5D%20Google%20Codejam/2021/Round%201B/A_Broken_Clock.py)

### Subtransmutation, Full
왜 문제 순서가 이런지 잘 모르겠다. 넉넉히 $K$ 한개로 시작해서 만들 수 있는지를 매번 확인해도 시간이 넉넉하고, 이는 $K$부터 1번까지 거꾸로 오면서 Greedy하게 DP를 계산해주면 된다. 말이 조금 이상한데, 꼭 필요한 개수만큼 빼놓고 나머지는 전부 나중에 쓰일수도 있으니 작은걸로 분해해준다고 생각하면 간단하다. 말보다 코드가 훨씬 쉬운 문제.

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Others/%5BGoogle%5D%20Google%20Codejam/2021/Round%201B/B_Subtransmutation.py)

## Problems
### BOJ 20191 줄임말 (KOI 2020)
난이도 : Gold 3 (BOJ)

문자열 S와 T가 주어질 때, T를 몇 번 concat해야 $T^n$ (concat) 이 $S$를 subseqeunce로 포함하는지 묻는 문제. S의 각 글자에 대해서, 이 글자가 T의 몇번째에 대응될 수 있는지 미리 모두 확인한다. Greedy하게, 내 이전 글자들보다 뒤에 있기만 하다면 대응할 수 있는 위치 중 최대한 앞에 대응해야 무조건 이득이 된다. 그러나 더이상 대응 가능한 위치가 없다면, 새로운 T를 하나 추가해서, 가능한 가장 앞에 대응해야 한다. 이를 이용하면 전처리 $O(S + T)$ 를 수행함으로써, $S$의 각 글자에 대해 $\log T$ 시간에 위치를 찾아줄 수 있으므로 $O(S \log T)$ 시간에 해결된다.

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Olympiads/%5BKOI%5D%20Korean%20Olympiad%20of%20Informatics/KOI%202020/%EA%B3%A0%EB%93%B11-%EC%A4%84%EC%9E%84%EB%A7%90.cpp)

### BOJ 3006 터보소트 (COCI 2007)
난이도 : Platinum 4 (BOJ)

세그먼트 트리에 각 element의 위치를 저장하고, segment tree를 이용하여 다이나믹하게 뭔가를 갱신하는 좋은 연습문제지만 기본적인 개념을 파악하고 나면 어렵지 않다. Segtree를 이용하면 구간 $(a, b)$ 의 1의 개수 (남아 있는 원소의 개수) 를 쉽게 셀 수 있다. 

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Olympiads/%5BCOCI%5D%20Croatian%20Open%20Competition%20in%20Informatics/COCI%202007-2008/2_TURBO.cpp)</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">Iterative methods : Jacobi, GS, SOR</title><link href="http://localhost:4000/numerical-analysis/im-1/" rel="alternate" type="text/html" title="Iterative methods : Jacobi, GS, SOR" /><published>2021-04-28T00:00:00+09:00</published><updated>2021-04-28T00:00:00+09:00</updated><id>http://localhost:4000/numerical-analysis/im-1</id><content type="html" xml:base="http://localhost:4000/numerical-analysis/im-1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## Iterative methods
수치선형대수 수업에서 배운 내용을 조금 정리해 보려고 한다. 구체적으로, 행렬 $A$와 벡터 $b$에 대해, $Ax = b$를 푸는 여러 방법들 중 iterative methods를 몇 포스팅에 걸쳐 다루어 본다.

우선, 행렬 $A$ 의 inverse를 구하기가 쉽다면 $x = A^{-1} b$ 를 계산하면 간단하다. 당연히 이상한 방법을 필요로 하는 이유는 이 inverse를 구하기가 어렵기 때문이다. 어렵다는 것은 두 가지 의미가 있는데...
1. Numerically unstable 해서 수치 오차가 우려되는 경우
2. Complexity 관점에서, 계산 시간이 큰 경우
두 경우 모두 &quot;계산이 어렵다&quot; 라는 말로 퉁치기로 하자. 

한번에 정확히 $x = A^{-1} b$를 구하는 대신, 임의의 $x_0$에서 시작해서, $x_i$들의 sequence가 $x$로 수렴하게 하려고 한다. 이때 $x_{i+1}$ 은 $x_i$ 및 그 이전 항들을 이용하여 귀납적으로 연산할 수 있어야 하고, 각 step은 계산이 쉬워야 할 것이다.

어떤 행렬 $Q$에 대해, $A = Q - (Q - A)$ 로 쓰면, $Ax = b$의 해 $x$는 $Qx = (Q - A) x + b$ 를 만족해야 할 것이다. 따라서, $Qx_k = (Q - A)x_{k-1} + b$ 를 우리의 iteration으로 쓸 것이다. 

또한, $A = L + D + U$ 를, $L$을 diagonal 아래의 (strictly) lower triangular한 행렬로, $U$를 그 반대의 upper triangluar 행렬로, $D$를 $A$의 diagonal로 잡기로 한다.

이번 포스팅에서는 가급적 증명들을 생략하고 method들에 대해서만 간략히 살펴보고, 증명은 나중에 여력이 되면 쓸 예정이다.

### Convergence
위 iteration이 올바른 답을 낸다는 사실은 상당히 nontrivial하다. 우선 $x_k = Q^{-1}((Q-A)x_{k-1} + b) = f(x_{k-1})$ 이라고 쓰면, 우리의 목표는 $f$의 fixed point를 찾는 것임을 알 수 있다. 이 iteration은 사실 이러한 $f$에 대해 FPI (Fixed Point Iteration) 을 수행하는 과정으로 이해할 수 있다. FPI가 언제 어떻게 수렴하는지를 이해하는 것은 쉽지 않은데, $f$가 Lipschitz continuous w/ $L &lt; 1$ 임을 보이거나, 훨씬 더 어려운 수학적 내용들을 공부해야 한다. 작년에 최적화 이론 수업에서 이러한 수렴 정리들을 배웠는데, Averaged operator에 대한 수렴정리가 상당히 어렵지만 재밌었던 기억이 있다. 직접 링크를 거는 것이 적절한지 모르겠는데, Ernest K. Ryu 교수님의 최적화 이론 수업 자료가 웹사이트에 공개되어 있으므로 찾아보면 (해석개론 정도의 해석학 지식 배경 위에서) 이해할 수 있을 것 같다. (**Monotone Operators and Base Splitting Schemes** 의 **Theorem 1** 부분을 확인하면 된다)

## Richardson method
Richardson method는 $Q = \frac{1}{w}I$ 를 쓰는 방법이다. 즉, $x_k = (I - wA) x_{k-1} + wb$ 를 생각할 것이다. $I - wA$를 한번 구한 다음부터는 계속 행렬-벡터 곱셈만 반복해도 되므로, 각 step이 $O(n^2)$이고, $I - wA$를 한번 구하는데 $O(n^2)$ 이 들게 되므로 iteration 횟수 $m$에 대해 $O(n^2 m)$ 시간에 연산할 수 있다. 

### Convergence
$x_* - x_i$ 를 직접 계산하면, $(I - wA)x_* + wb - (I - wA)x_{i-1} - wb$ 가 되고, 이를 반복적으로 적용하면 다음 식을 얻는다.
$$x_* - x_k = (I - wA)^k (x_* - x_0)$$
편의상, $x_0$ 을 영벡터로 놓으면, 우리는 다음과 같은 식을 얻는다.
$$\norm{x_* - x_k} = \norm{(I - wA)^k x_*} \leq \norm{I - wA}^k \norm{x_*}$$
이제 $\norm{I - wA}$ 부분을 evaluate 해야 함을 알 수 있고, 선형대수의 지식을 잘 써서 계산해 보면 수렴 속도는 $\lambda_n / \lambda_1$, 즉 가장 큰 eigenvalue와 가장 작은 eigenvalue의 비에 의존함을 파악할 수 있다. 

## Jacobi method
## Gauss-Seidel Method
## SOR (Successive OverRelaxation)</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="numerical-analysis" /><category term="algorithms" /><category term="mathematics" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 1학기 중간점검</title><link href="http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring/" rel="alternate" type="text/html" title="2021 1학기 중간점검" /><published>2021-04-23T00:00:00+09:00</published><updated>2021-04-23T00:00:00+09:00</updated><id>http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring</id><content type="html" xml:base="http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring/">블로그 포스팅 오랜만이네요. 기록상 3월 19일에 폴라드-로 알고리즘에 대해 쓴 게 마지막이니, 대략 한달 만입니다. 과제랑 중간고사에 치여서 나름대로 바쁜 삶을 살고 있습니다.

잠깐 이번학기 중간점검 하는 느낌으로, 쭉 적어보려고 합니다.

## Major Updates
- 수리과학부 복수전공을 (원래도 계획하고 있었지만) 시작하게 되었습니다. 원래는 부전공 중이었는데 조금더 제대로 수학공부를 해보고 싶기도 했고 원래 계획은 복전이었으니까요. 다만 (여기에 적어도 되는지 모를만한 여러 가지로 인해) 복전이 실제로 가능할지는 조금 의문이었는데 잘 해결되었습니다. 별일없으면 초과학기 한 학기와, 인턴십 등으로 쓸 휴학 한 학기를 이용하여 5학년까지 다니고 2023년 2월에 졸업할 예정입니다.
- Computer Theory Lab에서 수행했던 UROP (Undergraduate Research Oppertunity Program) 가 마무리되었습니다. 원래는 작년 8월 - 올해 2월이어야 했지만 어쩌다보니 좋은 기회가 생겨서 4월까지 이어졌습니다. 가능하다면 졸업후 이 연구실로 가고 싶다는 생각을 하고 있습니다. 
- 컴퓨터공학부 보안 분야 학술 동아리 Guardian의 부회장을 맡게 되었습니다. 보안 분야로 진로를 잡았던 것은 아니지만 암호학 등에는 계속 조금씩 관심이 있었는데, 부끄럽지 않을만큼의 공부를 해야겠다는 생각이 듭니다. 솔직히 많이 부족한데 맡을사람이 없다보니...

## Classes
이번학기에는 이렇게 수강하고 있습니다. (학과, 학년)
- 하드웨어 시스템 설계 (컴퓨터공학부, 3) : 서류상 3학년 과목이지만 왜인지 모르겠습니다. 원래는 메모리 구조 등을 배우는 과목이었다고 하는데, 학과 전체가 AI에 잡아먹히는 과정에서 Verilog로 행렬 곱셈을 빠르게 수행하는 가속기를 FPGA에다 올려서 CNN을 빨리 돌리는...뭐 아무튼 그런 주제를 다루는 수업이 되었습니다. Implementation specific한 하드웨어라던가, Neural network에 특화한 칩 설계 같은건 하드웨어 분야 에서 매우 핫한 주제라고 알고 있지만 저는 하드웨어 분야에 소질이 없기 때문에 사실 잘 모르겠습니다. Verilog 프로그래밍은 매우 못 하지만 훌륭한 팀원이 있어 잘 따라가는 중입니다. 
- 실변수함수론 (수리과학부, 4) : 해석학 정통 테크의 과목입니다. 아래 실해석학이랑 같이 듣고 있어서 조금은 편하게 공부하고 있습니다. Measure theory, $L^p$ space, 르벡 적분 등을 배웠습니다.
- 실해석학 (수리과학부, G1) : 실변수함수론보다 한단계 높은 과목으로 배우는 내용이 조금 어렵습니다. 다만 실제로 선수관계라기보다는 같은 과목의 학부 4 / 대학원 1 버전이라, 그냥 저냥 들을 만 합니다. 워낙 유명하고 평이 좋은 과목이라 학부생들도 많이 듣습니다. 실변수함수론 내용을 업글해서 배우는 느낌이라 같이 따라가기 좋고... 엄청 어렵습니다. 해석학 베이스가 없다는걸 많이 느낍니다.
- 정수론 (수리과학부, 2) : 정수론 수업은 진도가 상당히 빠르고 많은 내용을 다루며, 교수님께서 원래 Cryptography를 전공하셨기 때문에 저한테는 매우 흥미로운 주제들이 많았습니다. Computational한 주제들이 많아서 재밌습니다.
- 수치선형대수 (수리과학부, 3) : 선형대수의 여러 계산들을 수치적으로 하는 방법을 배웁니다. 뒤에는 뭔가 새로운 내용을 배우는거 같은데 잘 모르겠고... QR분해, SVD 등 다양한 선형대수의 지식을 Computational하게 접근하는 과목입니다. MATLAB 프로그래밍을 익히는게 조금 어색합니다.
- 이산수학 (컴퓨터공학부, 1) : ㅋㅋㅋㅋ 자구 알골 듣고 이산수학 역수강 ㅋㅋㅋㅋ 테크가 꼬여서 4학년에 이산수학을 듣고 있는데, 컴공과 CS테크를 타고 수학과 과목을 20학점 정도 들은 뒤라 그냥 편안하게 가고 있습니다.
  
## Extracurricular
- Guardian에서 C언어 기초 스터디 자료를 작성하게 되었습니다.
- Codejam 은 Round 1A를 일정상 걸렀는데, 1B에서 올라가면 되니까 별로 부담은 없긴합니다
- PS는 거의 못하고 있는데, 뭐 조금씩은 다시 해보려고 합니다. 가능하면 여기에 포스팅도 조금 자주 하구요... 난이도 있는 문제들 위주로 포스팅할 계획입니다.

## For fun 
- 온라인 체스를 꽤 재밌게 두고 있습니다. Lichess랑 Chess.com 둘다 가끔 하는데 레이팅은 1700 / 1400 정도. 그냥저냥 하는 정도인거 같습니다. 언젠가 여기에 체스 관련 포스팅 할 수도?</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="retrospects-and-plans" /><summary type="html">블로그 포스팅 오랜만이네요. 기록상 3월 19일에 폴라드-로 알고리즘에 대해 쓴 게 마지막이니, 대략 한달 만입니다. 과제랑 중간고사에 치여서 나름대로 바쁜 삶을 살고 있습니다.</summary></entry></feed>