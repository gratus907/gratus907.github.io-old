<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-08-18T22:56:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gratus907’s Study Note</title><subtitle>Hello World!</subtitle><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><entry><title type="html">8월 2주차 Weekly PS</title><link href="http://localhost:4000/ps-weekly/ps-weekly-21Aug2/" rel="alternate" type="text/html" title="8월 2주차 Weekly PS" /><published>2021-08-17T00:00:00+09:00</published><updated>2021-08-17T00:00:00+09:00</updated><id>http://localhost:4000/ps-weekly/ps-weekly-21Aug2</id><content type="html" xml:base="http://localhost:4000/ps-weekly/ps-weekly-21Aug2/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#recent-updates&quot; id=&quot;markdown-toc-recent-updates&quot;&gt;Recent Updates&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rounds&quot; id=&quot;markdown-toc-rounds&quot;&gt;Rounds&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#codeforces-round-738-div-2&quot; id=&quot;markdown-toc-codeforces-round-738-div-2&quot;&gt;Codeforces Round 738 (Div. 2)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#codeforces-round-730-div-2-virtual&quot; id=&quot;markdown-toc-codeforces-round-730-div-2-virtual&quot;&gt;Codeforces Round 730 (Div. 2), Virtual&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problems&quot; id=&quot;markdown-toc-problems&quot;&gt;Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#2016-서울대학교-프로그래밍-경시대회-d번-boj-13202-피자-배치&quot; id=&quot;markdown-toc-2016-서울대학교-프로그래밍-경시대회-d번-boj-13202-피자-배치&quot;&gt;2016 서울대학교 프로그래밍 경시대회 D번, BOJ 13202 피자 배치&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2012-icpc-daejeon-regional-j-boj-9015-정사각형&quot; id=&quot;markdown-toc-2012-icpc-daejeon-regional-j-boj-9015-정사각형&quot;&gt;2012 ICPC Daejeon Regional J, BOJ 9015 정사각형&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2019-숭고한-algorithm-camp-contest-p-boj-17403-가장-높고-넓은-성&quot; id=&quot;markdown-toc-2019-숭고한-algorithm-camp-contest-p-boj-17403-가장-높고-넓은-성&quot;&gt;2019 숭고한 Algorithm Camp Contest P, BOJ 17403 가장 높고 넓은 성&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2009-baltic-olympiad-of-informatics-boj-2415-직사각형&quot; id=&quot;markdown-toc-2009-baltic-olympiad-of-informatics-boj-2415-직사각형&quot;&gt;2009 Baltic Olympiad of Informatics, BOJ 2415 직사각형&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;August 09 - August 15, 2021&lt;/p&gt;

&lt;p&gt;이 글에 구현코드 링크가 없더라도 &lt;a href=&quot;https://github.com/gratus907/Gratus_PS&quot;&gt;PS 레포 링크&lt;/a&gt; 에 가서 대회 단위로 들어가면 보통 올려놓은 코드를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;읽는 사람이 문제를 읽고 조금 생각해봤다고 가정하고, 대략적인 아이디어만 간단히 적을 생각입니다 ㅎㅎ&lt;/p&gt;

&lt;h2 id=&quot;recent-updates&quot;&gt;Recent Updates&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SCPC Round 2에서 탈락했습니다.&lt;/li&gt;
  &lt;li&gt;Codeforces 3번만에 오렌지 복귀에 성공했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rounds&quot;&gt;Rounds&lt;/h2&gt;

&lt;h3 id=&quot;codeforces-round-738-div-2&quot;&gt;Codeforces Round 738 (Div. 2)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Div.2 136등, Rating 2055-&amp;gt;2117&lt;/li&gt;
  &lt;li&gt;Performance 2271&lt;/li&gt;
  &lt;li&gt;E번에서 mod 10억 7인줄 알고 (998,244,353입니다) 문제를 제대로 안읽어서 25분의 디버깅 시간과 1틀을 헌납했습니다. 그게 아니었다면 아마 100등 정도 했을텐데 아쉽네요.&lt;/li&gt;
  &lt;li&gt;그외에는 라운드 자체는 굉장히 재밌었습니다. 라운드 전체에 대한 풀이글은 D2를 업솔빙한 후에 작성할 예정입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;codeforces-round-730-div-2-virtual&quot;&gt;Codeforces Round 730 (Div. 2), Virtual&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Virtual Round&lt;/li&gt;
  &lt;li&gt;그럭저럭 재밌었습니다. C번은 실수오차 이슈가 있었다는데 저는 경험하지 않았습니다.&lt;/li&gt;
  &lt;li&gt;Interactive 문제는 여전히 코딩 이후 확인이 너무 끔찍합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;

&lt;p&gt;기하 연습셋을 만들어서 돌았습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;2016-서울대학교-프로그래밍-경시대회-d번-boj-13202-피자-배치&quot;&gt;2016 서울대학교 프로그래밍 경시대회 D번, BOJ 13202 피자 배치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Gold II&lt;/li&gt;
  &lt;li&gt;기하를 열심히 하면 풀 수 있습니다.&lt;/li&gt;
  &lt;li&gt;가운데 원은 넓이와 둘레의 관계를 통해 구할 수 있고, 나머지는 침착하게 삼각비를 이용하여 모든 값을 계산하면 됩니다.&lt;/li&gt;
  &lt;li&gt;매번, 세 방향으로 원을 그릴 수 있습니다. 세 방향 중 가장 큰 원 쪽에 원을 그리고, 그쪽 방향의 원 크기를 줄이는 식으로 구현하면 됩니다.&lt;/li&gt;
  &lt;li&gt;종이에 삼각비를 열심히 계산하면 문제 자체는 어렵지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;2012-icpc-daejeon-regional-j-boj-9015-정사각형&quot;&gt;2012 ICPC Daejeon Regional J, BOJ 9015 정사각형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum V&lt;/li&gt;
  &lt;li&gt;$n$개의 점에서, 가장 큰 정사각형의 넓이를 구하는 문제.&lt;/li&gt;
  &lt;li&gt;가장 쉬운 방법은 점 $p$ 를 고정하고, 다른 점 $x, y$ 로 변을 그어서 (직각인 경우), $p, x, y$ 와 함께 정사각형을 이루는 $q$가 존재하는지 확인해볼 수 있겠습니다. 이는 각 $p$에 대해 $n^2$ 번의 확인이 필요하므로 $O(n^3)$ 알고리즘입니다.&lt;/li&gt;
  &lt;li&gt;이 방법으로는 해결이 불가능합니다. 좀더 복잡도를 줄이기 위해, 대각선을 고정하겠습니다.&lt;/li&gt;
  &lt;li&gt;대각선을 하나 고정하면, 다른 대각선을 그어서 나머지 두 점의 위치를 특정할 수 있습니다. 나머지 두 점이 $n$개의 점중에 있는지 확인하면 되고, 이는 set같은걸 쓰면 $O(n^2 \log n)$ 에 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;제한 시간이 무려 10초임에도 불구하고 시간이 상당히 빡빡합니다. 저는 set에 point를 넣는 것이 느린건가 싶어서 점의 $x, y$ 좌표를 잘 때려넣어서 long long int 하나로 바꿨더니 간당간당하게 통과했습니다.&lt;/li&gt;
  &lt;li&gt;팁으로, 대각선에 대해 다른 두 점의 위치를 구하는 방법중 하나는 벡터연산을 잘 하면 되는데 그 과정에서 벡터에 1/2배를 해야 합니다. 이런 문제를 해결할 때는 모든 좌표를 2배로 늘려서 구현하면 조금 쉬워집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;2019-숭고한-algorithm-camp-contest-p-boj-17403-가장-높고-넓은-성&quot;&gt;2019 숭고한 Algorithm Camp Contest P, BOJ 17403 가장 높고 넓은 성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum IV&lt;/li&gt;
  &lt;li&gt;Convex Hull 을 구할 수 있는 만큼 계속 구하면 됩니다.&lt;/li&gt;
  &lt;li&gt;좋은 기하 라이브러리를 가지고 있다면 쉽습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;2009-baltic-olympiad-of-informatics-boj-2415-직사각형&quot;&gt;2009 Baltic Olympiad of Informatics, BOJ 2415 직사각형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum I&lt;/li&gt;
  &lt;li&gt;바로 위 위 문제인 9015와 거의 비슷한데, 직사각형 버전입니다.&lt;/li&gt;
  &lt;li&gt;다양한 방법으로 복잡도를 줄일 수 있습니다. 저는 모든 $n^2$ 개의 쌍에 대해 두 점 사이에서 오른쪽 방향으로 가는 벡터를 저장하되 ($x$좌표가 같으면 위 방향)&lt;/li&gt;
  &lt;li&gt;map을 이용하여 &amp;lt;오른쪽으로 가는 벡터 : {시작점들의 리스트}&amp;gt; 를 저장했습니다. 이제, 어떤 오른쪽 방향의 벡터 $p$에 대해, 두 시작점 $x, y$ 가 있다면, $x$ 와 $x+p$, $y$, $y+p$ 가 모두 $n$개의 점들 중에 있었다는 말이므로, 벡터 $r = y - x$ 를 계산하여 $r$과 $p$가 수직한지 관찰하면 됩니다.&lt;/li&gt;
  &lt;li&gt;복잡도는 $n^2 \log n$ 인데, 여전히 key와 value가 point와 point list 인 맵이 너무 느립니다. 9015번처럼, 점을 잘 숫자로 인코딩하면 간당간당하게 통과 가능했습니다. 범위를 잘 보고 이렇게 하면 됩니다.
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ptoi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;itop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ps-weekly" /><summary type="html">Contents</summary></entry><entry><title type="html">중앙대학교 NPC (Newbie Programming Challenge) 풀이/검수후기</title><link href="http://localhost:4000/cp-rounds/ChungAngU-NPC2021/" rel="alternate" type="text/html" title="중앙대학교 NPC (Newbie Programming Challenge) 풀이/검수후기" /><published>2021-08-16T00:00:00+09:00</published><updated>2021-08-16T00:00:00+09:00</updated><id>http://localhost:4000/cp-rounds/ChungAngU-NPC2021</id><content type="html" xml:base="http://localhost:4000/cp-rounds/ChungAngU-NPC2021/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#a-이진-딸기&quot; id=&quot;markdown-toc-a-이진-딸기&quot;&gt;A. 이진 딸기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#b-주간-달력&quot; id=&quot;markdown-toc-b-주간-달력&quot;&gt;B. 주간 달력&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#c-교수님-계산기가-고장났어요&quot; id=&quot;markdown-toc-c-교수님-계산기가-고장났어요&quot;&gt;C. 교수님 계산기가 고장났어요!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-백발백준하는-명사수&quot; id=&quot;markdown-toc-d-백발백준하는-명사수&quot;&gt;D. 백발백준하는 명사수&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#e-쿠키크루&quot; id=&quot;markdown-toc-e-쿠키크루&quot;&gt;E. 쿠키크루&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#f-선형-연립-방정식&quot; id=&quot;markdown-toc-f-선형-연립-방정식&quot;&gt;F. 선형 연립 방정식&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#g-rpg-마스터&quot; id=&quot;markdown-toc-g-rpg-마스터&quot;&gt;G. RPG 마스터&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#후기&quot; id=&quot;markdown-toc-후기&quot;&gt;후기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;작년에 중앙대학교 프로그래밍 대회 (CPC) 의 검수를 맡았었는데, 올해는 같은 대학의 신입생용 대회인 Newbie Programming Contest, 줄여서 NPC의 검수를 맡게 되었습니다.&lt;br /&gt;
작년 CPC의 풀이는 &lt;a href=&quot;https://gratus-blog.tistory.com/128&quot;&gt;링크&lt;/a&gt; 에 작성했는데, 최대 플래티넘 2까지의 상당한 고난도 문제가 출제되는 CPC와는 달리 NPC는 신입생들을 위해 쉽게 출제되는 대회이므로 약간 성격이 다릅니다. 올해 CPC도 검수에 참여할 수 있으면 재밌을것 같은데 불러주실지 모르겠네요&lt;/p&gt;

&lt;h2 id=&quot;a-이진-딸기&quot;&gt;A. 이진 딸기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검수 예상 난이도 : 브론즈 1&lt;/li&gt;
  &lt;li&gt;패턴을 찾으면 되는 문제입니다. 패턴의 길이가 28개임을 (대충 종이에 써보면 어렵지 않게) 관찰합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;b-주간-달력&quot;&gt;B. 주간 달력&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검수 예상 난이도 : 골드 4&lt;/li&gt;
  &lt;li&gt;‘첫 날짜’ 가 며칠인지를 정하면, 나머지는 모두 자연스럽게 계산 가능하다는 것을 파악합니다.&lt;/li&gt;
  &lt;li&gt;그런데, 그냥 브루트포스 계산에 얼마의 시간이 걸릴까요?&lt;/li&gt;
  &lt;li&gt;$[S, E]$ 를 알면 모듈러 연산을 통해 직접 다 돌아서 테이프를 자르는 횟수를 구하면 되므로, $O(M)$ 에 한번 계산해 볼 수 있습니다.&lt;/li&gt;
  &lt;li&gt;가능한 시작일은 1일부터 50000일까지이므로 ($T$라고 하겠습니다. 그 이상은 어차피 일정이 없으므로 무의미합니다)&lt;/li&gt;
  &lt;li&gt;50000 * 1000 시간에 브루트포스로 해결할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;Sweeping, Segment Tree 등 여러 방법으로 복잡도를 더 줄일 수 있습니다. 스위핑으로는 $O(M + T)$, 세그먼트 트리로는 $O(M + T\log T)$ 같은 시간에 풀 수 있을텐데, 이 문제는 $O(TM)$ 을 허용하도록 출제되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;c-교수님-계산기가-고장났어요&quot;&gt;C. 교수님 계산기가 고장났어요!&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검수 예상 난이도 : 실버 3 (C++ 기준)&lt;/li&gt;
  &lt;li&gt;가장 많은 논의가 있었던 문제입니다.&lt;/li&gt;
  &lt;li&gt;그냥 곱셈인데, double의 정밀도를 넘어서는 계산을 어떻게 할 것인가? 를 요구하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;python의 Decimal 라이브러리를 쓰면 다섯 줄로 풀 수 있습니다.&lt;/li&gt;
  &lt;li&gt;C++같은 언어로 풀기 위해서는, 실수의 곱셈을 문자열로 구현하거나, 큰 수를 곱해서 unsigned long long 같은 자료형에 집어넣은다음 다시 나중에 소숫점 위치를 정해서 찍어주면 됩니다.&lt;/li&gt;
  &lt;li&gt;언어에 따라 난이도가 달라지는 문제가 출제되어도 되는가? 라는 논의가 있었는데, 주최측에서는 ‘문제에 적합한 언어를 판단하고 사용하는 것도 대회의 일부’ 라는 견해를 가지고 계셨습니다. 여기부터는 개인의 가치판단의 영역이라고 생각합니다.&lt;/li&gt;
  &lt;li&gt;별개로, 원래는 16자리였는데 float128로 뚫림을 제보했더니 18자리로 늘어났습니다. 이것보다 정밀도를 더 많이 요구하면 C++가 unsigned long long으로 풀 수 없어서 너무 차이가 벌어진다는 이유로 정해진 아슬아슬한 정밀도입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;d-백발백준하는-명사수&quot;&gt;D. 백발백준하는 명사수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검수 예상 난이도 : 브론즈 2&lt;/li&gt;
  &lt;li&gt;고등학교 1학년 수학입니다. $R_1 + R_2$ 와 중심간의 거리 $D$를 비교하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;e-쿠키크루&quot;&gt;E. 쿠키크루&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검수 예상 난이도 : 실버 1&lt;/li&gt;
  &lt;li&gt;구현 문제입니다. 집 1개, 네가지맛 과자가 3개, 도착점 1개가 있으므로 집-&amp;gt;과자1-&amp;gt;과자2-&amp;gt;과자3-&amp;gt;도착점 의 거리를 그냥 다 구하면 됩니다. 여기서, 각 과자 3개에는 순서를 부여해야 하므로 next_permutation같은걸로 6가지 경우를 모두 시도하면 됩니다.&lt;/li&gt;
  &lt;li&gt;추가적인 제약이 있었으면 더 재밌었을것 같은데, 이 상황에서는 두 점의 거리는 $l_0$ 거리를 그냥 쓰면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;f-선형-연립-방정식&quot;&gt;F. 선형 연립 방정식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검수 에상 난이도 : 골드 4&lt;/li&gt;
  &lt;li&gt;Gaussian Elimination.&lt;/li&gt;
  &lt;li&gt;해가 있음이 주어져 있기 때문에, 구현상의 주의점 (0으로 나누는 경우 조심 등) 을 지키지 않아도 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;별개로, 정수만 이용하여 가우스 소거법을 하도록 강제하는 (gcd, lcm을 이용하여) 문제였어도 좋았을 것 같은데 C번과 너무 컨셉이 겹치는것 같기도 하고… 지금은 제약이 작아서 실수연산해도 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;g-rpg-마스터&quot;&gt;G. RPG 마스터&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검수 예상 난이도 : 실버 2&lt;/li&gt;
  &lt;li&gt;예전에 코포 B번쯤에 꽤 많이 나오던 유형인데, 게임을 실제 시뮬레이션하면 시간상 통과하기 힘듭니다.&lt;/li&gt;
  &lt;li&gt;단순한 스텝들 - 그러니까, 어차피 적의 체력이 $S$ 이상이고 내 체력도 충분한 - 을 묶어서 스킵하면 어렵지 않은 구현 문제입니다.&lt;/li&gt;
  &lt;li&gt;경우를 침착하게 나누는 연습이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;브론즈 ~ 쉬운 골드 사이의 문제라서 전형적인 문제들도 많이 있었고, 막 멋진 문제가 있는것은 아니었지만 신입생의 프로그래밍 능력 향상이라는 본 목적에 충실한, educational round가 아닌가 싶습니다.&lt;/li&gt;
  &lt;li&gt;B번 (브루트포스의 복잡도 파악), C번 (실수오차에 대한 이해) 같은 문제들은 처음 PS를 시작하거나 할때 생각해볼만한 주제들을 던져주는 의미가 있을 것 같습니다.&lt;/li&gt;
  &lt;li&gt;A번 (패턴찾기), G번 (역시 일종의 경우 나누기) 또한 요즘 코포에서는 굉장히 트렌드로 밀고 있는 문제기도 합니다.&lt;/li&gt;
  &lt;li&gt;D번은 가장 쉬운 문제니까 하나 있어야 하고, E, F도 전형적인 테크닉 (2차원에서 이런거 구현하기, 가우스 소거법) 을 구현하는 문제지만 NPC의 본 목적에 부합한다고 생각합니다.&lt;/li&gt;
  &lt;li&gt;재밌었습니다 :) CPC때 불러주세요~&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp-rounds" /><summary type="html">Contents</summary></entry><entry><title type="html">MATH TESTBED</title><link href="http://localhost:4000/math-test/" rel="alternate" type="text/html" title="MATH TESTBED" /><published>2021-08-13T00:00:00+09:00</published><updated>2021-08-13T00:00:00+09:00</updated><id>http://localhost:4000/math-test</id><content type="html" xml:base="http://localhost:4000/math-test/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;정리 테스트&lt;/p&gt;

&lt;div class=&quot;definition&quot; data-title=&quot;위상&quot;&gt;
  &lt;p&gt;집합 $S$에 대해 다음 조건을 만족하는 $\mathcal{T} \subset \mathcal{P}(S)$ 를 위상(Topology) 라 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;이렇게 정리를 쓸 수 있다.&lt;/p&gt;
&lt;div class=&quot;definition&quot;&gt;
  &lt;p&gt;집합 $S$에 대해 다음 조건을 만족하는 $\mathcal{T} \subset \mathcal{P}(S)$ 를 위상(Topology) 라 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;정리에 자동으로 번호를 붙일 수 있다.&lt;/p&gt;
&lt;div class=&quot;theorem&quot;&gt;
  &lt;p&gt;함수 $f$가 닫힌 구간 $[a, b]$ 에서 연속이면, 함수 $F(x) = \int_{a}^{x} f(t) \dd{t}$ 는 닫힌 구간 $[a, b]$ 에서 연속이고, 열린 구간 $(a, b)$ 에서 미분가능하며, $F’ = f$ 이다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Definition과 Theorem은 따로 번호를 붙인다.&lt;/p&gt;
&lt;div class=&quot;lemma&quot; data-title=&quot;lemma1&quot;&gt;
  &lt;p&gt;보조정리1&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;보조정리도 쓸 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;증명은 CSS가 깨지므로, 이렇게 쓴다.&lt;/li&gt;
  &lt;li&gt;귀납법을 쓰자. $n = 1$일 때 성립한다.&lt;/li&gt;
  &lt;li&gt;$n = k$ 일 때 성립하면 $n = k+1$ 일 때 성립한다.&lt;/li&gt;
  &lt;li&gt;단어 몇개를 추가했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;lemma&quot; data-title=&quot;Fatou Lemma&quot;&gt;
  &lt;p&gt;가측함수열 $f_n$이 $f_n \geq 0$ 을 만족하면, 다음이 성립한다.
\(\int_X \liminf_{n} f_n \dd{\mu} \leq \liminf_{n} \int_X f_n \dd{\mu}\)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;이름 있는 보조정리&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><summary type="html">Contents</summary></entry><entry><title type="html">논문읽기 : Chan-Vese Algorithm</title><link href="http://localhost:4000/cs-adventure/chan-vese/" rel="alternate" type="text/html" title="논문읽기 : Chan-Vese Algorithm" /><published>2021-08-13T00:00:00+09:00</published><updated>2021-08-13T00:00:00+09:00</updated><id>http://localhost:4000/cs-adventure/chan-vese</id><content type="html" xml:base="http://localhost:4000/cs-adventure/chan-vese/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#key-ideas&quot; id=&quot;markdown-toc-key-ideas&quot;&gt;Key Ideas&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#energy-functional&quot; id=&quot;markdown-toc-energy-functional&quot;&gt;Energy functional&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#integral-formulation&quot; id=&quot;markdown-toc-integral-formulation&quot;&gt;Integral formulation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#regularization--euler-lagrange&quot; id=&quot;markdown-toc-regularization--euler-lagrange&quot;&gt;Regularization &amp;amp; Euler-Lagrange&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#partial-differential-equation&quot; id=&quot;markdown-toc-partial-differential-equation&quot;&gt;Partial Differential Equation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#reinitialization&quot; id=&quot;markdown-toc-reinitialization&quot;&gt;Reinitialization&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conclusion&quot; id=&quot;markdown-toc-conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thoughts&quot; id=&quot;markdown-toc-thoughts&quot;&gt;Thoughts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;CS 논문읽기라고 생각하고 연 cs-adventure 카테고리인데 의외로 두번째가 수치해석? 을 쓰는 최적화 관련이 되었네요.&lt;/p&gt;
&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;이번에 읽은 논문은 &lt;strong&gt;Active Contours Without Edges&lt;/strong&gt; 라는, 2001년의 논문입니다. 2001년 IEEE Transactions on Image Processing, Vol.10, No.2 에 발표된 논문으로, 이 분야 - image processing - 에서는 엄청나게 중요한 논문으로, 현재까지 1만 3천 회 가량 인용되었습니다.&lt;/p&gt;

&lt;p&gt;목표는 어떤 이미지가 주어졌을 때, 이 이미지의 외곽선 &lt;strong&gt;“Contour”&lt;/strong&gt; 를 따는 것입니다. 특히, 여기서는 segmentation이라고 해서 그림의 픽셀을 몇개의 클래스로 구분하는 문제를 해결하는 것으로 보고 있습니다. 예를 들어, 배경 앞에 사람이 서 있다면, 사람과 배경을 구분하는 문제를 classification이라고 할 수 있겠습니다. 꽤 오래 전 (저널 발표일 기준 2001) 논문이므로, 본격적인 Deep Learning의 시대가 오기 전의 방법론을 볼 수 있었습니다.&lt;/p&gt;

&lt;p&gt;먼저, 용어를 간단히 정의합니다. Segmentation과 Contour detection은 원래 약간 다른 문제지만, 여기서는 Segmentation의 방법으로 Level set (등고선) 의 Contour를 따는 방법을 생각하기로 합니다. 이를 위해, 예를 들어 어떤 grayscale 이미지가 주어지면, 이 선을 대충 색이 진한 쪽과 흐린 쪽으로 나누기 위해 진한 점들이 이루는 Contour를 찾고자 한다고 이해하면 되겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;key-ideas&quot;&gt;Key Ideas&lt;/h1&gt;
&lt;h2 id=&quot;energy-functional&quot;&gt;Energy functional&lt;/h2&gt;
&lt;p&gt;이 문제에서는, Segmentation 문제를 Functional Optimization의 문제로 환원합니다. 여기서 Functional이란, 정의역이 함수의 집합인 함수를 말합니다.&lt;/p&gt;

&lt;p&gt;특히, 우리는 결과물의 외곽선이 Smooth하기를 원하므로, $X$에서 Lipschitz Continuous 한 함수의 집합 $\mathcal{L}$ 에서 $\R$로 가는 함수열을 생각할 것입니다. 여기서 Lipschitz 연속이란 연속성보다 더 강한 개념으로, 점 $x, y$ 와 어떤 상수 $K$에 대해 $\norm{f(x) - f(y)} \leq K \norm{x - y}$ 를 만족하는 함수들을 의미합니다.&lt;/p&gt;

&lt;p&gt;함수의 Level set에 대해 논의하기 위해, 우리는 함수 $\phi \in \mathcal{L}$ 에 대해, $\phi = 0$ 인 점들을 이은 곡선을 $C$라고 정의합니다. 또한, $\phi(x) &amp;gt; 0$ 인 공간을 $A$, $\phi(x) &amp;lt; 0$ 인 공간을 $B$라고 쓰겠습니다. 마지막으로, 원래의 이미지 픽셀값을 $u_0(x, y)$ 함수로 나타냅니다.&lt;/p&gt;

&lt;p&gt;이제, 다음과 같은 Functional들을 정의합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$Len(C)$ : 곡선의 길이. 곡선의 길이가 길면 $\phi$ 가 덜 smooth하기 때문에 (해석학적인 term이라기보다는, 기하적인 smooth함), 매끄러운 곡선을 그리도록 페널티를 통해 incentivise 합니다.&lt;/li&gt;
  &lt;li&gt;$Area(A)$ : $\phi(x) &amp;gt; 0$ 인 부분의 넓이. 길이와 기본적인 의미는 같습니다.&lt;/li&gt;
  &lt;li&gt;$\int_{A} \abs{u_0(x, y) - c_1}^2 \dd{x}\dd{y}$ : 어떤 실수값 $c_1$ 을 잡아서, $\phi$ 안쪽에서 $u_0$ 의 평균을 나타내고 싶습니다. 이때 이 평균값이 가급적 정확하기를 바란다는 의미입니다. 일종의, 영역 안에서의 intensity의 분산으로 생각하면 됩니다. 가급적 영역을 잘 잡아서 밝기의 분산이 작게 자른다는 의미가 되겠습니다.&lt;/li&gt;
  &lt;li&gt;$\int_{B} \abs{u_0(x, y) - c_2}^2 \dd{x}\dd{y}$ : $\phi$ 바깥쪽에서도 똑같은 작업을 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;직관적으로, 저 네 값 모두 작았으면 좋겠다는것을 알 수 있습니다. 앞 두개가 작으려면 함수가 대충 곡선으로 쭉 매끄럽게 이어져야 하고, 뒤 두개가 작으려면 그 안쪽과 바깥쪽에 어떤 intensity 값을 잡아서 그 값에 가깝게 잘려야 합니다.&lt;br /&gt;
우리는 저 네 Functional의 선형결합을 “Energy Functional” 이라고 부르기로 하고, 저 값을 minimize하는 $c_1, c_2, \phi$ 를 찾는 것을 목표로 합니다.&lt;/p&gt;

&lt;h2 id=&quot;integral-formulation&quot;&gt;Integral formulation&lt;/h2&gt;
&lt;p&gt;그러나, 저 식은 저대로는 상당히 계산하기가 어렵습니다. 좀더 계산을 잘 하기 위해, 식을 살짝 조절해 봅시다. 이를 위해, 헤비사이드 함수 $H$를 도입합니다. $H$는 $x \geq 0$ 일 때 1, $x &amp;lt; 0$ 일 때 0인 함수입니다. 이를 도입하면 $H(\phi(x, y)) = 1$ iff $\phi(x, y) \geq 0$ 가 성립합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Length : 길이는 스토크스 정리와 헤비사이드 함수의 정의를 이용하면, 아래와 같이 쓸 수 있습니다. 
  \(L(\phi) = Len(C) = \int_{\R^2} \abs{\nabla H(\phi(x, y))} \dd{x}\dd{y}\) 
  당연히 일반적으로 $H(\phi(x, y))$ 는 미분이 불가능하지만, 우리는 Heaviside의 도함수를 Dirac-delta로 쓰고 있으므로 (in distribution function sense) 적분은 잘 됩니다. &lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br /&gt;
  나머지 식들과 적분하는 변수 등을 맞춰주기 위해, 이 식을 조금 바꾸어 아래와 같이 씁니다. 
  \(L(\phi) = Len(C) = \int_{\R^2} \delta(\phi(x, y))\abs{\nabla \phi(x, y)} \dd{x}\dd{y}\)&lt;/li&gt;
  &lt;li&gt;Area : 간단한 다변수 적분입니다. 
  \(S(\phi) = Area(A) = \int_{\R^2} H(\phi(x, y)) \dd{x}\dd{y}\)&lt;/li&gt;
  &lt;li&gt;역시 간단한 두 개의 다변수 적분식을 쓸 수 있습니다. 
  \(F_i(\phi) = \int_{\R^2} \abs{u_0(x, y) - c_1}^2 H(\phi(x, y))\dd{x}\dd{y}\) 
  \(F_o(\phi) = \int_{\R^2} \abs{u_0(x, y) - c_2}^2 (1 - H(\phi(x, y)))\dd{x}\dd{y}\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;하나 관찰할 수 있는 것은, $c_1$과 $c_2$는 $\phi$를 고정하고 최적화할 수 있다는 점입니다. 구체적으로, 첫번째 식을 다시
\(\int_{A} \abs{u_0(x, y) - c_1}^2 \dd{x}\dd{y}\) 이렇게 돌려놓고 보면, $c_1$은 자명하게 $u_0$의 $A$에서의 ‘평균’ 이 되어야 합니다. (적분을 통해 함수의 평균을 구하는 방법은 standard 하므로 생략) 따라서, 앞으로 $c_1, c_2$는 $\phi$로부터 간단한 적분을 통해 계산 가능하므로, 위 식을 $\phi$로만 최소화한다고 문제를 단순화하겠습니다.&lt;br /&gt;
또한, 실제 알고리즘은 1, 2, 3에 각각 적당한 상수를 붙여서 계산합니다. 특히, (3) 의 $F_i$ 와 $F_o$에 다른 상수를 붙여서 계산하는데, 실제로는 원본 논문의 저자들도 상수를 대충 잡았고, 이 상수를 어떻게 잡아야 하는지에 대해서는 별로 논증이 없었으므로 저는 여기서 (1) * $\mu$ + (2) * $\nu$ + (3) * $\lambda$ 로 놓고 계산하겠습니다. 외곽선이 매끄러운 것이 중요하면 $\mu, \nu$ 를 높게 잡고, 색의 정확도가 중요하면 $\lambda$를 높게 잡으면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;regularization--euler-lagrange&quot;&gt;Regularization &amp;amp; Euler-Lagrange&lt;/h2&gt;
&lt;p&gt;이후의 연산에서 가장 큰 문제 중 하나는, $H$ 와 $\delta$는 미분이 불가능한 함수라는 문제가 있습니다. 이 문제를 해결하기 위해, 우리는 Regularization이라는 방법을 적용합니다.&lt;/p&gt;

&lt;p&gt;Regularization은 전혀 어렵지 않은데, $H$ 대신 $\epsilon$ 이라는 factor에 dependent한, 그리고 $H_\epsilon \to H$ as $\epsilon \to 0$ 함수 $H_\epsilon$ 으로 대체하고, 그 도함수를 $\delta_\epsilon$ 으로 쓰면 됩니다. 본 논문에서는 다음의 $H_\epsilon$ 을 제시하고 있습니다. 
\(H_\epsilon(z) = \frac{1}{2} \left(1 + \frac{2}{\pi} \arctan\left(\frac{z}{\epsilon}\right)\right)\)
이 식과 그 도함수 $\delta_\epsilon$ 을 이용, 모든 $H$ 와 $\delta$를 대체하면 됩니다.&lt;br /&gt;
이제, 여기까지 오면서 우리가 최종적으로 무엇을 최소화하는지 보겠습니다. 여기서부터는 $F_i, F_o$ 등도 모두 위 식에 따라 relaxation 된 것으로 읽어야 합니다.
\(\int_{\R^2} \mu L(\phi) + \nu S(\phi) + \lambda(F_i(\phi) + F_o(\phi)) \dd{x}\dd{y}\)
이 식을 최소화하는 함수 $\phi$를 찾는 대표적인 방법은 &lt;strong&gt;변분법&lt;/strong&gt; 입니다. 변분법으로 &lt;del&gt;끔찍한 계산을 통해&lt;/del&gt; 오일러-라그랑주 방정식을 유도하면 &lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, 아래와 같은 편미분 방정식을 얻습니다. 
\(\delta_\epsilon \left(\mu\nabla\cdot\left(\frac{\nabla \phi}{\abs{\nabla \phi}}\right) - \nu - \lambda(u_0 - c_1)^2 + \lambda(u_0 - c_2)^2\right) = 0 \tag{PDE}\)&lt;/p&gt;

&lt;h2 id=&quot;partial-differential-equation&quot;&gt;Partial Differential Equation&lt;/h2&gt;
&lt;p&gt;우리는 이런 편미분방정식은 풀 방법이 없기 때문에, 마지막으로 수치해석을 적용합니다. 구체적으로, Finite Differnce method를 이용해야 합니다.&lt;/p&gt;

&lt;p&gt;편미분방정식을 iterative 하게 풀기 위해, evolving 하는 해 $\phi$ 를 생각합니다. 이런 방법을 쓰는 이유는 $c_1$ 과 $c_2$를 $\phi$로부터 계산해야 해서 위 식을 계산할 수 없으므로, 다음과 같은 알고리즘을 돌리겠다는 의미입니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$\phi_0$ 을 정합니다.&lt;/li&gt;
  &lt;li&gt;$c_1, c_2$ 를 $\phi_n$ 으로부터 계산합니다.&lt;/li&gt;
  &lt;li&gt;“PDE” 를 한번 풀어서 $\phi_{n+1}$ 을 계산합니다.&lt;/li&gt;
  &lt;li&gt;$\phi_{n+1}$ 이 $\phi_n$ 과 많이 다르다면, (2) 로 돌아가서 반복합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finite Difference method는 별로 어렵지 않은데, $\Delta_{-}^{x}$ 같은 식으로 $x, y$ 방향 $+, -$ 로 네개의 time differnece를 정의하고 여러 공식들을 적용하기만 하면 됩니다. 편미방이 복잡하게 생겼지만 각 term은 그렇게 어렵지 않습니다.&lt;/p&gt;

&lt;p&gt;먼저, $\nu - \lambda(u_0 - c_1)^2 + \lambda(u_0 - c_2)^2$ 부분은 자명합니다. ($c_1, c_2$ 도 $\phi_n$ 으로부터 구했으므로) Divergence 부분이 문제인데, 그 부분은 이미 과거의 선행 연구 논문 &lt;a href=&quot;https://www-pequan.lip6.fr/~bereziat/cours/master/vision/papers/rudin92.pdf&quot;&gt;(링크)&lt;/a&gt; 에 의해 어떻게 해야 하는지 잘 알려져 있다고 합니다. 구체적으로, 충분히 작은 $\Delta t$를 잡아서 이렇게 쓰면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/88f15ccdc6324ec2463d30fe19c7ecb811221c9218659d19d8e6fa891f690d1d.png&quot; alt=&quot;formula&quot; width=&quot;60%&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 수치해석 문제도 해결되었고, 위 식을 그냥 열심히 계산하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;reinitialization&quot;&gt;Reinitialization&lt;/h2&gt;
&lt;p&gt;Level Set을 구하고자 Dirac delta 같은 함수들을 사용할 때, re-initialization이라는 과정을 거치지 않으면 level set이 지나치게 flat해지는 경향성이 있다고 합니다. 그 이유는 우리가 정상적인 $\delta$ 가 아닌 $\delta_\epsilon$ 같은 비슷한 함수들로 넘어가서 생긴 문제인데, 이를 해결하기 위해 $\phi$를 매번 수정해줄 수 있습니다. 논문에서 저자들은 ‘반드시 필요하지 않다’ 고 쓰고 있고, 실제로도 이 알고리즘에서는 Reinitialize를 하지 않아도 결과가 어떨때는 잘 나오는 것 같습니다만, 추가하고 싶다면 다음의 Evolution equation을 풀면 됩니다.
\(\pdv{\psi}{t} = sign(\phi(x, y, t))(1 - \abs{\nabla \psi})\)
여기서 $\phi(x, y, t)$ 는, 앞서 $\phi_n$ 을 실제로는 $t = n\Delta t$에서의 $\phi(x, y, t)$ 값으로 보고 있기 때문에 필요한 지점에서는 계산할 수 있습니다. 우리는 어차피 이 식도 수치해석으로 풀 것이므로 $\phi(x, y, t)$ 의 값은 해석적으로 구할 필요 없습니다.&lt;/p&gt;

&lt;p&gt;이 테크닉에 관해서는 다른 논문을 통해 더 알게 되면 보충해 볼 생각입니다. 아직은 실제 예시가 없어서인지 왜 이게 필요한지, 어떤 의미인지 잘 와닿지 않네요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;이 알고리즘은 Noisy image에서도 생각보다 훌륭한 성능을 보여주고, vector-valued (= 컬러 이미지) 같은 확장도 그렇게 어렵지 않습니다. 특히, 이런 식의 Energy Functional을 잘 정의하기에 따라서 범용성이 굉장히 높고 원하는 Feature가 있다면 추가로 embed 할 수도 있어서 확장성도 높습니다. 특히, 원본 논문에서는 curvature 같은 정보들을 추가로 이용하는 케이스들도 제시되고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;thoughts&quot;&gt;Thoughts&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;위 알고리즘에서는 Parameter 가 상당히 중요해 보입니다. $\mu, \nu, \lambda$ 의 어떤 조합이 좋은 결과를 내는지에 대해서는 원본 논문에서는 별로 Discuss하지 않았는데, 실험적으로 확인해야 하는 걸까요? $\mu, \nu$ 는 어떻게 실험적으로 검증할 수 있어 보이는데, $\lambda$는 좀 오바인것 같습니다. 검색을 좀 해보니, 다른 논문 몇편에서 이미지의 어떤 computable한 성질들로부터 parameter를 자동으로 튜닝하는 논문들이 있었습니다.&lt;/li&gt;
  &lt;li&gt;Functional Optimization은 일반적인 optimization의 방법론들과는 좀 다르다보니 어렵습니다. 듣기로는 Banach space위에서의 Lagrange Multiplier같은 해괴한게 있다고 합니다. Functional도 결국 Banach space나 Hilbert Space 같은 좋은 공간 위에서 어떤 함수를 최적화하는 거니까, 일반적인 최적화와 비슷한 아이디어들이 있는 걸까요?&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;해석개론을 배우고 나서부터 디랙-델타를 적분에 활용하는게 오히려 정말 이해가 안 갔었는데, 이 개념은 Measure, Distribution function 등 실해석학 및 그 이상의 해석학을 배우면 다시 make sense 합니다. 잠시 공학수학의 관점으로 돌아가서 이 식을 받아들이기로 합니다. 어차피, 이 적분을 실제로 계산할 것은 아니니까요. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;변분법과 오일러-라그랑주에 관한 내용은 미적분학 II에서 정말 초보적으로 배운 이후로 처음이라서, 거의 다 까먹었던 내용을 다시 보고 추가로 이것저것 더 공부해야 했습니다. 저보다 이런걸 훨씬 많이 써먹는 UNIST 기계공학과(+물리학 부전)의 지인에게 급히 오일러-라그랑주 방정식에 대해 배웠습니다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;바로 위에서 언급된 지인이 던져준 고전역학 강의노트(제가 이런걸 보게 될줄은 몰랐네요…) 를 다시 보면서, 식을 처음부터 다 유도해 봤는데 진짜 정신이 아득합니다. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cs-adventure" /><summary type="html">Contents</summary></entry><entry><title type="html">BOJ 15744, USACO 2018 Feb P3 Cow Gymnasts</title><link href="http://localhost:4000/ps-problems/BOJ15744/" rel="alternate" type="text/html" title="BOJ 15744, USACO 2018 Feb P3 Cow Gymnasts" /><published>2021-08-11T00:00:00+09:00</published><updated>2021-08-11T00:00:00+09:00</updated><id>http://localhost:4000/ps-problems/BOJ15744</id><content type="html" xml:base="http://localhost:4000/ps-problems/BOJ15744/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#풀이--관찰&quot; id=&quot;markdown-toc-풀이--관찰&quot;&gt;풀이 : 관찰&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#풀이--시간-복잡도-줄이기&quot; id=&quot;markdown-toc-풀이--시간-복잡도-줄이기&quot;&gt;풀이 : 시간 복잡도 줄이기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#풀이--더-고통받기&quot; id=&quot;markdown-toc-풀이--더-고통받기&quot;&gt;풀이 : 더 고통받기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;출처 : USACO 2018 February Platinum Problem 3 - Cow Gymnasts (BOJ 15744)&lt;br /&gt;
난이도 : solved.ac Diamond 3&lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/problem/15744&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;풀이--관찰&quot;&gt;풀이 : 관찰&lt;/h2&gt;
&lt;p&gt;DHdroid가 ‘재밌는 문제’ 라면서 들고왔습니다. 나름 재밌게 풀었는데 후반에 좀 허탈했습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;먼저, $N$개의 자리를 통틀어 최소값이 $m$ 이라고 하고, 그 최솟값이 있는 자리를 $k$번이라고 합시다.&lt;/li&gt;
  &lt;li&gt;$k - 1, k - 2, \dots k - m + 1$ 번 까지는 어쩔 수 없이 $k$번에 Contribute합니다.&lt;/li&gt;
  &lt;li&gt;$k-m$번은 $k$번에 Contribute해서는 안 되므로, 값이 정확히 $m$이여야 합니다.&lt;/li&gt;
  &lt;li&gt;이와 같은 논증을 귀납적으로 반복하면, 다음 조건을 만족하는 조합이 ‘성공하는 조합’ 임을 알 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;먼저 최솟값 $m$에 대해 주기 $\gcd(m, N)$ 을 갖고,&lt;/li&gt;
      &lt;li&gt;각 주기 내에서의 값은 $m$ 또는 $m+1$ 이어야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서, 다음 식을 계산하는 것으로 끝납니다.
\(1 + \sum_{i = 1}^{N - 1} \left(2^{\gcd(i, N)} - 1\right)\)
이 관찰을 하는 것까지만이었으면 아마도 플래티넘 정도의 문제였을 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;풀이--시간-복잡도-줄이기&quot;&gt;풀이 : 시간 복잡도 줄이기&lt;/h2&gt;
&lt;p&gt;$N = 10^{12}$ 이기 때문에, 이 식을 시간 내에 단순하게는 계산할 수 없습니다.&lt;br /&gt;
앞의 잡다한 부분은 떼고 $\sum_{i = 1}^{N} 2^{\gcd(i, N)}$ 을 빠르게 계산하는 방법에 대해 생각해 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, $\gcd(i, N) = g$ 인 $i \leq N$의 개수를 빠르게 셀 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$i$는 $g$의 배수여야 하므로 $i = gk$ 라고 쓰면, $\gcd(k, N/g)$ 이 1이어야 하며&lt;/li&gt;
  &lt;li&gt;$k &amp;lt; N / g$ 여야 합니다.&lt;/li&gt;
  &lt;li&gt;따라서, 이러한 $k$는 정확히 $\phi(N / g)$ 개 있고, 다음 식을 계산하면 됩니다. 
\(\sum_{g \di N} 2^g \phi(N / g)\)&lt;/li&gt;
  &lt;li&gt;$g \di N$ 을 모두 구하는 것은 $O(\sqrt{N})$ 시간이 걸리며, $g$가 몇 개 있는지는 정확히 쓰기 매우 어렵습니다.
    &lt;ul&gt;
      &lt;li&gt;다만, PS에서 일반적으로 쓰는 바운드는 $O(n^{1/3})$ 입니다. 재밌는 사실은, 이 바운드는 수학적으로 찾은 바운드가 아니라, $10^{9}$ 까지의 수들 중 약수가 가장 많은 수가 1,344개, $10^{18}$ 까지의 수들 중 가장 많은 수가 103,680개의 약수를 갖기 때문에 대충 저만큼 잡으면 된다는 것이 알려져 있다는 점입니다.&lt;/li&gt;
      &lt;li&gt;$O(n^{1/3})$ 개의 약수 각각 $\phi(g)$ 를 구하는 시간은 조금 빡빡합니다. 구체적으로는 개당 $O(n^{1/2})$ 시간인데&lt;/li&gt;
      &lt;li&gt;실제로는 $g$들 중 상당수가 $N$에 비해 많이 작기 때문에, $O(n^{1/3})$개의 약수에 대해 각각 $\phi$함수를 구하는 풀이는 시간 제한을 통과합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;더 최적화하는 방법은, $\phi$ 함수는 그 수의 소인수분해 형태에 의해 정해지며, $N$의 소인수는 많아야 수십 개 선이라는 점입니다.&lt;/li&gt;
  &lt;li&gt;각각의 $g \di N$ 은 $N$의 소인수의 부분집합을 갖기 때문에, $p_1^{e_1} p_2^{e_2} p_3^{e_3}\dots$ 에 대해 각 소인수의 개수를 iterate하면 빠르게 구할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;잘 짜면 $O(n^{1/2} \log n)$ 에 구할 수 있다고 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;풀이--더-고통받기&quot;&gt;풀이 : 더 고통받기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;저는 저 식으로 통과할 자신이 없었기 때문에, 뭔가 새로운 아이디어를 찾아야 한다고 생각했습니다.&lt;/li&gt;
  &lt;li&gt;Identity function $\iota$, Mobius function $\mu$ 에 대해, $\phi = \mu * \iota$ 임이 알려져 있습니다. (디리클레 합성곱)&lt;/li&gt;
  &lt;li&gt;$f(n) = 2^n$ 을 $p$ 함수라고 하면, 우리의 문제는 $p * \phi$ 의 값을 구하는 것이므로, $p * \mu * \iota$ 를 구하는 것이고&lt;/li&gt;
  &lt;li&gt;다시 이를 $\mu * (p * \iota)$ 로 바꾸어 계산할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;처참하게도, $\mu$를 계산하기 위해 포함-배제의 원리를 이용해야 하기 때문에 시간 복잡도는 전혀 줄어들지 않고 $\log$ 항이 하나 더 붙습니다 (뫼비우스 함수의 값을 모두 계산하는게 아니라서, map 같은 자료구조를 이용해야 하기 때문. 심지어 결과적으로 이 풀이는 위 풀이의 $O(n^{5/6}))$ 보다도 훨씬 느렸습니다. 간신히 시간 제한을 통과할 수 있었습니다. :(&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ps-problems" /><category term="number-theory" /><summary type="html">Contents</summary></entry><entry><title type="html">V. Graph Basics, Heaps</title><link href="http://localhost:4000/ds-alg-note/05-graph-basics/" rel="alternate" type="text/html" title="V. Graph Basics, Heaps" /><published>2021-08-09T00:00:00+09:00</published><updated>2021-08-09T00:00:00+09:00</updated><id>http://localhost:4000/ds-alg-note/05-graph-basics</id><content type="html" xml:base="http://localhost:4000/ds-alg-note/05-graph-basics/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#graphs&quot; id=&quot;markdown-toc-graphs&quot;&gt;Graphs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#implementation-of-graphs&quot; id=&quot;markdown-toc-implementation-of-graphs&quot;&gt;Implementation of Graphs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#trees--binary-trees&quot; id=&quot;markdown-toc-trees--binary-trees&quot;&gt;Trees / Binary Trees&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#heaps&quot; id=&quot;markdown-toc-heaps&quot;&gt;Heaps&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#heap-operation&quot; id=&quot;markdown-toc-heap-operation&quot;&gt;Heap Operation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#heap-sort&quot; id=&quot;markdown-toc-heap-sort&quot;&gt;Heap Sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#heap-implementation&quot; id=&quot;markdown-toc-heap-implementation&quot;&gt;Heap Implementation&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#additional-topics-and-problems&quot; id=&quot;markdown-toc-additional-topics-and-problems&quot;&gt;Additional topics and Problems&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#programming-practice&quot; id=&quot;markdown-toc-programming-practice&quot;&gt;Programming Practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;저번 세션에 이어서, 자료구조를 공부하고자 합니다.&lt;/p&gt;

&lt;h2 id=&quot;graphs&quot;&gt;Graphs&lt;/h2&gt;

&lt;p&gt;추상적으로, 그래프는 다음과 같이 정의된 $G = (V, E)$를 의미합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$V$는 정점의 집합으로, 그냥 원소들을 모은 집합으로 생각하면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$E$는 $V \times V$의 어떤 부분집합으로, 원소들 간의 연결성을
표현합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 점 (정점, 노드) 들과 그들 간의 연결선 (간선, 에지) 들의
configuration을 그래프라고 정의한다는 의미입니다. 몇가지 용어를
짚자면...&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Directed/Undirected graph : Directed graph는 간선 $(u, v)$ 와
$(v, u)$ 를 다른 것으로 보고, Undirected graph는 같지 않은 것으로
봅니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Multigraph : $(u, v)_1$ 과 $(u, v)_2$로, 같은 간선이 여러 개 있을 수
있는 - 즉, $E$가 set이 아니라 multiset인 - 그래프를 말합니다.
일반적으로 우리는 고려하지 않을 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simple graph : $E$가 중복을 허용하지 않을 뿐 아니라, $(u, u)$ 도
허용하지 않는 그래프를 말합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Path : 간선들을 따라 돌 수 있는 ‘경로’ 를 말합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Circuit / Cycle : Path의 시작점이 끝점과 같은 경우를 말합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjacent : 정점 $u, v$에 대해, $(u, v) \in E$ 이면 adjacent라고
말합니다. 또한 $u, v$는 서로의 neighbor입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Connected Component : 정점 $u, v$에 대해, $u$에서 시작해서 $v$에
도착하는 path가 존재하면 같은 connected component에 있다고 말합니다.
특히 모든 정점이 하나의 connected component를 이루면 connected
graph라고 말합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unless otherwise specified, $V$는 정점의 집합이면서 간혹 정점의 개수를
$V$개라고 부를 것입니다. $E$도 마찬가지입니다. (Abuse of notation) 또한,
앞으로 그냥 그래프 $G$라고 하면 $n$개의 정점과 $m$개의 간선으로 이루어진
Undirected Connected Simple Graph를 생각하겠습니다. 그래프에 대한 많은
논증은 각 Connected Component를 독립적으로 생각할 수 있으며,
Multigraph도 대충 비슷하게 다루어질 수 있기 때문입니다.&lt;/p&gt;

&lt;h2 id=&quot;implementation-of-graphs&quot;&gt;Implementation of Graphs&lt;/h2&gt;

&lt;p&gt;그래프에 대해서는 후에 다시 자세히 보겠지만, 여기서는 그래프를 어떻게
구현할지만 생각해 보겠습니다.&lt;/p&gt;

&lt;p&gt;흔히 사용하는 그래프 구현은 두 가지가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Adjacent matrix : 2차원 $n \times n$ 배열을 잡고, $A_{ij}$ 를
$(i, j)$ 간선의 존재 여부를 인코딩하는 것입니다. Directed graph를
기준으로 생각하는 것이 조금 더 자연스럽고, Undirected graph일 때는
$A$가 대칭행렬이 될 것입니다.&lt;/p&gt;

    &lt;p&gt;이론적으로 이 방법이 조금더 자연스럽게 그래프를 대할 수 있는데, 특히
Adjacency matrix $A$의 선형대수학적 성질로부터 (Eigenvalue 등)
그래프의 성질을 알 수 있는 것들이 많이 있기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjacent list : Vector나 List같은 다이나믹한 뭔가를 정점마다 하나씩
$n$개 잡고, “이 정점에 인접한 정점” 들의 리스트 (배열) 을 관리하는
관점입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래프의 Density에 대해 생각해 봅시다. 일상에서 만나는 대부분의 (큰)
그래프들은, 굉장히 sparse합니다. 예를 들어, 페이스북 전체의 친구 관계를
그래프로 그린다면, 페이스북 유저 10억 명 중 여러분의 페친은 많아야 천 명
단위일 것이므로 전체 가능한 간선들 중 100만 분의 1 정도밖에 사용되지
않는다는 의미입니다. 대충 간선이 $n^2$개 근처일 때 dense, 그보다 많이
작으면 sparse라고 하겠습니다.&lt;/p&gt;

&lt;p&gt;Adjacent matrix가 이론적으로 보다 아름답게 느껴질 수 있지만, 그래프가
sparse할 때 adjacent matrix는 $O(n^2)$ 메모리를 소모한다는 심각한 단점이
있습니다. 우리는 많은 경우에 sparse한 그래프를 다루고 싶고, 간선을
따라가면서 작업을 하고 싶습니다. 예를 들어...&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int nxt = 0; nxt &amp;lt; n; nxt++)
    if (A[i][nxt])
        traverse(A[i][nxt]);

for (int j = 0; j &amp;lt; A[i].size(); j++)
    traverse(A[i][j]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 둘 다 $i$의 neighbor들을 돌면서 traverse함수를 호출하지만,
전자의 경우에는 if문이 추가될 뿐 아니라 $O(n)$ 개만큼 확인해야 합니다.
만약 페이스북 친구 그래프에 대해 코드를 돌리면, 위쪽 경우에는 내
친구들을 찾기 위해 10억명의 모든 유저를 탐색하는 반면 후자는 그런 필요가
없습니다.&lt;/p&gt;

&lt;p&gt;다만 인접행렬이 구현이 좀더 간단하고, 행렬 곱셈을 통해 연결성을 본다던가
하는 연산들이 가능하기 때문에, 필요한 경우에는 사용할 수 있어야 합니다.
그러나 위 이유들 때문에, 우리는 기본적으로 인접리스트를 그래프의 기본
표현으로 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;trees--binary-trees&quot;&gt;Trees / Binary Trees&lt;/h2&gt;

&lt;p&gt;정점 $n$개 중 어떤 루트가 있고, 루트로부터 모든 정점까지의 경로가
유일하게 존재하는 그래프를 Tree라고 합니다. 이때 루트로부터 경로를
내렸을 때 내 바로 이전 노드를 parent, 그 이전 노드들을 ancestor라고
합니다 (반대는 child, descendant) 트리의 경우, 인접 리스트 표현 외에도
그냥 $n$칸 배열에 각 tree의 parent node를 저장하는 방법으로도 저장할 수
있습니다.&lt;/p&gt;

&lt;p&gt;Binary Tree란, 모든 노드의 Child node가 최대 2개인 트리를 의미합니다.
구현의 편의와, 다양한 활용처 때문에 매우 자주 활용되는 자료 구조입니다.
우리는 앞으로 Binary tree 노드를 다음과 같이 생각할 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct node {
    int val, id;
    node * left;
    node * right;
} root;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;즉, 각 노드가 id와 어떤 값을 하나 가지고 있고, 자신의 left / right
child로 가는 포인터를 가지고 있음을 의미합니다.&lt;/p&gt;

&lt;p&gt;이진 트리의 Special case로 다음과 같은 경우들이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Full Binary Tree : 모든 노드가 0개 또는 2개의 자식 노드를 갖습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Complete Binary Tree : 가장 아래 층을 제외한 모든 층이 최대한 노드가
차 있고, 가장 아래 층에서도 최대한 왼쪽으로 노드가 몰려있는
트리입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Perfect Binary Tree : Complete 이면서 Full 인 binary tree입니다.
높이가 $h$인 Perfect Binary Tree의 노드는 항상 $2^h$임을 기억하세요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로, Balance가 잘 잡혀 있는 binary tree는 높이가 $\log n$
정도이고, 한 줄에 가까운 binary tree는 높이가 $n$ 정도임을 기억하면
좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;heaps&quot;&gt;Heaps&lt;/h2&gt;

&lt;p&gt;Heap이라는 자료 구조는, 다음과 같은 성질을 만족하는 트리를 의미합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Complete Binary Tree. 즉, 최대한 균형이 잡혀 있고, 노드가 남는다면 왼쪽으로 몰아넣은 상태의 트리여야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;힙 성질. 부모 노드에 쓰여 있는 값은, 자식 노드에 쓰여 있는 값보다
항상 작거나 같다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제, Complete Binary Tree의 구조를 생각해 보면, 한 층씩 밑으로 내려올 때마다
노드의 개수가 2배씩 늘어나므로, 전체 노드의 개수가 $n$개 정도일 때, 높이
$h$ 는 $h \in \Theta(\log n)$ 입니다. 또한, Heap의 성질 상, Heap의
임의의 노드를 하나 잡으면, 그 노드를 root로 하는 subtree도 다시 heap임을
알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;heap-operation&quot;&gt;Heap Operation&lt;/h3&gt;

&lt;p&gt;Heap의 기본 operation으로, 다음과 같은 두가지 연산을 생각합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Heap에 어떤 수 $x$를 삽입하는 Push 연산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Heap의 노드를 삭제하는 연산&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pop 연산에서 루트만 생각해도 되는 이유는 앞서 말한 바와 같이, 모든
노드가 자신을 subtree로 하는 heap의 루트이기 때문입니다. 따라서, 위 두
연산만 있으면 Heap에 임의의 원소를 삽입하고 삭제할 수 있다는
의미입니다.&lt;br /&gt;
이 연산을 어떻게 구현할지 생각해 봅시다. Push의 경우, 다음과 같은
과정으로 수행합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;무조건 완전 이진 트리 성질을 만족하는 것을 우선하여, 끝 자리에
삽입합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;끝자리의 삽입으로 인해 힙 성질이 깨졌을 수 있으므로, 그 자리부터
올라오면서 힙을 수선합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;힙을 수선한다고 하는 말은, 실제로는 삽입한 자리부터 올라오거나
내려가면서, 자식 노드가 부모 노드보다 큰 값을 가졌으면 두 노드를
교환한다는 의미입니다. 앞으로 이와 같은 “힙 수선” 이라는 말을 계속 쓸
텐데, 기본적으로 특정 노드에서 힙을 수선한다면, 루트부터 리프까지
내려가면서 매 단계 최대 2개씩, 많아야 $2h \in O(\log n)$ 개의 노드만
보면 됩니다.&lt;br /&gt;
&lt;br /&gt;
힙에서 노드를 삭제하는 연산은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;완전 이진 트리 성질을 만족하는 것을 우선하여, 끝 자리 노드와 삭제할
노드의 자리를 바꿉니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;끝 자리의 노드를 지워도 완전 이진 트리 성질이 깨지지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제, 방금 교환에 의해 힙 성질이 깨졌을 수 있으므로, 위아래로
오가면서 힙을 수선합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;과정을 보면, 수선 외의 모든 Operation은 구현을 잘 하면 $O(1)$에 해결할
수 있을 것 같아 보입니다. 수선에서는 값 간의 비교가 최대 $O(\log n)$ 번
일어나기 때문에, 전체 알고리즘의 수행 시간은 $O(\log n)$ 입니다.&lt;/p&gt;

&lt;h3 id=&quot;heap-sort&quot;&gt;Heap Sort&lt;/h3&gt;

&lt;p&gt;빈 Heap과 $n$ 크기의 배열에서 시작해서, 모든 element를 Heap에 넣습니다.
그다음, 루트가 전체 heap의 최솟값이므로, 루트를 확인하고 삭제하는 연산을
$n$번 반복하면, 작은 원소부터 순서대로 나오게 됩니다. 넣고 빼는데 매번
$O(\log n)$씩이므로 항상 $O(n \log n)$ 정렬임이 보장됩니다!&lt;/p&gt;

&lt;h3 id=&quot;heap-implementation&quot;&gt;Heap Implementation&lt;/h3&gt;

&lt;p&gt;힙이 트리 구조라고 해서, 실제로 포인터 세개짜리 노드로 (Parent,
Left-Child, Right-Child) 구현해야 할 필요는 없습니다. 실제로는, 다음과
같은 원리로 배열에 트리를 얹는 느낌으로 구현하면 유용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1번 노드를 루트로 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n$번 노드의 두 자식 노드는 $2n$, $2n+1$번으로 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러면, 자동으로 $n$번 노드의 부모 노드는 $n/2$번 노드 (정수
나눗셈만 하면 바로 나옵니다!).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 ‘배열에 이진트리를 얹는’ 구현은 나중에 이진트리 기반의 자료구조를 구현할 때 정말 많이 쓰게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;additional-topics-and-problems&quot;&gt;Additional topics and Problems&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Heap sort에서는 어차피 복잡도가 달라지지 않아서 빈 힙에 $n$개의
원소를 순서대로 삽입하는 식으로 힙을 구성했지만, 실제로는 이미 있는
배열을 그대로 Heap으로 만드는 Heapify() 연산은 이보다 빨리 할 수
있습니다. 다음과 같은 과정을 이용합니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;가장 아래 노드 ($N$번) 부터 시작합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;자신의 값이 부모노드보다 높다면, 부모노드와 값을 교환합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이때의 값이 자식 정점보다 작다면, 자식노드 중 작은 쪽과 값을
교환합니다. (리프까지 내려가면서)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;재귀적으로 반복합니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Heap 수선 과정과 똑같아 보이지만, 약간의 차이는 위쪽으로는 끝까지
확인하지 않는다는 점입니다. 아래쪽으로는 재귀적으로 반복해야 하지만,
부모노드와 값을 교환했다고 해서 한번에 위쪽까지 힙을 수선하지 말고,
부모노드의 값은 나중에 그 노드 차례가 될 때 확인해도 됩니다.&lt;br /&gt;
이 알고리즘의 시간 복잡도를 생각해 보면, 자신의 높이에 비례하는
정도의 연산이 필요함을 알 수 있습니다. 대략 각 노드마다 높이가
$h$라면 대략 $O(h)$번 연산이 필요합니다. 높이가 $k$인 노드가
$2^k$개임을 이용하여, 이 알고리즘이 주어진 Array를 Heap으로 고치는
데 $O(n)$ 시간밖에 걸리지 않음을 보이세요.&lt;/p&gt;

    &lt;p&gt;힌트) 각 노드는 ‘최대 얼마나’ 내려갈 수 있나요?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;programming-practice&quot;&gt;Programming Practice&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;BOJ 19535번을 해결해 보세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BOJ 11279번을 (STL의 priority queue를 쓰지 말고) 해결해 보세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BOJ 1655번을 해결해 보세요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ds-alg-note" /><summary type="html">Contents</summary></entry><entry><title type="html">IV. Binary Search</title><link href="http://localhost:4000/ds-alg-note/04-binary-search/" rel="alternate" type="text/html" title="IV. Binary Search" /><published>2021-08-09T00:00:00+09:00</published><updated>2021-08-09T00:00:00+09:00</updated><id>http://localhost:4000/ds-alg-note/04-binary-search</id><content type="html" xml:base="http://localhost:4000/ds-alg-note/04-binary-search/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#binary-search&quot; id=&quot;markdown-toc-binary-search&quot;&gt;Binary Search&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#bisection-parametric-search&quot; id=&quot;markdown-toc-bisection-parametric-search&quot;&gt;Bisection (parametric) Search&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ternary-search&quot; id=&quot;markdown-toc-ternary-search&quot;&gt;Ternary Search&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;binary-search&quot;&gt;Binary Search&lt;/h2&gt;

&lt;p&gt;Up &amp;amp; Down 게임을 해 보셨나요? 1부터 1000까지의 수 중 하나를, 10번 정도면
맞출 수 있다는 사실을 알고 계시나요? 아마도, 모두가 절반씩 잘라서
확인하는 전략을 사용할 것입니다. 이 전략을 우리는 Binary Search 라고
부릅니다.&lt;br /&gt;
$N$ 크기의 배열이 정렬되어 있음을 안다면, 이 Up &amp;amp; Down 전략을 이용하여,
우리는 한번 질문할 때마다 절반씩 문제의 크기를 줄일 수 있습니다. 예를
들어, 10개짜리 배열의 5번을 열어 봤는데 우리가 원하는 값보다 크다면,
1번부터 4번 사이에 원하는 값이 있음을 아니까 2번이나 3번을 물어보면
됩니다. 이렇게 하면, $\order{\log n}$ 시간에 정렬된 배열에서 특정한 값을
찾을 수 있습니다. 이 알고리즘은 정말 유용합니다! Programming
Practice들을 풀면서 확인해 보세요 :)&lt;/p&gt;

&lt;h2 id=&quot;bisection-parametric-search&quot;&gt;Bisection (parametric) Search&lt;/h2&gt;

&lt;p&gt;Binary Search를 확인하여, 다음과 같은 질문에 빠르게 답할 수 있습니다.&lt;br /&gt;
어떤 함수 $f : \R \to \R$가 단조 증가하는 연속 함수일 때, $f(x) = k$ 인
$x$를 찾아라.&lt;br /&gt;
정확히 말하자면, 이 질문에 정확하게 답할 필요까지는 없고, 충분히 가까운
$x$를 찾으면 됩니다. 이제, $f$가 단조증가한다는 성질을 이용하여, 충분히
작은 수와 충분히 큰 수로 양쪽 끝값을 잡아 놓고, 그 사이를 구간으로 이분
탐색합니다.&lt;br /&gt;
예를 들어, $2^{1/3}$ 을 계산해야 한다고 생각해 봅시다. 이때, 우리는 답이
되는 $x$가 $x^3 = 2$ 를 만족하며, 이 값이 $0$과 $2$ 사이에 있음을
압니다. 이 구간의 중간인 $1$을 이용하여, $1^3 = 1 &amp;lt; 2$ 이므로, 답이
$1$과 $2$ 사이임을 압니다. 이제, $1.5^3 &amp;gt; 2$ 이므로, 답이 1과 $1.5$
사이임을 압니다. 이제 $1.25$를 시도하고...&lt;br /&gt;
이 알고리즘을 Parametric Search라고 합니다 (사실은, 이 단어는 더
일반적인 상황에서 쓰는 말입니다. 굳이 말하자면 Bisection search 정도가
정확할 것 같은데, 우리가 관심있는 Parametric Search가 이쪽이
대부분이라서 그런 것 같기도 합니다). Parametric Search는 Binary Search의
일반화이면서, 정말 많은 것들을 할 수 있습니다. 앞으로 대회 준비나 공부를
더 하다 보면, 이 아이디어를 이용하는 문제를 정말 많이 만나게 됩니다.&lt;br /&gt;
Parametric과 Binary 를 구분하지 않고 Binary Search를 이용한다고
말하는 사람도 많이 있고, 사실 이걸 굳이 구분할 필요가 있다고 생각하지는
않습니다. Binary라고 쓰더라도 맥락에 따라 이해해 주세요.&lt;/p&gt;

&lt;h2 id=&quot;ternary-search&quot;&gt;Ternary Search&lt;/h2&gt;

&lt;p&gt;* 이 subsection을 skip해도 뒤 내용에 영향이 없습니다.&lt;br /&gt;
어떤 함수 $f : \R \to \R$가 볼록함수라고 할 때, $f(x)$ 의 최솟값을 찾는
문제를 생각해 봅시다. 만약 $f$가 미분 가능한 함수라면, $f$의 도함수를
생각했을 때, $f’(x) = 0$이 되는 $x$를 Binary Search로 찾는 방법을 생각할
수 있겠습니다. 그러나 우리가 생각하는 함수가, ‘대충 볼록하게 생기긴
했지만’ 미분이 가능하진 않을 수도 있습니다. 이경우에, $\log$ 시간에
최솟값을 찾는 방법을 생각해 봅시다. 단, 이 함수 $f$가 평평한 구간을 갖지
않는다고 합시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;충분히 작은 $L$과 큰 $R$을 생각합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$[L, R]$의 삼등분점인 $p, q$를 생각합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일반성을 잃지 않고, $f(p) &amp;gt; f(q)$ 라고 가정합시다. 이때, 만약
최솟값이 $[L, p]$에 있고, 그 최소점이 $x = t$라면, 함수가 적어도
$t$에서 $p$까지 사이에서 증가하는 구간이 있고, 다시 $q$까지 감소해야
합니다. 이는 $f$의 볼록성과 모순이므로, 최솟값이 $[p, R]$ 사이에
있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우리가 보는 구간의 길이가 $\frac{2}{3}$으로 줄어들었습니다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제, 생각해 보면 매번 $2/3$으로 구간을 줄이는 것이므로, $\log_{3/2} n$
시간에 ($n$은 우리가 필요한 정밀도와, 구간 길이의 비율입니다. 간단히
말해, $[0, 10]$ 사이에서 $0.001$ 수준의 정밀도를 얻는 것은 1만 칸 중
하나를 찾는 느낌으로 접근하면 된다는 얘기입니다) 답을 얻을 수 있고,
Asymptotic하게는 로그의 밑은 무의미하므로 $\log$ 시간 알고리즘이 됩니다.
이 알고리즘을 Ternary Search, 삼분 탐색이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;이분 탐색이나 삼분 탐색은 그 자체로도 매우 의미있지만, 다른 알고리즘과
결합되었을 때 그 유용성이 더욱 부각됩니다. 그리고 처음 접했을 때
생각해내기 어렵기 때문에, 많은 연습이 필요합니다.&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ds-alg-note" /><summary type="html">Contents</summary></entry><entry><title type="html">III. 정렬과 탐색</title><link href="http://localhost:4000/ds-alg-note/03-sorting-and-searching/" rel="alternate" type="text/html" title="III. 정렬과 탐색" /><published>2021-08-09T00:00:00+09:00</published><updated>2021-08-09T00:00:00+09:00</updated><id>http://localhost:4000/ds-alg-note/03-sorting-and-searching</id><content type="html" xml:base="http://localhost:4000/ds-alg-note/03-sorting-and-searching/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#slow-sorting-algorithm&quot; id=&quot;markdown-toc-slow-sorting-algorithm&quot;&gt;Slow Sorting Algorithm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fast-sorting-algorithms&quot; id=&quot;markdown-toc-fast-sorting-algorithms&quot;&gt;Fast Sorting Algorithms&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#heap-sort&quot; id=&quot;markdown-toc-heap-sort&quot;&gt;Heap Sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#merge-sort&quot; id=&quot;markdown-toc-merge-sort&quot;&gt;Merge Sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quick-sort&quot; id=&quot;markdown-toc-quick-sort&quot;&gt;Quick sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hybrid-sort&quot; id=&quot;markdown-toc-hybrid-sort&quot;&gt;Hybrid Sort&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#selection-algorithms&quot; id=&quot;markdown-toc-selection-algorithms&quot;&gt;Selection Algorithms&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#quickselect&quot; id=&quot;markdown-toc-quickselect&quot;&gt;Quickselect&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#worst-case-linear-selection&quot; id=&quot;markdown-toc-worst-case-linear-selection&quot;&gt;Worst-Case Linear Selection&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#additional-topics-and-problems&quot; id=&quot;markdown-toc-additional-topics-and-problems&quot;&gt;Additional topics and Problems&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#programming-practice&quot; id=&quot;markdown-toc-programming-practice&quot;&gt;Programming Practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;우리의 목표는, $n$개의 원소를 가진 배열을 정렬하는 것입니다. 편의상,
다음과 같은 사실을 가정합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;정렬은 작은 것부터 큰 것 순서로 늘어놓는 것을 말합니다. ex) 1, 2, 3,
4, 5&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n$개의 원소에 대한 사전 정보는 전혀 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n$개의 원소는 모두 Random-access 가능한 형태로 저장되어 있습니다.
&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;slow-sorting-algorithm&quot;&gt;Slow Sorting Algorithm&lt;/h2&gt;

&lt;p&gt;자연스럽게, 정렬을 처음 생각하면 보통 $\order{n^2}$ 알고리즘을 생각하게
됩니다. 여기서는 비교적 간단하지만 유용한 Insertion sort 에 대해서만
알아보겠습니다. 한번 for loop을 실행할 때마다, 새 원소의 올바른 자리를
찾아 준다고 생각하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int key, j;
for(int i = 1; i &amp;lt; size; i++) {
    key = array[i];
    j = i;
    while(j &amp;gt; 0 &amp;amp;&amp;amp; array[j-1]&amp;gt;key) {
        array[j] = array[j-1];
        j--;
    }
    array[j] = key;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 알고리즘을 잘 살펴보면, 다음과 같은 사실들을 확인할 수 있습니다.&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Stable : 같은 원소 두 개, 즉 $x_1$ 과 $x_2$ 가 있을 때, 이 둘의
순서가 정렬 후에 바뀌지 않습니다. 이게 왜 필요하냐면, 이름 순으로
정렬된 사람의 목록을 나이 순으로 정렬한 다음에도, 같은 나이인
사람들끼리는 이름순으로 정렬되어 있음이 보장된다는 뜻입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In-place : 추가적인 메모리를 거의 소모하지 않습니다. 정의에 따라
다르지만, $O(n)$ 보다 작은 추가 메모리를 소모한다는 의미로
받아들이기도 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adaptive : 좋은 데이터가 주어지면, 그 성질을 활용해서 정렬을 더 빨리
끝낼 수 있습니다. &lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fast-sorting-algorithms&quot;&gt;Fast Sorting Algorithms&lt;/h2&gt;
&lt;h3 id=&quot;heap-sort&quot;&gt;Heap Sort&lt;/h3&gt;

&lt;p&gt;Heap 이라는 자료구조를 이용하는 정렬 방법으로, 나중에 Heap을 다룰 때 공부할 예정입니다.&lt;/p&gt;

&lt;h3 id=&quot;merge-sort&quot;&gt;Merge Sort&lt;/h3&gt;

&lt;p&gt;Merge sort (합병 정렬) 은 대표적인 Divide and Conquer 알고리즘입니다. 이
분할 정복 방법론 자체는 나중에 본격적으로 다루겠지만, 간단히 말하자면
다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;큰 문제를 한 번 푸는 대신, 이를 작은 문제로 나누어서&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각각의 작은 문제를 풀고&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 작은 문제의 결과들을 합치는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앞서 공부한 Master theorem을 이용하여, 이러한 유형의 알고리즘들이 왜 더
빨라지는지, 어떻게, 얼만큼 더 빨라지는지 이해할 수 있습니다. 여기서
주목할 만한 점은 크게 두 가지입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;작은 문제로 나누어 풀고 합치는게 정말 더 빠른가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작은 문제는 어떻게 푸는가?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1번 질문의 답은, Master theorem이나 이를 확장한 정리를 이용해 답하면
됩니다. 2번 질문은, 작은 문제가 큰 문제와 같지만 $n$만 작아진 버전이라는
사실에 주목하여, &lt;strong&gt;더 작은 문제&lt;/strong&gt; 로 나누어서 더 작은 문제를 풀고, .…
하면 됩니다. 간단히 말해서, &lt;strong&gt;푸는 방법이 자명해질 때까지&lt;/strong&gt; 문제를
줄이면 됩니다! 예를 들어, 정렬의 경우 배열의 원소가 2개 남으면, 자명하게
해결할 수 있습니다. &lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; 이제, Merge sort의 구체적인 방법을 생각해
봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;배열을 두개로 나눕니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각각의 배열을 Merge sort 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정렬된 두 배열을 합칩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../images/498956df70149475da97a6b92fa5729569fc056992112f16692130a63a8ae869.png&quot; alt=&quot;picture 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시간 복잡도를 생각해 봅시다. $n$개의 원소를 가진 배열을 정렬하는데
$T(n)$ 의 시간이 걸린다면, 두개로 나누어 각각을 정렬하는데 한번에
$T(n/2)$ 씩 2번이 필요할 것입니다. 이제 정렬된 두 배열을 합치면 됩니다.&lt;br /&gt;
합치는 과정은, 두 배열이 이미 정렬되어 있음을 이용합니다. 두 배열 각각의
시작점을 표시하고, 더 작은 쪽을 챙기고, 챙긴 원소를 빼는 방법으로
생각하면 됩니다. 구현을 처음 해본다면 상당한 주의가 필요하지만,
$\Theta(n)$에 가능하다는 것은 쉽게 이해할 수 있을 것입니다.&lt;br /&gt;
따라서, $T(n) = 2T(n/2) + \Theta(n)$이고, 이를 마스터 정리로 풀면
$T(n) \in \Theta(n \log n)$ 을 얻습니다.&lt;/p&gt;

&lt;h3 id=&quot;quick-sort&quot;&gt;Quick sort&lt;/h3&gt;

&lt;p&gt;Quick sort는 비슷하게 Divide and Conquer 방식을 이용하는 알고리즘으로,
더 간단하게 설명할 수 있습니다. 다음 세 줄이면 충분합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;적당한 Pivot을 고릅니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pivot보다 작은 원소는 왼쪽으로, 큰 원소는 오른쪽으로 보냅니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pivot의 좌우에 대해 반복합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 과정을 반복하여 전체 배열을 정렬하는 방법입니다. 이 방법이 왜 Quick
이라고 불리냐면, 실제로 돌려보면 평균적으로 Merge나 다른 정렬보다 빠르기
때문입니다. 그러나 이 방법에는 치명적인 문제가 있습니다.&lt;br /&gt;
적당한 Pivot을 어떻게 고르느냐에 따라, 알고리즘의 성능이 크게
좌우됩니다. 이 알고리즘의 성능은, Pivot보다 작은 원소가 $k$개, 큰 원소가
$n-k-1$개라고 할 때, $T(n) = T(k)+T(n-k-1)+\Theta(n)$ 형태로 나타난다는
사실을 어렵지 않게 알 수 있습니다. 모든 지점에서 $k = 0$이라면, 즉 운이
매우 없어서 / 또는 데이터가 매우 불리하게 주어져서, 매번 가장 작은
원소가 Pivot에 걸린다면 수행 시간이 $\Theta(n^2)$가 됩니다. 이를 막기
위해서는, 비교적 중간값에 가까운 Pivot을 골라야 합니다. 그러나 이것은
필연적으로 Pivot 고르는 시간을 필요로 하게 됩니다. 크게 다음의 방법이
&lt;strong&gt;주로&lt;/strong&gt; 쓰입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Random : 배열의 &lt;strong&gt;임의의&lt;/strong&gt; 원소를 씁니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Median-of-3 (9) : 3 (9)개를 임의로 뽑아 보고, 그중 중간값을
Pivot으로 씁니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hybrid-sort&quot;&gt;Hybrid Sort&lt;/h3&gt;

&lt;p&gt;Quick sort는 $n$이 작을 때 상대적으로 느립니다. 반면, $O(n^2)$ Sorting
algorithm들은 단순하기 때문에 $n$이 작으면 매우 빠릅니다. 그래서, Hybrid
sort 라고 해서, Quick sort 같은 알고리즘을 쓰다가 원소의 개수가 적어지면
&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; Insertion으로 마무리하는 알고리즘이 있고, 이것의 성능이 단순
Quick보다 훨씬 좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;selection-algorithms&quot;&gt;Selection Algorithms&lt;/h2&gt;

&lt;p&gt;우리의 다음 목표는, $n$개의 원소 중 $k$번째로 큰 원소를 찾는 것입니다.
이것을 ‘selection’, 선택 문제라고 부르기로 합니다. 잠깐 생각해 보면,
정렬하고 나면, $\order{1}$ 에 선택 문제를 풀 수 있으므로, 선택 문제에
대한 알고리즘의 후보로 정렬을 쓸 수 있습니다. 다시 말해, 선택 알고리즘은
적어도 정렬보다는 쉬운 문제 (Computationally, 시간 복잡도가 같거나 더
작은 문제) 일 것이라는 생각을 할 수 있습니다. 구체적으로, 우리는 어떤
$k$에 대해서든, $\order{n}$에 해결하고 싶습니다. 가장 작은 원소, 가장 큰
원소 등은 $\order{n}$에 찾을 수 있음이 자명하기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;quickselect&quot;&gt;Quickselect&lt;/h3&gt;

&lt;p&gt;Quickselect algorithm은 Quicksort를 응용한 방법입니다. 먼저, Quicksort
알고리즘을 크게 다음과 같이 정리합시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Partition : pivot을 기준으로 좌우로 원소들을 분할하는 작업.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Recursive Quicksort $\times 2$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제, 생각해 보면, Partition을 똑같이 해보고 나서, 왼쪽 또는 오른쪽 중에
어느 쪽에 우리가 원하는 $k$번째 원소가 있는지를 알 수 있습니다. 예를
들어, 10개의 원소가 3개-pivot-6개로 나누어져 있고, 우리가 7번째 작은
원소를 원한다면, 왼쪽은 버리고 오른쪽에 대해서만 재귀적으로 들어갑니다.
즉, 오른쪽 part에 대해 3번째로 작은 원소를 고르면 됩니다. (5, 6, 7, 8,
9, 10 중 3번째를 고른다는 의미)&lt;br /&gt;
이 방법은 정말 빠를까요? 얼마나 빠른지를 생각해 봅시다. 만약에, 한번
실행마다 절반씩 원소를 줄일 수 있다면 (최적의 Partition), $n$, $n/2$,
$n/4$ $\dots$ 에 대한 Partition만 하면 끝나므로, 이를 무한급수로
생각하면 $2n \in \order{n}$ 시간에 해결할 수 있습니다. 즉, Pivot을 잘
고르면 $\order{n}$ 시간에 해결할 수 있음을 의미합니다. 그러나, Quick
sort와 마찬가지로, Pivot을 계속 못 고르면 $n^2$ 시간이 걸릴 수도
있습니다. 이런 알고리즘에 어떤 의미가 있는지는 문제 iv 번을 참고하세요.&lt;/p&gt;

&lt;h3 id=&quot;worst-case-linear-selection&quot;&gt;Worst-Case Linear Selection&lt;/h3&gt;

&lt;p&gt;우리의 목표에 있어서 별로 중요하지 않기 때문에, 매우 간단하게만
설명하겠습니다. 아이디어는 약간의 시간을 써서 Quickselect의 pivot이
나쁘지 않게 하는 것입니다. &lt;sup id=&quot;fnref:6&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;전체 $n$ 크기의 배열을, $n/5$개의 5개짜리 배열로 나눕니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;5개짜리 배열 각각의 중간값을 찾습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n/5$개의 수들 중, 중간값을 재귀적으로 구합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제, 이 수를 $M$이라고 합시다. 이 수는 &lt;strong&gt;중간값들의 중간값&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 $M$을 pivot으로, Partition합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 방법이 정말 빠를까요? (Additional 5 참고)&lt;/p&gt;

&lt;h2 id=&quot;additional-topics-and-problems&quot;&gt;Additional topics and Problems&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;(Almost-Sorted) Insertion sort의 Adaptive한 성질을 더 생각해 봅시다.
구체적으로, $n$개의 원소를 가진 배열에서, 각 원소가 sorting된
자리에서 $k$ 자리 이상 벗어나 있지 않음이 보장되어 있다고 가정하고,
Insertion sort가 $O(nk)$에 정렬을 완료함을 보이세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;STL의 sort가 어떻게 구현되어 있는지 찾아보세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(Tip) C++ sort의 comparator란, 두 원소의 크고 작음을 비교하는 기준을
제공하면 이를 기준으로 정렬해 준다는 의미입니다. 예를 들어, 두
String을 길이를 기준으로 정렬할 수 있습니다. 유용하니 반드시 익히길
권합니다. Comparator는 (이산수학을 수강했다면) strict partial
order여야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음 조건 하에서, 흐름을 따라가며 Quick sort의 시간 복잡도가 average $O(n \log n)$ 임을 보이세요.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;입력은 임의의 중복 없는 수열.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, 위 설명에서, $k$가 0부터 $n-1$까지의 임의의 수일 확률이 모두
일정하다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;이때, Average의 개념을 생각하면, $T(n)$ 에 대한 평균은
\(T(n) = \frac{1}{n}\left(\sum_{k = 0}^{n-1} T(k)+T(n-k-1)\right) + \Theta(n)\)
이 식을 어떻게 계산할지 생각해 보세요. 다양한 방법이 있습니다.&lt;br /&gt;
거의 비슷한데, Quick select 알고리즘의 평균 시간 복잡도가 $O(n)$
임을 보이세요. 다시 말해,
\(T(n) = \frac{1}{n} \left(\sum_{k = 0}^{n-1} \max\{T(k), T(n-k-1)\}\right) + \Theta(n)\)
이 식을 계산해 보세요.&lt;br /&gt;
&lt;strong&gt;힌트&lt;/strong&gt; : $T(n) \in O(f(n))$ 을 증명하는 방법으로, 수학적 귀납법을
생각해 보세요. $n$보다 작은 $m$에 대해, $T(m) \leq cf(m)$ 인 상수
$c$가 존재한다고 가정하고 $n$에 대해서도 성립함을 보입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Quick sort에서 각 과정에서 항상 좌우의 배열 크기가 1:9로
나누어진다고 가정하고, 시간 복잡도를 계산해 보세요. 1:99, 1:999에
대해서도 생각해 보세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(제약의 중요성) 맨 앞 장으로 돌아가, &lt;strong&gt;가정&lt;/strong&gt;을 보세요. 모든 수가
-100만부터 +100만까지라는 사실이 주어져 있을때, $n$개의 수가 주어질
때 $O(n)$에 정렬할 수 있는 방법을 제시하세요.&lt;/p&gt;

    &lt;p&gt;힌트 : 이 방법을 &lt;strong&gt;Counting Sort&lt;/strong&gt; 라고 부릅니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;앞서 제시한 Linear-Time Selection 알고리즘이 정말 Linear-time
selection을 보장함을 보이세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;(Sorting Lower Bound)&lt;/strong&gt; Decision tree에 대해 찾아보고, Worst
case에 $O(n \log n)$ 보다 좋은 비교 기반의 정렬 알고리즘이 없음을 납득하세요. 이를 Sorting lower bound라고 부릅니다. (6번에서 다룬 Counting sort는 비교 기반 정렬이 아니므로 (&amp;lt; 연산의 결과를 쓰지 않습니다) 이 내용과 상관 없습니다)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;programming-practice&quot;&gt;Programming Practice&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;STL의 도움을 전혀 받지 말고 (필요하다면 벡터 정도까지는 써도 됩니다)
편한 방법대로 quick sort와 merge sort를 구현해 보세요. Baekjoon OJ의
2751번에 제출해서 구현을 확인해 보세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Quickselect를 구현해서 Baekjoon OJ의 11004번에 제출하고, 시간 초과를
받았다면 개선해 보세요. &lt;sup id=&quot;fnref:7&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; Worst case linear selection을 구현해
보세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BOJ 11650, 11651을 통해 STL의 sort 함수 사용법을 익히세요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Small exercise) Asymptotic analysis를 이용하여, 이 가정이
불필요함을 보이세요. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;직접 확인해 보세요. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Additional 의 i 를 참고하세요 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;한 줄로, 한번에 풀 수 있을 때까지 나누면 된다고 생각하기 쉽습니다.
사실은, 충분히 빨리 풀 수 있는 방법이 있다면 굳이 그럴 필요는
없습니다. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Typically, 8, 16, 32, 64 정도 값을 택합니다. &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;목표는 &lt;strong&gt;좋게&lt;/strong&gt; 가 아니라 &lt;strong&gt;나쁘지 않게&lt;/strong&gt;. (Additional 5) 참고. &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:7&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;항상 Worst case에 대비하는 mind를 준비하세요! ㅋㅋ &lt;a href=&quot;#fnref:7&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ds-alg-note" /><summary type="html">Contents</summary></entry><entry><title type="html">II. 기본 자료구조</title><link href="http://localhost:4000/ds-alg-note/02-basic-ds/" rel="alternate" type="text/html" title="II. 기본 자료구조" /><published>2021-08-09T00:00:00+09:00</published><updated>2021-08-09T00:00:00+09:00</updated><id>http://localhost:4000/ds-alg-note/02-basic-ds</id><content type="html" xml:base="http://localhost:4000/ds-alg-note/02-basic-ds/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#자료-구조--data-structures&quot; id=&quot;markdown-toc-자료-구조--data-structures&quot;&gt;자료 구조 : Data structures&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#linked-lists&quot; id=&quot;markdown-toc-linked-lists&quot;&gt;Linked Lists&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#stacks--queues--deques&quot; id=&quot;markdown-toc-stacks--queues--deques&quot;&gt;Stacks / Queues / Deques&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#implementation&quot; id=&quot;markdown-toc-implementation&quot;&gt;Implementation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#standard-library&quot; id=&quot;markdown-toc-standard-library&quot;&gt;Standard Library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;자료-구조--data-structures&quot;&gt;자료 구조 : Data structures&lt;/h2&gt;

&lt;p&gt;이 장은 자료 구조에 대한 이야기입니다. 자료 구조는 알고리즘과 매우
밀접한 관련이 있는데, 어떤 식으로 자료가 저장되어 있는지에 따라
알고리즘의 소요 시간이 크게 달라지기 때문입니다. 특정한 자료구조를
이용해야만 빠르게 작동하는 알고리즘들도 수없이 많고, 알고리즘 자체에
명세처럼 이런 자료구조를 써야 한다고 말하는 경우도 많을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;linked-lists&quot;&gt;Linked Lists&lt;/h2&gt;

&lt;p&gt;가장 기본적인 자료구조인 Linked List (연결 리스트) 는, 한 줄로 쭉 연결된
&lt;strong&gt;노드&lt;/strong&gt; 들의 연결로 구성됩니다. 대표적은 Dynamic data structure라고 볼
수 있겠습니다. 우리가 앞서 본 바와 같이, 1개가 있을지 5개가 있을지
10만개가 있을지 모르는 상황에서 배열을 쓰려면 가능한 최대를 잡아야
합니다. 이는 매우 비효율적이기 때문에, 이러한 Dynamic data structure에
대한 고민은 매우 중요하다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;링크드 리스트를 구현하는 방법은 매우 간단합니다. 각 노드가 &lt;strong&gt;데이터&lt;/strong&gt;
와, &lt;strong&gt;다음 노드로 가는 포인터&lt;/strong&gt; 를 들고 있으면 됩니다. 노드를 &lt;strong&gt;struct
node&lt;/strong&gt; 로 관리하면 좋겠네요. 이제...&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;원소를 추가할 때는, 먼저 새 노드를 만든 다음, 추가하려는 위치를
잡고, 그 앞에 있는 노드의 next pointer를 지금 추가하려는 노드로
잡아주고, 새로 추가한 노드의 next pointer를 관리하면 간단합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;원소의 삭제는, 삭제하려는 노드 이전 노드를 찾아서 그 next pointer를
삭제하려는 노드의 다음 노드로 보내주면 됩니다. Dynamic memory
alloc/dealloc에 주의해 주세요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자료구조 / 알고리즘을 공부할 때 좋은 rule of thumb 중 하나는, 뭔가를
얻었으면 뭔가를 지불해야 한다는 점입니다. 이 손해는 구현의 난이도일수도
있고, 상수가 크다는 점일 수도 있고, 다른 연산이 느릴 수도 있는데, 링크드
리스트는 이 대표적인 사례 중 하나입니다. 먼저...&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;10만개짜리 리스트 중 5만 6천번째가 뭔지 확인하고 싶으면, head부터
next포인터를 5만6천번 따라가야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;삭제할때, 이전 노드를 찾는 작업이 굉장히 귀찮습니다. ‘지금 보고 있는
노드’ 뿐 아니라, ‘그 직전 노드’ 가 뭔지도 관리하면서 Loop를 돌려야
하기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;후자는 구현상의 문제니 뭐 그렇다고 치더라도, 시간 복잡도로 생각해 보면
임의 위치의 삽입/삭제/접근이 모두 $O(n)$ 시간이 걸린다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;배열의 경우, 임의 삽입은 개수가 넘어가면 안 될수도 있고, 되더라도 삽입
삭제는 $O(n)$이 걸리는데 비해 접근은 $O(1)$에 할 수 있으므로, 동적
리스트를 얻기 위해 임의접근 속도를 포기했다고 보면 되겠습니다.&lt;/p&gt;

&lt;p&gt;변형된 형태의 동적 리스트로, 다음 노드 뿐 아니라 이전 노드로 가는
포인터도 관리하는 double linked list, 구현상의 편의를 위해 Head와 Tail을
이어 버리는 circular linked list 등등이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;stacks--queues--deques&quot;&gt;Stacks / Queues / Deques&lt;/h2&gt;

&lt;p&gt;스택은 Last-in First-out (LIFO) 형태의 자료구조입니다. 즉, 다음 두
연산을 지원하는 자료구조를 말합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Element를 맨 위에 추가 (push)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;맨 위에 쌓은 element를 빠르게 확인하거나 (peek), 가져오기 (pop)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서, &lt;strong&gt;할 수 있다&lt;/strong&gt; 는 말은 사실 &lt;strong&gt;빠르게 할 수 있다&lt;/strong&gt; 는 말입니다.
당연히 스택에서 맨 밑 원소를 보는것도 그 위에 $n$개의 원소를 다 뽑아내면
할 수는 있습니다. 다만 위 두 연산을 $O(1)$에 할 수 있음이 중요합니다.&lt;/p&gt;

&lt;p&gt;Queue는 First-in First-out (FIFO) 형태의 자료구조입니다. Stack과는 달리,
Element를 위에서 넣고 뺄 때는 아래에서만 뺀다고 생각하면 됩니다.&lt;/p&gt;

&lt;p&gt;Deque는 Queue와 Stack의 기능을 합쳐, Front/Rear access와 insert가 모두
$O(1)$에 작동하는 자료구조입니다.&lt;/p&gt;

&lt;p&gt;이 세 가지에 대한 자세한 설명은 워낙 좋은 내용들이 많고, 어려운 내용도 아니라서 패스하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;세 자료구조 모두 개념적으로는 Doubly Linked List로 구현하면 됩니다.
구현의 용이성을 위해 Dynamic함을 포기하고 1차원 배열에다가 배열의 양
끝을 표시하는 index variable 2개를 쓰는 구현도 많이 사용하는데, 이
경우에는 메모리에만 들어가면 원하는 만큼 많이 넣을 수 있다는 기본적인
가정을 위배하는데 비해 시간복잡도상의 이득이 있지는 않으므로 우리의
관심사는 아닙니다.&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;standard-library&quot;&gt;Standard Library&lt;/h2&gt;

&lt;p&gt;STL에는 stack, queue, deque가 다 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deque&amp;lt;int&amp;gt; dq;&lt;/code&gt; 와 같이
선언하고 쓸 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{push/pop}_{back/front}()&lt;/code&gt; 의 4개 함수를 제공합니다. 당연히
stack이나 queue는 제약이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;top(), front(), back()&lt;/code&gt; 등 peek-형 함수들이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;미세하게 문법이 다른데, 쓰면서 익히면 됩니다. 특히, stack이나
queue는 어차피 넣고빼는 위치가 정해져 있으므로 그냥 push/pop으로
사용하도록 되어 있습니다. 위 설명은 deque가 기준입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;vector는 스택이 할 수 있는 모든 것을 동일한 시간 복잡도에 할 수
있으므로, stack임을 명시하고 싶은 상황이 아니라면 vector를 써도
됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;다만... 링크드 리스트는 실제 퍼포먼스가 매우 느립니다. 링크드
리스트의 $O(1)$ 과 배열의 $O(1)$은 좀 다르긴 합니다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ds-alg-note" /><summary type="html">Contents</summary></entry><entry><title type="html">I. 시간 복잡도와 Big-O Notation</title><link href="http://localhost:4000/ds-alg-note/01-time-complexity/" rel="alternate" type="text/html" title="I. 시간 복잡도와 Big-O Notation" /><published>2021-08-09T00:00:00+09:00</published><updated>2021-08-09T00:00:00+09:00</updated><id>http://localhost:4000/ds-alg-note/01-time-complexity</id><content type="html" xml:base="http://localhost:4000/ds-alg-note/01-time-complexity/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#time-complexity-analysis&quot; id=&quot;markdown-toc-time-complexity-analysis&quot;&gt;Time Complexity Analysis&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#asymptotic-notation&quot; id=&quot;markdown-toc-asymptotic-notation&quot;&gt;Asymptotic Notation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#additional-topics-and-problems&quot; id=&quot;markdown-toc-additional-topics-and-problems&quot;&gt;Additional topics and Problems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;time-complexity-analysis&quot;&gt;Time Complexity Analysis&lt;/h2&gt;

&lt;p&gt;알고리즘 (Algorithm) 과 자료구조 (Data Structure) 를 공부하는 우리의
목표는, 같은 문제를 효율적으로 해결하는 것입니다. 뭔가를 효율적으로 하기
위해서는 항상 효율을 측정하는 기준이 필요할 것입니다.&lt;/p&gt;

&lt;p&gt;일반적으로 이 기준에는 다음 두 가지가 가장 중요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램이 얼마나 오래 걸리는가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램이 얼마나 많은 자원 (대표적으로 메모리 등) 을 요구하는가&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;당연하게도, 이 부분은 입력이 무엇인지에 따라 달라집니다. 대표적으로 원소
10개짜리 배열을 정렬하는 것과 100만개짜리 배열을 정렬하는 것의 소요
시간과 소모 메모리는 다를 수밖에 없기 때문입니다. 우리는 이를 위해,
일반적으로 &lt;strong&gt;입력이 증가함에 따라, 소요 시간과 메모리가 어떻게
변화하는지&lt;/strong&gt; 를 알고자 합니다.&lt;/p&gt;

&lt;p&gt;특히, 현대의 컴퓨팅 환경에서 중요한 것은 시간입니다. (메모리가 중요하지
않다는 뜻은 아닙니다) 따라서 우리는 알고리즘의 시간 복잡도를 가장
중요하게 볼 것입니다. 즉, 입력의 크기 $n$에 대해, 소요 시간 $T(n)$ 이
얼마나 빨리 증가하는가? 라는 질문을 알고리즘의 효율성으로 이해하고자
합니다. 그런데, 입력의 크기가 $n$으로 같다고 해서 정말 소요 시간이
같을까요?&lt;/p&gt;

&lt;p&gt;정렬하는 문제를 생각해 봅시다. 정렬하는 문제에서, 원소 10개짜리 배열을
정렬하는데...&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1, 2, 3, 4, ... 로 이미 정렬된 배열이 들어오면, 아무것도 할 필요가
없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어쩌면 거꾸로 정렬된 배열이 들어와서 다 엎어야 할수도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다면 크기가 $n$인 모든 입력에 대해 평균을 내는것이 합당할까요?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 크기가 $n$인 모든 입력의 집합 $S_n$에 대해, 다음 세 가지는 모두
중요할 수 있습니다.
\(\min_{s \in S_n} T(s) \quad\quad\quad \max_{s \in S_n}T(s) \quad\quad\quad \frac{\sum_{s \in S_n}T(s)}{\abs{S_n}}\)
이를 우리는, &lt;strong&gt;Best / Worst / Average&lt;/strong&gt; 시간복잡도라고 부릅니다.
알고리즘에 관한 연구는 수학적으로 엄밀한 것을 목표로 하기 때문에,
일반적으로는 Worst case를 가지고 다루고자 하는 tendency가 있습니다.
그러나 현실에서는 Average case를 잘 푸는 알고리즘도 매우 중요하기
떄문에, 필요하다면 이를 명시하고 사용할 것입니다. Unless otherwise
stated, 앞으로 나오는 복잡도는 worst case입니다. 즉, $T(n)$이란, 입력이
$n$인 입력들 중, worst case에 필요한 시간을 의미할 것입니다. 우리는
문제를 단순화하기 위해 $T(n)$을 $\N \to \N$함수로 받아들이겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;asymptotic-notation&quot;&gt;Asymptotic Notation&lt;/h2&gt;

&lt;p&gt;중요한 사실 하나는, 정확한 $T(n)$은 사실 그렇게 중요하지 않다는
부분입니다. &lt;strong&gt;컴퓨터 구조&lt;/strong&gt; 를 배우면 알수 있는데, 두 실수의 곱셈은 두
정수의 덧셈보다 수 배 이상 느립니다. 즉 정수덧셈 100만번이 실수곱셈
20만번보다 빠를지도 모른다는 의미입니다. 수학적으로는 보통 FLOP count 라
하여, 실수 연산 몇번으로 bound 되는지를 가지고 관찰하는데, 정수연산만
쓰는 알고리즘을 개발하였다면 이는 조금 불합리하게 느껴질 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 $n$이 커질 때, $n^2$, $n^2 \log n$, $n^3$ 등은 상당히 큰 차이를
불러일으킵니다. 따라서, 우리는 다음과 같은 Big-O notation을 정의할
것입니다. Big-O notation $O(g)$란, $g : \N \to \N$ 에 대하여,
\(f \in O(g) \iff ^\exists N, C \in \N \st ^\forall n \geq N, f(n) \leq Cg(n)\)
이를 잘 생각해 보면 다음과 동치임을 알 수 있습니다.
\(f \in O(g) \iff \limsup_{n \to \infty} \frac{f(n)}{g(n)} &amp;lt; \infty\)
대충, 의미를 받아들일 때는 ‘충분히 큰 $n$에 대해, $f$를 $g$의 상수 배로
바운드를 잡을 수 있다’ 라고 생각하시면 됩니다. 예를 들어 $3n^2 + 4n + 6$
은 $O(n^2)$ 다 라고 말할 수 있는 것입니다.&lt;/p&gt;

&lt;p&gt;Big-Omega notation이라는 것이 있습니다. Big-Omega는 반대로, 알고리즘의
하한에 대한 논의입니다. &lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
\(f \in \Omega(g) \iff ^\exists N, C \in \N \st ^\forall n \geq N, f(n) \geq Cg(n) \iff \liminf_{n \to \infty} \frac{f(n)}{g(n)} &amp;gt; 0\)&lt;/p&gt;

&lt;p&gt;간혹 Little-o 와 Little-omeaga도 씁니다.
\(f \in o(g) \iff \lim_{n \to \infty} \frac{f(n)}{g(n)} &amp;lt; \infty\)&lt;/p&gt;

&lt;p&gt;중요한 notation으로, $f \in O(g)$ 이고 $f \in \Omega(g)$ (또는
$g \in O(f)$) 이면, $f \in \Theta(g)$ 이고 $g \in \Theta(f)$ 라고
씁니다. 대략 시간 복잡도의 관점에서 두 함수는 사실상 같게 취급된다는
의미입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 위에서 본 $3n^2 + 4n + 6$는 $O(n^2)$ 이고 $O(n^3)$ 이지만,
$\Theta(n^3)$은 아닙니다. 하지만 $\Theta(n^2)$ 가 됨은 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;우리는 편의상 알고리즘을 공부하면서, 1억 = 1초라는 Rule of Thumb을
이용합니다. 즉, $O(n^2)$ 알고리즘이면, 대략 $n = 10000$ 까지는 1초에
작동할 것이라고 믿겠다는 말입니다. 이 규칙이 몇년째 바뀌지 않았다고
들은것 같은데, 그동안 컴퓨터는 빠르게 발전했기 때문에 사실 지금은
1억보다는 더 많이 돌아가기는 합니다만, 우리가 $O(n^2)$이라고 말하더라도
실제로는 $3n^2 + 6n$ 같은 것일 경우가 많으므로 Rule of Thumb으로는
유효하다고 생각합니다.&lt;/p&gt;

&lt;p&gt;시간 복잡도는 매우 중요하고 항상 생각해야 하지만, 시간 복잡도가 모든
것을 좌우하지 않음도 꼭 기억해야 합니다. 컴퓨터 구조 같은 수업에서 왜
그런지, 어떻게 그런지 공부하게 됩니다. 어떤 연산은 복잡도에 비해
빠르거나 느립니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt; 왜인지 정확히는 모르겠지만 Big-Theta를
의미하면서도 말은 Big-O로 말하는 이상한 Tradition이 있습니다. 저도 그
영향을 받았기 때문에 그렇게 쓰는 일이 많이 있습니다. (추측이 좀
섞여있지만) 사실 중요한 것은 알고리즘이 얼마나 빠른지이므로, Big-O가
가장 중요해서일 것입니다. 예로 $O(n^2)$ 알고리즘을 개발했다면, 이게
실제로 $\Theta(n \log^4 n)$ 인지 tight하게 prove하는 것보다는 ‘아무튼
$n^2$ 이상의 퍼포먼스를 보여준다’ 는 점이 중요하기 때문이 아닌가 합니다.
$\Theta$ 를 최대한 사용하려고 노력하겠지만, 일부 그렇지 못한 경우가 있을
수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의2&lt;/strong&gt; $f \in O(g)$ 를 의미하면서 무려 $f = O(g)$ 같은 Abuse of notation도 꽤 흔한 듯 합니다.&lt;/p&gt;

&lt;h2 id=&quot;additional-topics-and-problems&quot;&gt;Additional topics and Problems&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Amortized Analysis가 무엇인지 찾아보고, 어떨때 유용할지 생각해
보세요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;($\bigstar$) 알고리즘 수업에서 배우는, Master Theorem이라는 정리가
있습니다.&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 몇가지 알려진 재귀식을 빠르게 해결할 수 있는 방법으로,
알아두면 알고리즘 분석에 많은 도움이 됩니다. 정리를 기술하면 다음과
같습니다.&lt;/p&gt;

    &lt;hr /&gt;
    &lt;p&gt;어떤 알고리즘이 $n$ 크기의 입력을 받았을 때, $n/b$ 크기의 입력
$a$개로 문제를 쪼개어 해결한 후, 이를 $f(n)$ 시간에 합친다고 하자.
즉, 시간 복잡도가 다음과 같다고 하자. \(T(n) = aT(n/b) + f(n)\)
이때, $c = \log_b a$ 라고 하자. 다음과 같은 경우, 이 점화식의 다음과
같은 해가 알려져 있다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;$f(n) \in O(n^d),\ d &amp;lt; c$ : $T(n) \in \Theta(n^c)$&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;$f(n) \in \Theta(n^c \log^k n)$ : Depends on value of $k$.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;$k &amp;gt; -1$ : $T(n) \in \Theta(n^c \log^{k+1} n)$&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;$k = -1$ : $T(n) \in \Theta(n^c \log \log n)$&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;$k &amp;lt; -1$ : $T(n) \in \Theta(n^c)$&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;$f(n) \in \Omega(n^d), d &amp;gt; c$ 이고,
$^\exists k &amp;lt; 1 \st af(n/b)\geq kf(n)$ for large enough $n$ :
$T(n) \in \Theta(f(n))$&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;hr /&gt;

    &lt;p&gt;증명은 알고리즘 수업에서도 (아마도) 다루지 않겠지만, 다음과 같은
사실을 이용합니다. 수학에 관심이 많고 이런걸 보고 증명이 없으면 못
넘어가는 성격이라면 시도해 보세요.&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;br /&gt;
점화식을 Recursion Tree 형태로 그리면 다음과 같은 사실을 쉽게 알 수
있습니다.
\(T(n) = \sum_{i = 0}^{\log_b a} a^i f(n/b^i) + O(n^{\log_b a})\)
이제, 각 Case별로 조건을 나누고 침착하게 Bound를 잡으면 됩니다.
힌트를 조금 드리자면, 1번과 같은 조건을 해석하는 좋은 방법은
$f(n) \in O(n^{c - \epsilon})$ 이라고 생각하는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Knuth의 저서에서는 $f \in \Omega(g) \iff g \in O(f)$ 로
정의했는데, 이 정의는 원래의 정의와 조금 다르지만 CS에서 사용하는
함수들에 대해서는 거의 같으며, 훨씬 이해가 편하므로 이쪽을 쓰기도
합니다. 저희도 대충 이걸로 생각할 계획입니다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;정수론에서 사용하는 Hardy-Litttlewood Omega와 &lt;strong&gt;아주 조금&lt;/strong&gt;
다릅니다! &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;[CLRS] 4.3 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;이 증명을 알아야 한다는 뜻은 아닙니다 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ds-alg-note" /><summary type="html">Contents</summary></entry></feed>