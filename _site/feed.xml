<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-06-20T17:43:49+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gratus907’s Study Note</title><subtitle>Hello World!</subtitle><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><entry><title type="html">2021 1학기 종강</title><link href="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/" rel="alternate" type="text/html" title="2021 1학기 종강" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>http://localhost:4000/retrospects-and-plans/finishing-2021-spring</id><content type="html" xml:base="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/">이번학기도 무사히...ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.

## Academic

### Spring Semester Courses

#### Hardware System Design (CSE, 3)

-   Verilog를 이용하여 행렬곱셈 하드웨어 가속기를 만들고, CNN을 빨리돌리는..뭐 그런걸 배우는 과목입니다.
-   저는 베릴로그 코딩을 굉장히 힘들어하기 때문에 팀원이 좀 많이 고생했습니다. 논리설계때 좀 열심히 들을걸 하는 깊은 후회와 미안함을 느끼고 있어서, 창통설은 제가 좀더 나서서 고생할 계획입니다 (아마도...)
-   그와는 별개로 배우는 내용은 매우 흥미로웠는데, 저한테는 좀 힘들었습니다. 제 관심 분야와는 멀다보니 전선이었다면 안 들었을 것 같은데 전필이라 (내 선택에 맡겼다면 있는지도 몰랐을 것들을) 배울 수 있었다는 데 의의가 있다고 생각합니다. 솔직히 NPU, 딥러닝용 FPGA 등이 매우 전망있고 미래에 중요한 기술일 거라는 생각은 듭니다. 다만 제가 개척할 미래는 아니고, 다른 훌륭한 엔지니어들이 수십배 빠른 NPU를 만들어 줄거라고 믿어 의심치 않습니다.
-   프로젝트가 정말 빡세지만 끝나고 보니 그럭저럭 재밌기도 했습니다. 다만 조금 힘들었던 부분들에 대해서는 언젠가 제 시간이 허락하고 팀원이 동의하면 셀프 검열을 좀 거쳐서 얘기해보고 싶습니다. 소개원실 프로젝트는 이렇게 말하고 영원히 검열을 통과하지 못했는데, 하시설은 그정도로 고통스럽지는 않았기 때문에 언젠가는 검열을 통과할수 있을 것 같습니다.

#### Discrete Mathematics (CSE, 1)

-   CS 101인데 지금듣는 놀라운 역수강의 결과입니다. Subgraph Isomorphism에 대한 논문을 읽다가 graph가 뭐고 simple graph가 뭔지 배우는 등... 많은 괴리가 있었습니다.
-   다른 학교의 이산수학과는 달리 저희는 Group이 무엇인지, Lattice가 무엇인지 등 좀 신기한 것들을 많이 배웁니다. Lattice는 처음 듣는 내용이라 당황해서 (정수론의 Lattice가 아닌 집합론의 Lattice입니다) 다른학교 컴공과 친구들 몇명 붙잡고 이게도대체 뭐냐고 물어봤지만 아무도 모르던데, 나름 신기한 뭐가 많았습니다.
-   별개로, 1학년때 들었다면 좋았을것 같습니다. 저야 수학을 복수전공하니까 Proof의 구조나 Function, Relation 등에 대해 공부할 일이 어차피 있었기 때문에 그 효용이 크지 않았겠습니다만 저처럼 수학을 많이는 공부하고 싶지 않더라도 CS 전공자에게 필요한 수학을 단시간에 빠르게 습득할 수 있는 과목이었다는 생각이 듭니다.

#### Numerical Linear Algebra (MATH, 3)

-   수리과학부 수치해석 루트의 과목입니다. MATLAB 또는 Python을 이용한 프로그래밍도 해야 하고, 그냥 과제의 양이 정말 충격적으로 많았는데 그만큼 많이 배웠다고 생각합니다. 중간고사 때까지는 사실 많은 내용을 어디서 주워들은 것들이라고 생각했었는데, 중간고사를 보고 그렇지 않음을 깨달은 뒤 (...) 기말고사는 열심히 공부하고 봤습니다.
-   간단히 요약하자면, 행렬에 대한 알고리즘을 배우는 과목입니다. numpy의 수많은 알고리즘들을 그대로 가져다 쓸수도 있겠지만, 누군가는 그런것들을 만들어야 하니까요. 예를 들어, 1000 \* 1000 행렬의 eigenvalue를 어떻게 구할지, eigenvalue 전부가 아니라 몇개만 필요하다면 어떻게 구할지... $Ax = b$는 정해진 해 $x = A^{-1} b$ 가 있지만, 세상에는 감히 역행렬을 구할 시도조차 할 수 없는 사이즈의 문제들이 있습니다. 그렇기에 iteration method 등 여러 clever 한 알고리즘들을 써야 하는데, 그런 부분들을 배웁니다.
-   컴퓨터공학부 알고리즘 수업은 아무래도 이산적인 구조에 집중하고, 다익스트라 알고리즘, 다이나믹 프로그래밍 등등을 배워야 하기 때문에 수치적 알고리즘은 다루지 않게 됩니다. 저희과는 수치해석에 대해서는 공학수학에서 조금 배우는 정도이기 때문에, 후반부 내용들은 굉장히 새로웠습니다.
-   필기노트를 언젠가 LaTeX로 바꿔서 블로그에 공유하고 싶은 과목으로 현재로서는 두번째에 있습니다 (첫번째는 지난학기에 들었던 최적화 이론입니다) 다만 가장 큰 문제는, LaTeX가 행렬 타이핑이 굉장히 어렵다는 점입니다. 고민해보고 있습니다.

#### Number Theory (MATH, 2)

-   수리과학부 2학년 과목이고, KMO 출신들을 이길수 없기 때문에 학점은 포기하고 들어야 하는 과목입니다. 다만 교수님께서 원래 Cryptography를 연구하시고, Pollard-Rho 알고리즘의 발전에 지대한 공헌을 하신 등 Computational Number Theory에 가까운 분이시기 때문에 저한테는 정말 재밌는 수업이었습니다. 수업중 Algorithmic한 부분들 - 예를들어 Lenstra의 소인수분해 등 - 에 대한 언급이 많았고, 격자이론이나 동형암호에 대한 특강 등 컴퓨터공학 전공인 저한테는 정말 배울게 많았습니다.
-   PS하면서 배운 정수론을 좀더 정확히 이해할 수 있었습니다. 초반에 빠르게 일반적인 정수론의 주제들 (중국인의 나머지 정리, 페르마 소정리, 오일러 피 함수, 르장드르 기호, 이차 잉여, 디리클레 합성곱 등) 을 달린 후, 후반에는 타원곡선, 무리수의 유리근사, 소수정리 등의 재밌는 주제들을 폭넓게 다루었는데 솔직히 80%도 채 소화하지 못한 것 같아 아쉽습니다. 언젠가 제가 ~정신을 잃고~ 대수적 정수론 같은걸 펴볼 날이 올까요?

#### Real Analysis (MATH, Grad 1) / Undergrad Real Analysis (MATH, 4)

-   이번학기를 지배한 실해석/실변수 세트입니다. 실해석학은 워낙 유명한 과목으로 대학원 1년차 과목임에도 학부생 수강생이 훨씬더 많고 타과생도 많습니다만 제기억에 컴공과는 저밖에 없었습니다. 주로 해석학을 배워야 하는 통계학과, 경제학과가 많았습니다.
-   GRA / URA로 구분하자면, GRA는 루딘의 Real and Complex Analysis의 앞부분 반정도를 커버하고, URA는 Folland의 Real Analysis를 기준으로 그중 일부를 나갑니다. 두 과목의 가장 큰 차이는 &apos;세팅&apos; 이었다고 생각하는데, GRA는 Locally Compact Hausdorff space X를 기본 세팅으로 두는데 비해 URA의 기본 세팅은 $\\R$ 또는 $\\R^2$ 입니다. 예를들어 Fourier Series를 이해하기 위해 URA에서는 직접 적분을 계산하고 Dirichlet Kernel, Fejer Kernel 등등을 이용하여 내용을 진행하는데 비해, GRA에서는 Hilbert space (완비내적공간)에 대한 일반적인 성질들을 공부하고 그걸 $L^2(\[-\\pi, \\pi\])$ 에 적용하는 식입니다.
-   그렇다보니 Measure theory, Lebesgue 적분 등을 두가지 관점에서 동시에 보면서 (뚝배기가 박살나긴 했지만) 재밌게 공부할 수 있었습니다. 종합해서 해석학에 대한 이해를 높일 수 있었다고 생각합니다.
-   다만 저처럼 수학을 찍먹할 사람이면 모를까, 수학 전 분야에 대한 이해를 좀 가져야 할 수리과학 전공생들에게 권할만한 테크인지는 잘 모르겠습니다. Redundancy가 있는건 사실이니까요. 저는 복수전공자니까 전필만 듣고나면 제가 듣고싶은거 적당히 골라듣고 챙기면서 움직여도 뭐 되지 않을까요.
-   Measure theory를 공부하게 된 계기는, 3학년 2학기 때 수강했던 최적화 이론입니다. 최적화 이론에서 Martingale 등 놀라운 이론들을 통해 수렴성을 얻는게 좀 있었는데, 도대체 수렴하면 수렴하는거지 Almost surely converge한다는건 무슨소리인가??? 에 대해 답할 수 있게 되었습니다. 최적화이론 수업 이후 조언을 구하였을 때, measure theory와 stochastic differential equation에 대한 공부가 최적화 분야의 엄밀한 이해에 도움이 될 것이라는 조언을 얻을 수 있었습니다.

### Extracurricular

-   지난 2학기 ~ 이번 4월까지 컴퓨터공학부 컴퓨터이론 및 응용 연구실에서 수행했던 UROP 결과로 작성에 참여한 논문을 한국정보과학회에서 주관하는 한국 컴퓨터 종합 학술대회 (Korea Computer Congress) 에 제출하여 발표 (발표는 제가 하는건 아니지만) 하게 되었습니다. 솔직히 짧은 경험과 부족한 지식, 코로나 시국이라 대부분이 비대면으로 진행된 현실 상 제가 뭔가 딥하게 할수 있었던건 별로 없고, 어떤식으로 이런 프로세스들이 돌아가는지 배웠다는 것, 논문 읽고 코드 좀 고쳐서 테스트해보면서 그래도 학교 공부와는 또 다른 느낌의 뭔가를 생각해봤다는데 의의가 있는게 아닌가 생각하기로 헀습니다.
-   연구실에서 감사하게도 KCC 참가비용을 지원해주셔서, 23-25일에는 발표도 듣고 그러게 되었습니다. 재밌는게 있으면 정리해서 뭘 배웠는지 또 포스팅 해보려고 합니다.
-   \[UPD\] KCC 2021에 결과물인 &quot;부분 그래프 매칭 문제를 위한 향상된 동적 매칭 순서&quot; 를 제출하여 Oral 발표 세션에서 발표될 예정입니다. (발표는 뭐 제가 하는건 아니고, 주저자이신 박사과정 연구원님께서 하십니다) 부족한 제게 정말 과분하게 좋은 경험이었고 감사하게 생각하고 있습니다.

### Miscellaneous

-   코로나 시국이라 Personal하게 크게 바뀔만한건 없는듯합니다.
-   가까운 친구/지인 몇명이 병특 등을 포기하고 군대를 갔습니다. 산업기능요원 TO 감소를 비롯하여 여러 이슈들이 겹쳐진것 같은데, 개인적으로 석전연/박전연 중 한쪽을 제 루트로 생각하고 있어서 현재는 입대는 계획에 없습니다. 그래도 유학 등 때문에 고민은 많네요...

## 2021 Summer

-   졸업을 해야 하므로 (...) 과학 교양을 채워야 합니다. 실험 듣기 싫어서 미뤘던 죄값을 치를 순간이 왔습니다. 이번 여름에 일반생물학과 일반생물학 실험을 듣게 되었습니다. 고등학교 때 암기가 싫어서 생명과학 2를 고르느니 물리2 화학2 수능을 보고 말겠다고 선언하고 (가오에 지배당해서) 실제로 그렇게 했던 제게는 너무나 끔찍한 형벌이 아닐 수 없습니다.
    -   그러나 늘 그렇듯 새로운걸 배우기 전까지는 알 수 없는 법입니다. 저는 제가 대학와서 수학을 이렇게 많이 공부할지 몰랐으니까요.
    -   라고 셀프 세뇌하고 있습니다.
-   수학과의 지인과 지식공유? 의 차원에서, 제가 자료구조/알고리즘과 C++ 프로그래밍을 좀 가르쳐주고 현대대수2의 내용을 좀 배우기로 했습니다. 다음학기에 현대대수2를 들을 예정인데 현대대수1을 모두 잊어버렸기 때문에 복습과 예습이 조금 필요합니다. 어제 그 지인분이 &quot;그렇게 아예 잊어버리기야 했겠느냐&quot;며,  &quot;Normal subgroup이 뭔지 기억하죠? Ideal이랑&quot; 라고 물었을 때 &apos;어...$g$랑 $g^{-1}$를 앞뒤로 곱했던거 같은데...&apos; 와 &apos;아뇨 기억 안나는데요&apos; 로 대답하는 놀라운 당당함을 보여줬습니다. 모르긴 몰라도 이샛기는 붕어인가?? 하는 생각에 FACEPALM하고 있지 않을까요?
-   그외 계획은 아직 미정입니다. PS도 좀 하고 (이건 이제 반쯤 취미죠)...</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="retrospects-and-plans" /><summary type="html">이번학기도 무사히…ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.</summary></entry><entry><title type="html">Codejam 2021 Round 2</title><link href="http://localhost:4000/algorithms/Codejam-2021-R2/" rel="alternate" type="text/html" title="Codejam 2021 Round 2" /><published>2021-05-19T00:00:00+09:00</published><updated>2021-05-19T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/Codejam-2021-R2</id><content type="html" xml:base="http://localhost:4000/algorithms/Codejam-2021-R2/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

올해 Codejam의 (나한테 있어) 사실상 마지막 round이므로 (R3 는 재밌게 하겠지만 competition으로써는 얻을게 없다) Hashcode 때처럼 prep과 과정을 좀 적어보려고 한다. 앞으로 메이저한 대회는 이렇게 적어볼 생각이다.

## Preperation
그렇게 말하긴 했지만 준비할수 있었던건 딱히 없다. 올해는 CP에 쓰기에는 너무 할일이 많다. 

방학때면 모를까...학기중에 PS/CP에 많은 시간을 투자하기에는 아무래도 어려움이 많다. 그래도 작년 코드잼과 지금 비교했을때 (PS적인 측면에서) 어떤 점들이 나아졌는지 / 나아지지 않았는지 비교해보면 준비를 되새기는 측면에서 조금은 도움이 될것 같기도 하다.

- Courses. Problem solving은 결국 아이디어와 지식이 둘 다 필요한데, 몇몇 내용들 - 작년 1학기에 들은 알고리즘, 지금 듣고있는 정수론 등 - 은 도움이 되는건 사실이다. 대충 다 아는 내용이긴 했지만 혼자서는 절대 하지 않을 revisit을 다시 해보는건 분명히 의미가 있다. General하게, 정수론 같은 파트들은 지식적인 측면보다는 그냥 고민해보는 시간을 갖는게 의미가 있다고 생각한다.

- C++ 구현능력은 오히려 작년만 못하다. 2학기 소개원실이 분기점이 되어서 그런거 같은데, 돌아오려면 아직 멀었다고 생각한다. 2019년 ICPC 때 팀원들이 굉장히 구현을 힘들어해서 아니 멀쩡했던 사람들이 왜이러나 싶었는데, 대충 왜그런지 알거 같기도 하다.

- 그동안 CF rating은 답보를 거듭했는데, 한문제 잡고 푸는 능력은 작년에 비해 나아졌다고 생각한다. `dhdroid` 같은 경우에는 빠른 코딩 실력을 갖추지는 못했지만 어려운 문제를 고민하면 나보다 훨씬 체계적으로 관찰을 쌓아나가는 능력이 있는데, 같이 공부하면서 이런걸 많이 배웠다.

## Preliminary &amp; Round 1
- Preliminary는 30점 절대평가 형식이므로 카페에 앉아서 그냥 대충 앞 몇문제만 내보고 던졌다. 그때 꽤 바쁜 일정들이 있었기 때문에...
- Round 1은 뭔가 항상 R1B를 치게 되는 기분이다. 

## Problem 1 : Minimum Sort
Easy. 바로 떠오르는 Naive 풀이를 그냥 구현하면 된다.

[1, 100] 중 가장 작은걸 뽑고, 맨 앞으로 보낸 다음, [2, 100] 중 가장 작은걸 뽑고.... 이렇게 하면 소모하는 코인 수는 $1/2 + 1/3 + \dots 1/100$ 개 정도이고, 이 값은 6보다 작으므로 이대로 짜서 내면 된다.

## Problem 2 : Matrygons
$K$가 주어질 때, &lt;조건&gt;을 만족하는 distinct한 수열 $x_1, x_2, \dots x_N$ 중 $N$이 최대인 수열을 찾는 문제.

$\sum_{i = 1}^{N} x_i = K$ 여야 하며, $x_1 | x_2 | x_3 | \dots | x_N$ 을 만족해야 한다.

먼저, $K$ 가 $x_1$ 의 배수임을 쉽게 관찰할 수 있다. 또한, $K - x_1$ 은 $x_2$의 배수이고... 이를 반복할 수 있다는 것이 첫번째 관찰이다.

두번째로, $N$이 reasonable하게 작음을 관찰하자. $2x_i \leq x_{i+1}$ 임을 확인할 수 있는데 (배수여야 하고, 같으면 안 되므로) 이를 보면, $N$은 많아야 $\log K$, 30 정도이다.

이 두가지를 이용하면, $f(k, t)$ 를 &quot;현재 $x = t$, $K = k$일 때 $x$ 부터 시작해서 수열을 만들어서 $k$를 만들고자 할 때, 최대의 $N$값&quot; 으로 정의하면 $f(k, t)$ 를 재귀적으로 꽤 빠르게 계산할 수 있다. 설명하기가 굉장히 까다롭지만 코드는 매우 간단하므로 아래 코드를 참고하자.

주의할 점은, 1각형이나 2각형은 없으므로 처음에는 3각형 이상으로 시작해야 함을 주의하자. (이걸로 1틀했다...)

라운드가 끝나고 `dhdroid` 와 discussion했는데 역시 DP황답게 나보다 훨씬 좋은 DP 솔루션을 가져왔다. :fan:

## Problem 3 : Hidden Pancakes
이 문제의 경우, 주어진 문제 상황을 잘 이용하면 &quot;$i$ 번이 $j$번보다 크다/작다&quot; 형태의 정보를 많이 얻을 수 있다. 이러한 정보들이 consistent 하다면, transitivity에 의해 imply되는 정보들을 제외함으로써 Directed tree를 만들 수 있다.

예를 들어, 예제 2는 `1 1 2` 인데, 이를 다음과 같이 볼 수 있다.

- 처음에는 &lt;1&gt; 이 보이는 상황이다.
- 1 다음에 1이 온 시점에서, 보이는게 1개이므로 현재 보이는 것은 &lt;2&gt; 이다. 2번이 1번을 스택에서 쫓아냈으므로, 2번이 1번보다 크다.
- 그다음 2개가 보이므로 &lt;2, 3&gt; 이다. 3번이 2번을 쫓아내지 못했으므로 2번이 3번보다 크다.

이를 트리로 그리면 2번이 루트가 되고, 1번과 3번이 2번의 child node인 트리가 된다. 

같은 방법으로, 예제 1인  `1 2 2 1` 을 보자.

- 처음에는 &lt;1&gt; 이 보이는 상황이다.
- 두번째 시점의 스택은 &lt;1, 2&gt; 이므로 1이 2보다 크다.
- 세번째 시점의 스택은 &lt;1, 3&gt; 인데, 스택에서 3이 2를 쫓아냈으므로 3이 2보다 크다. 또한, 3이 1보다는 작다.
- 마지막 시점에서 &lt;4&gt; 가 모두 쫓아냈으므로 4가 1보다 크다. 

따라서, 4 &gt; 1 &gt; 3 &gt; 2 임을 알 수 있다. 이를 트리로 그리면 한 줄로 쭉 이어진 트리가 된다.

이렇게 트리를 그리고 나면, 이 &quot;트리가 제공하는 partial order&quot;를 깨지 않으면서 $n$개의 팬케익 크기를 정하는 문제가 되는데, 이는 다시 말하면 1, 2, ... $n$을 각 트리 노드에 써넣되 topological order를 깨지 않는 permutation의 개수를 찾는 문제가 된다. 

이는 즉, 현재 주어진 트리의 적법한 topological order의 개수를 세는 문제와 같다. 이 문제는 나름대로 well-known 이므로, 약간 구글링해보면 Tree DP 로 이를 해결하는 방법을 찾을 수 있다. 앳코더에 문제로도 나온 적 있다. [문제 링크](https://atcoder.jp/contests/abc160/tasks/abc160_f)

분명 저 앳코더 문제를 풀때는 생각을 해서 ($O(n \log n)$이긴 했지만 이걸 혼자 찾아냈었는데, 왜인지 모르겠지만 라운드 때는 저런 생각을 전혀 못했다. :( Tree DP는 항상 너무 어려운듯...)

## Round 총평
올해의 첫 메이저 대회인데 나름 재밌었다. 작년이나 재작년 Round 2에 비하면 조금 쉬워진듯한데, 어차피 상대평가니까 큰 의미는 없을 수도...

1000등이라는 커트를 정해놓고 시작하는 라운드다 보니 66점을 받은 시간으로 갈릴수밖에 없는데, 그래도 다행히 막 첫 태스크 빨리푼 시간 이런식으로 갈린 speed중심의 대회는 아니라서 약간 다행이다. 간단한 아이디어 / DP / 트리 DP 라는 첫 3문제의 세팅도 reasonable했다고 보고...

R3도 재밌게 치고 후기정도는 올릴 계획이다 :P</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="competitive-programming" /><summary type="html">Contents</summary></entry><entry><title type="html">5월 2주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21may2/" rel="alternate" type="text/html" title="5월 2주차 Weekly PS" /><published>2021-05-18T00:00:00+09:00</published><updated>2021-05-18T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21may2</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21may2/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

May 10 - May 17, 2021.

## Google Codejam 2021, Round 2
PS를 시작하고 세 번째 Codejam이다. 처음으로 Round 3에 진출하고 Codejam 티셔츠를 얻었다.

순위는 855등으로, 거의 막차를 탔지만 아무튼 티셔츠를 받았다는 사실이 매우 고무적이다 (?) 

나름대로 중요한 대회이므로 별도로 포스팅하기로 한다.

## [Virtual] Google Codejam 2018, Round 2
Codejam을 대비하기 위해 영원한 팽도리들 `dhdroid`, `dlwocks31` 과 함께 2018 Round 2를 virtual로 돌았다. 많은 부족함을 느꼈다. 

### Falling Balls
나름대로 재밌는 Greedy construction 문제이다. 먼저, `/`과 `\`에 대한 조건으로부터, 시작하는 공들이 교차해서 움직이지 못함을 관찰하자. 그러고 나면 결국 왼쪽에서 $k$번째라는 공의 상대적 위치가 잘 보존되므로, 어느 공이 어디로 가야 하는지를 정확하게 안다. 이를 맞추어 construct하기는 어렵지 않다.

### Graceful Chainsaw Jugglers (small)
$O(n^4)$ 의 자명한 DP를 이용하여 small을 긁었고, 어떻게든 이를 줄여보려고 이리저리 많은 고민을 했지만 성공하지 못했다. 

끝나고 `dhdroid` 의 솔루션을 들었는데, DP의 차원을 줄이는 아이디어가 상당히 매력적이다. 뭔가 형태적으로 자주 보이는 DP인 듯 함에도 떠올리지 못한 점은 좀 아쉽다. 풀이에는 $O(n^{8/3})$ 의 놀라운 풀이가 적혀 있으나, $O(n^3)$ 도 문제 해결에 아무런 지장이 없고 훨씬 떠올리기 쉽다.

### Costume Change
중요한 포인트 하나는, 사실 색깔은 충분히 많다는 것이다. 즉, 현재의 &apos;특별하지 않음&apos; 이라는 이슈만 resolve하면 된다.

어떤 $n \times n$ 그리드 상에서, $k$개의 점들이 놓여 있을 때, 이중의 subset을 스도쿠스럽게 뽑는 방법 (각 행에 하나, 각 열에 하나 이하를 유지하는 방법) 은 비교적 well-known이다. 행을 표현하는 정점 $n$개와 열을 표현하는 정점 $n$개를 만들고, $(i, j)$ 에 점이 놓여 있음을 $r_i \to c_j$ 간선으로 표현한 다음, 이들간의 maximum bipartite matching을 찾으면 된다. 이것만 찾는 방법은 좋은 방법이 많이 있지만, 무지성 플로우가 가장 쉽게 구현할수 있다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">5월 1주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21may1/" rel="alternate" type="text/html" title="5월 1주차 Weekly PS" /><published>2021-05-11T00:00:00+09:00</published><updated>2021-05-11T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21may1</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21may1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

Apr 26 - May 09, 2021. 이번 주차는 4월 말 것들도 포함되어 있다.
이전 블로그에서 했었던 weekly PS를 다시 써보려고 한다. 알고리즘 공부도 요새 너무 못한거 같아서...
시험기간 2주씩을 제외하고, 5월에는 아마 1-4주차까지는 있을 예정이다. 

## Google Codejam 2021, Round 1B
1번 Broken clock의 small과 middle, 2번 subtransmutation의 small과 large를 풀고 1101등으로 1B를 통과했다. 올해는 Round 2에는 큰 의미를 두고 있지 않다 (요새 코딩 연습을 너무 못해서..)

놀라운 구현 뇌절이 있을 예정이었기 때문에 미연에 방지하고자 python으로 뛰었고, 그럼에도 불구하고 Broken clock 구현에 1시간 반 정도를 박고 9번을 제출했지만 large를 맞지 못했다는건 좀 충격적이다. 

문제 풀이에 대해 간략히 얘기하자면...

### Broken Clock, Small-Middle
Middle까지는 가능한 시간이 정수 초 만큼이라서 43,200가지밖에 없고, 이 모든 경우를 직접 확인해도 넉넉한 시간이다. 

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Others/%5BGoogle%5D%20Google%20Codejam/2021/Round%201B/A_Broken_Clock.py)

### Subtransmutation, Full
왜 문제 순서가 이런지 잘 모르겠다. 넉넉히 $K$ 한개로 시작해서 만들 수 있는지를 매번 확인해도 시간이 넉넉하고, 이는 $K$부터 1번까지 거꾸로 오면서 Greedy하게 DP를 계산해주면 된다. 말이 조금 이상한데, 꼭 필요한 개수만큼 빼놓고 나머지는 전부 나중에 쓰일수도 있으니 작은걸로 분해해준다고 생각하면 간단하다. 말보다 코드가 훨씬 쉬운 문제.

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Others/%5BGoogle%5D%20Google%20Codejam/2021/Round%201B/B_Subtransmutation.py)

## Problems
### BOJ 20191 줄임말 (KOI 2020)
난이도 : Gold 3 (BOJ)

문자열 S와 T가 주어질 때, T를 몇 번 concat해야 $T^n$ (concat) 이 $S$를 subseqeunce로 포함하는지 묻는 문제. S의 각 글자에 대해서, 이 글자가 T의 몇번째에 대응될 수 있는지 미리 모두 확인한다. Greedy하게, 내 이전 글자들보다 뒤에 있기만 하다면 대응할 수 있는 위치 중 최대한 앞에 대응해야 무조건 이득이 된다. 그러나 더이상 대응 가능한 위치가 없다면, 새로운 T를 하나 추가해서, 가능한 가장 앞에 대응해야 한다. 이를 이용하면 전처리 $O(S + T)$ 를 수행함으로써, $S$의 각 글자에 대해 $\log T$ 시간에 위치를 찾아줄 수 있으므로 $O(S \log T)$ 시간에 해결된다.

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Olympiads/%5BKOI%5D%20Korean%20Olympiad%20of%20Informatics/KOI%202020/%EA%B3%A0%EB%93%B11-%EC%A4%84%EC%9E%84%EB%A7%90.cpp)

### BOJ 3006 터보소트 (COCI 2007)
난이도 : Platinum 4 (BOJ)

세그먼트 트리에 각 element의 위치를 저장하고, segment tree를 이용하여 다이나믹하게 뭔가를 갱신하는 좋은 연습문제지만 기본적인 개념을 파악하고 나면 어렵지 않다. Segtree를 이용하면 구간 $(a, b)$ 의 1의 개수 (남아 있는 원소의 개수) 를 쉽게 셀 수 있다. 

코드 : [링크](https://github.com/gratus907/Gratus_PS/blob/master/Contests/Olympiads/%5BCOCI%5D%20Croatian%20Open%20Competition%20in%20Informatics/COCI%202007-2008/2_TURBO.cpp)</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">Iterative methods : Jacobi, GS, SOR</title><link href="http://localhost:4000/numerical-analysis/im-1/" rel="alternate" type="text/html" title="Iterative methods : Jacobi, GS, SOR" /><published>2021-04-28T00:00:00+09:00</published><updated>2021-04-28T00:00:00+09:00</updated><id>http://localhost:4000/numerical-analysis/im-1</id><content type="html" xml:base="http://localhost:4000/numerical-analysis/im-1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## Iterative methods
수치선형대수 수업에서 배운 내용을 조금 정리해 보려고 한다. 구체적으로, 행렬 $A$와 벡터 $b$에 대해, $Ax = b$를 푸는 여러 방법들 중 iterative methods를 몇 포스팅에 걸쳐 다루어 본다.

우선, 행렬 $A$ 의 inverse를 구하기가 쉽다면 $x = A^{-1} b$ 를 계산하면 간단하다. 당연히 이상한 방법을 필요로 하는 이유는 이 inverse를 구하기가 어렵기 때문이다. 어렵다는 것은 두 가지 의미가 있는데...
1. Numerically unstable 해서 수치 오차가 우려되는 경우
2. Complexity 관점에서, 계산 시간이 큰 경우
두 경우 모두 &quot;계산이 어렵다&quot; 라는 말로 퉁치기로 하자. 

한번에 정확히 $x = A^{-1} b$를 구하는 대신, 임의의 $x_0$에서 시작해서, $x_i$들의 sequence가 $x$로 수렴하게 하려고 한다. 이때 $x_{i+1}$ 은 $x_i$ 및 그 이전 항들을 이용하여 귀납적으로 연산할 수 있어야 하고, 각 step은 계산이 쉬워야 할 것이다.

어떤 행렬 $Q$에 대해, $A = Q - (Q - A)$ 로 쓰면, $Ax = b$의 해 $x$는 $Qx = (Q - A) x + b$ 를 만족해야 할 것이다. 따라서, $Qx_k = (Q - A)x_{k-1} + b$ 를 우리의 iteration으로 쓸 것이다. 

또한, $A = L + D + U$ 를, $L$을 diagonal 아래의 (strictly) lower triangular한 행렬로, $U$를 그 반대의 upper triangluar 행렬로, $D$를 $A$의 diagonal로 잡기로 한다.

이번 포스팅에서는 가급적 증명들을 생략하고 method들에 대해서만 간략히 살펴보고, 증명은 나중에 여력이 되면 쓸 예정이다.

### Convergence
위 iteration이 올바른 답을 낸다는 사실은 상당히 nontrivial하다. 우선 $x_k = Q^{-1}((Q-A)x_{k-1} + b) = f(x_{k-1})$ 이라고 쓰면, 우리의 목표는 $f$의 fixed point를 찾는 것임을 알 수 있다. 이 iteration은 사실 이러한 $f$에 대해 FPI (Fixed Point Iteration) 을 수행하는 과정으로 이해할 수 있다. FPI가 언제 어떻게 수렴하는지를 이해하는 것은 쉽지 않은데, $f$가 Lipschitz continuous w/ $L &lt; 1$ 임을 보이거나, 훨씬 더 어려운 수학적 내용들을 공부해야 한다. 작년에 최적화 이론 수업에서 이러한 수렴 정리들을 배웠는데, Averaged operator에 대한 수렴정리가 상당히 어렵지만 재밌었던 기억이 있다. 직접 링크를 거는 것이 적절한지 모르겠는데, Ernest K. Ryu 교수님의 최적화 이론 수업 자료가 웹사이트에 공개되어 있으므로 찾아보면 (해석개론 정도의 해석학 지식 배경 위에서) 이해할 수 있을 것 같다. (**Monotone Operators and Base Splitting Schemes** 의 **Theorem 1** 부분을 확인하면 된다)

## Richardson method
Richardson method는 $Q = \frac{1}{w}I$ 를 쓰는 방법이다. 즉, $x_k = (I - wA) x_{k-1} + wb$ 를 생각할 것이다. $I - wA$를 한번 구한 다음부터는 계속 행렬-벡터 곱셈만 반복해도 되므로, 각 step이 $O(n^2)$이고, $I - wA$를 한번 구하는데 $O(n^2)$ 이 들게 되므로 iteration 횟수 $m$에 대해 $O(n^2 m)$ 시간에 연산할 수 있다. 

### Convergence
$x_* - x_i$ 를 직접 계산하면, $(I - wA)x_* + wb - (I - wA)x_{i-1} - wb$ 가 되고, 이를 반복적으로 적용하면 다음 식을 얻는다.
$$x_* - x_k = (I - wA)^k (x_* - x_0)$$
편의상, $x_0$ 을 영벡터로 놓으면, 우리는 다음과 같은 식을 얻는다.
$$\norm{x_* - x_k} = \norm{(I - wA)^k x_*} \leq \norm{I - wA}^k \norm{x_*}$$
이제 $\norm{I - wA}$ 부분을 evaluate 해야 함을 알 수 있고, 선형대수의 지식을 잘 써서 계산해 보면 수렴 속도는 $\lambda_n / \lambda_1$, 즉 가장 큰 eigenvalue와 가장 작은 eigenvalue의 비에 의존함을 파악할 수 있다. 

## Jacobi method
## Gauss-Seidel Method
## SOR (Successive OverRelaxation)</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="numerical-analysis" /><category term="algorithms" /><category term="mathematics" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 1학기 중간점검</title><link href="http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring/" rel="alternate" type="text/html" title="2021 1학기 중간점검" /><published>2021-04-23T00:00:00+09:00</published><updated>2021-04-23T00:00:00+09:00</updated><id>http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring</id><content type="html" xml:base="http://localhost:4000/retrospects-and-plans/halfway-through-2021-spring/">블로그 포스팅 오랜만이네요. 기록상 3월 19일에 폴라드-로 알고리즘에 대해 쓴 게 마지막이니, 대략 한달 만입니다. 과제랑 중간고사에 치여서 나름대로 바쁜 삶을 살고 있습니다.

잠깐 이번학기 중간점검 하는 느낌으로, 쭉 적어보려고 합니다.

## Major Updates
- 수리과학부 복수전공을 (원래도 계획하고 있었지만) 시작하게 되었습니다. 원래는 부전공 중이었는데 조금더 제대로 수학공부를 해보고 싶기도 했고 원래 계획은 복전이었으니까요. 다만 (여기에 적어도 되는지 모를만한 여러 가지로 인해) 복전이 실제로 가능할지는 조금 의문이었는데 잘 해결되었습니다. 별일없으면 초과학기 한 학기와, 인턴십 등으로 쓸 휴학 한 학기를 이용하여 5학년까지 다니고 2023년 2월에 졸업할 예정입니다.
- Computer Theory Lab에서 수행했던 UROP (Undergraduate Research Oppertunity Program) 가 마무리되었습니다. 원래는 작년 8월 - 올해 2월이어야 했지만 어쩌다보니 좋은 기회가 생겨서 4월까지 이어졌습니다. 가능하다면 졸업후 이 연구실로 가고 싶다는 생각을 하고 있습니다. 
- 컴퓨터공학부 보안 분야 학술 동아리 Guardian의 부회장을 맡게 되었습니다. 보안 분야로 진로를 잡았던 것은 아니지만 암호학 등에는 계속 조금씩 관심이 있었는데, 부끄럽지 않을만큼의 공부를 해야겠다는 생각이 듭니다. 솔직히 많이 부족한데 맡을사람이 없다보니...

## Classes
이번학기에는 이렇게 수강하고 있습니다. (학과, 학년)
- 하드웨어 시스템 설계 (컴퓨터공학부, 3) : 서류상 3학년 과목이지만 왜인지 모르겠습니다. 원래는 메모리 구조 등을 배우는 과목이었다고 하는데, 학과 전체가 AI에 잡아먹히는 과정에서 Verilog로 행렬 곱셈을 빠르게 수행하는 가속기를 FPGA에다 올려서 CNN을 빨리 돌리는...뭐 아무튼 그런 주제를 다루는 수업이 되었습니다. Implementation specific한 하드웨어라던가, Neural network에 특화한 칩 설계 같은건 하드웨어 분야 에서 매우 핫한 주제라고 알고 있지만 저는 하드웨어 분야에 소질이 없기 때문에 사실 잘 모르겠습니다. Verilog 프로그래밍은 매우 못 하지만 훌륭한 팀원이 있어 잘 따라가는 중입니다. 
- 실변수함수론 (수리과학부, 4) : 해석학 정통 테크의 과목입니다. 아래 실해석학이랑 같이 듣고 있어서 조금은 편하게 공부하고 있습니다. Measure theory, $L^p$ space, 르벡 적분 등을 배웠습니다.
- 실해석학 (수리과학부, G1) : 실변수함수론보다 한단계 높은 과목으로 배우는 내용이 조금 어렵습니다. 다만 실제로 선수관계라기보다는 같은 과목의 학부 4 / 대학원 1 버전이라, 그냥 저냥 들을 만 합니다. 워낙 유명하고 평이 좋은 과목이라 학부생들도 많이 듣습니다. 실변수함수론 내용을 업글해서 배우는 느낌이라 같이 따라가기 좋고... 엄청 어렵습니다. 해석학 베이스가 없다는걸 많이 느낍니다.
- 정수론 (수리과학부, 2) : 정수론 수업은 진도가 상당히 빠르고 많은 내용을 다루며, 교수님께서 원래 Cryptography를 전공하셨기 때문에 저한테는 매우 흥미로운 주제들이 많았습니다. Computational한 주제들이 많아서 재밌습니다.
- 수치선형대수 (수리과학부, 3) : 선형대수의 여러 계산들을 수치적으로 하는 방법을 배웁니다. 뒤에는 뭔가 새로운 내용을 배우는거 같은데 잘 모르겠고... QR분해, SVD 등 다양한 선형대수의 지식을 Computational하게 접근하는 과목입니다. MATLAB 프로그래밍을 익히는게 조금 어색합니다.
- 이산수학 (컴퓨터공학부, 1) : ㅋㅋㅋㅋ 자구 알골 듣고 이산수학 역수강 ㅋㅋㅋㅋ 테크가 꼬여서 4학년에 이산수학을 듣고 있는데, 컴공과 CS테크를 타고 수학과 과목을 20학점 정도 들은 뒤라 그냥 편안하게 가고 있습니다.
  
## Extracurricular
- Guardian에서 C언어 기초 스터디 자료를 작성하게 되었습니다.
- Codejam 은 Round 1A를 일정상 걸렀는데, 1B에서 올라가면 되니까 별로 부담은 없긴합니다
- PS는 거의 못하고 있는데, 뭐 조금씩은 다시 해보려고 합니다. 가능하면 여기에 포스팅도 조금 자주 하구요... 난이도 있는 문제들 위주로 포스팅할 계획입니다.

## For fun 
- 온라인 체스를 꽤 재밌게 두고 있습니다. Lichess랑 Chess.com 둘다 가끔 하는데 레이팅은 1700 / 1400 정도. 그냥저냥 하는 정도인거 같습니다. 언젠가 여기에 체스 관련 포스팅 할 수도?</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="retrospects-and-plans" /><summary type="html">블로그 포스팅 오랜만이네요. 기록상 3월 19일에 폴라드-로 알고리즘에 대해 쓴 게 마지막이니, 대략 한달 만입니다. 과제랑 중간고사에 치여서 나름대로 바쁜 삶을 살고 있습니다.</summary></entry><entry><title type="html">폴라드-로 소인수분해 알고리즘</title><link href="http://localhost:4000/algorithms/Pollards-Rho/" rel="alternate" type="text/html" title="폴라드-로 소인수분해 알고리즘" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/Pollards-Rho</id><content type="html" xml:base="http://localhost:4000/algorithms/Pollards-Rho/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## Motivation
소인수분해는 매우 어려운 과정이다. 실제로 소인수분해는 (입력 비트 수에 대해) 다항 시간에 결정론적으로 풀 수 있는 방법이 알려져 있지 않다.

그러나, 약간의 랜덤성 (확률에 대한 의존) 을 허용한다면 상당히 clever한 알고리즘을 통해 빠르게 소인수분해를 할 수 있는데, 이 방법이 바로 Pollard&apos;s Rho($\rho$) 알고리즘이다.

### 생일 문제 (Birthday Problem)
고등학교 확/통 교과서에도 실려있는 유명한 문제인데, 다음 문제에 답해 보자.
- 23명의 사람이 한 방에 모여 있다. 이 중, 적어도 한 쌍 이상이 생일이 겹칠 확률은 얼마인가?
  
계산을 직접 해 본다면, 별로 직관적이지 못한 결론을 얻는다. 대략 50%가 넘어가는데, 365개의 생일 중 23명이 골랐을 뿐인데 이렇게 높은 확률이라는 것이 비직관적이기 때문에 이 결과를 Birthday Paradox라고도 부른다.

이 문제의 핵심은, **마구 랜덤하게 뽑으면 생각보다 많이 겹친다** 라는 정보이다. 이를 이용하여, 어떻게 소인수분해를 할 수 있는지 알아보고자 한다.

구체적으로, $\sqrt{n}$ 정도의 사람이 필요하다는 사실을 기억하자. 즉, $n$개 중 $k$개를 뽑아서, 겹치는 쌍을 만들고자 한다면, $k = O(\sqrt{n})$ 정도 뽑으면 겹치는 쌍을 기대할 수 있다. 증명은 생략.

### 가정 
폴라드-로 알고리즘이 잘 작동하기 위해서는, 큰 수 $m$을 소인수분해하되, $m$의 가장 작은 소인수 $p$가 작아야 한다. 예를 들어, RSA에서 쓰는 좋은 N - 즉, 큰 소수 2개를 곱한 수에서는 그 효율이 현저히 낮다. 100자리 소수를 2개 곱해서 얻은 200자리 합성수보다는, 20자리 소수 10개를 곱해서 얻은 수를 잘 소인수분해하는 알고리즘임을 의미한다. 

## Algorithm
$k$개의 정수 $u_1, u_2, \dots u_k$ 를 랜덤하게 선택하자. 이때, 생일 문제에 의해, $u_i \equiv u_j \mod p$ 인 $i, j$를 얻을 가능성이 상당히 높다. 그런데, 이는 다시 말하면 $u_i - u_j$가 (일반성을 잃지 않고 양수라고 하자) $m$과 $p$를 공약수로 가질 가능성이 상당히 높다는 뜻이다. 우리는 두 수의 gcd를 입력 비트 수에 대한 다항 시간에 찾는 유클리드 알고리즘을 잘 알고 있으므로, $m$의 어떤 소인수를 빠르게 찾을 수 있다는 의미가 된다. 다시 말해, $\binom{k}{2}$개의 $u_i - u_j$들과 $m$의 gcd를 확인함으로서 $m$의 어떤 약수를 얻을 확률이 상당히 높다는 뜻이다.

그러나, $O(k^2)$ 개의 조합을 모두 검토하기는 너무 느리다. 폴라드-로 아이디어는 이 과정을 줄이는 것인데, $u_i$를 랜덤하게 뽑는 대신 $u_{i+1} = u_i^2 + 1$ 을 사용하는 것이다. 이 다항식 $f(x) = x^2 + 1$ 은 사실 어떤 다항식이든 크게 상관은 없으나, mod $p$에 대한 랜덤성을 해치지 않아야 하고, 계산이 너무 오래 걸리지 않아야 한다. 일반적으로 저렇게 생긴 다항식이 잘 작동함이 알려져 있으나 $x^2 + x + 1$ 같은걸 쓴다고 큰 문제는 없고... 다만 1차식을 쓰면 안 된다는 사실도 잘 알려져 있다. 

이런식으로 결정론적으로 계산하는 것의 장점은, $u_i$ 의 수열이 주기성을 갖게 된다. 우리가 어떤 주기성을 갖는 수열 $u_i$에서 주기를 찾고자 할 때는 Tortoise and Hare 라는 좋은 방법을 쓸 수 있는데, 이 방법은 다음과 같다.

수열의 주기를 $r$이라고 할 때, $s \equiv t \mod r \Rightarrow u_s = u_t$ 가 된다. 따라서, $s$를 적당히 큰 (주기성을 보이는) $r$의 배수로 잡고, $t = 2s$로 잡으면 항상 $u_s \equiv u_{2s}$ 이다. 따라서, 우리는 $k$를 하나씩 늘리면서 $u_{2k} - u_k$ 만 확인하여도 반드시 주기를 놓치지 않음이 보장되며, 이때 주기성을 가지는 첫번째 $r$의 배수가 대략 $O(\sqrt{p})$ 정도 스케일이기 때문에 $k = O(\sqrt p)$ 정도 확인하면 그 안에 gcd$(u_{2k} - u_k, m)$ 가 1이 아닌 $k$를 기대할 수 있다.

### 예시
Niven 의 정수론 책에 수록된 예시는 다음과 같다.

$m = 36,287$, $f(x) = x^2 + 1 \mod m$, $u_0 = 1$일 때, $u$의 수열을 계산하면...  
$1, 2, 5, 26, 677, 22886, 2439, 33941, 24380, 3341, 22173, 25652, 26685, 29425, 22806$... 이다. 이때, 각 $k$에 대해 gcd$(u_{2k} - u_k, m)$ 를 계산하면, $u_{14} - u_7$에서 gcd$(u_{14} - u_7, m) = 131$ 이다. 131은 $m$의 약수이다.

### 구현
위 알고리즘을 그대로 코드로 옮기면 된다.
- 단, $u$ 수열을 미리 구해놓고 Tortoise-Hare를 돌리는 것은 어디까지 구해야 할지 모르는 상황에서는 별로 적절하지 않다. $x^2 + 1$ 은 구하기 쉬운 다항식이므로, 매 스텝마다 $y$는 두 스텝씩, $x$는 한 스텝씩 나간다고 생각하면서 진행시키자.
- $u_0$는 랜덤하게 뽑았는데, 별로 상관은 없다. 
- `is_prime` 부분은 일반적인 소수 판정 함수를 쓰면 된다. 보통은 밀러-라빈 판정법을 많이 쓴다 (그냥 판정하면 느리니까).

```cpp
inline int64_t mulmod(int64_t x, int64_t y, int64_t m)
{
    return ((__int128)x * y % m);
}
int32_t PollardRho(int32_t n)
{
    if (n==1) return n;
    if (n % 2 == 0) return 2;

    int32_t x = (rand()%(n-2))+1;
    int32_t y = x;
    int32_t c = 1;
    int32_t d = 1;
    while (1)
    {
        x = (mulmod(x, x, n) + c + n)%n;

        y = (mulmod(y, y, n) + c + n)%n;
        y = (mulmod(y, y, n) + c + n)%n;

        d = __gcd(abs(x-y), n);
        if (d == 1) continue;
        if (is_prime(d))
            return d;
        else return PollardRho(d);
    }
}
```

## 시간 복잡도
앞서 설명한 바와 같이, Birthday Paradox에 의해 실제로 구해야 하는 $u$의 값은 $O(\sqrt p)$개이다. $n$에 대해서는 $p \leq \sqrt{n}$ 임을 가정하면 (소수가 아님은 밀러라빈 등으로 확인하자) $O(n^{1/4})$ 알고리즘이라고 할 수 있다. 이는 다항식 $x^2 + 1$ 이 진짜 랜덤한 수들을 준다는 가정 하에 이루어진 계산인데, 실제로는 당연히 뭔가 더 복잡하고 끔찍한 분석이 필요하다. 이쪽은 잘 모르기도 하니 일단은 넘어가기로 하자.

당연히, 매우 큰 수를 다룰 때는 곱셈이나 모듈러 등이 유의미하게 오래 걸린다. 이 경우 적절하게 시간 복잡도에도 이런 항들을 곱해야 할 것이다. 우선은 64비트 (곱셈이 $O(1)$에 수행) 가정 하에서의 복잡도가 위와 같다고 알아두면 된다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="number-theory" /><category term="algorithms" /><summary type="html">Contents</summary></entry><entry><title type="html">Google Hash Code 2021 : Team Little Piplup 준비과정</title><link href="http://localhost:4000/Hashcode-2021-prep/" rel="alternate" type="text/html" title="Google Hash Code 2021 : Team Little Piplup 준비과정" /><published>2021-02-26T00:00:00+09:00</published><updated>2021-02-26T00:00:00+09:00</updated><id>http://localhost:4000/Hashcode-2021-prep</id><content type="html" xml:base="http://localhost:4000/Hashcode-2021-prep/">이 글은 올해 해시코드를 준비하는 과정 등에 대한 이야기이고, 해시코드 2021에 Specific한 (문제 등) 은 다음 글([링크](/Hashcode-2021-prelim/)에서 다룹니다.

내년에 해시코드를 준비하려는 분들이 읽었을때 재밌게 쓰고 싶었는데 어떤지 모르겠네요. :( 

&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## Google Hashcode 
Google Hashcode는 구글에서 개최하는 Coding competition 중 최적화와 휴리스틱을 겨루는 대회입니다. NP한 문제가 주어지고, 이 문제에 대해 좋은 휴리스틱과 적절한 알고리즘적 최적화를 통해 주어진 데이터셋에서 좋은 점수를 받는 경쟁인데, 모든 데이터셋이 공개되기 때문에 데이터셋의 성질을 잘 활용한다거나 하는, Data science틱한 면이 조금 있다고도 할 수 있겠습니다.

이런 형태의 대회는 기존의 PS와는 또 다르지만, 필요한 스킬셋은 어느정도 비슷하고, 최상위권 레벨에서는 기존 PS 스러운 테크닉들이 유의미합니다. PS 실력과 매우 높은 상관관계가 있지만, Hashcode 형 대회에 특히 강한 팀들도 있습니다. 

문제가 상당히 Real-world 스럽게 출제되며, 실제로 Google Loon 같은 구글의 product와 깊은 연관이 있습니다. 문제를 풀다 보면 뭔가 진짜 실제로 유의미한 문제를 해결하는 느낌을 받기도 합니다. 

## Team Little Piplup 
이 팀은 2019년도 ICPC를 기점으로 저와 `Coffeetea`, `DHDroid` 로 출발했습니다. 이후 두 사람이 병역특례를 위해 휴학을 하게 되었는데, 휴학생은 ICPC 본선 출전권이 없기 때문에 제가 다른 팀을 찾게 되었습니다. (결과적으로, 서울대에서 본선에 진출하는 난이도를 생각해 보면 별로 그럴 필요가 없었다는 생각이 들기도 합니다만...) 2020년부터 그 자리는 병특중이었고 저랑 계속 PS를 같이 공부했던 `Dlwocks31` 이 들어가게 되었습니다.

`Dlwocks31`이 들어간 시점의 팀명은 `Army Piplup`으로 개칭되었고, 2020 ICPC 예선에서 11등을 거두는 놀라운 실력을 보여주었습니다. 코드포스 레이팅 (Max)를 기준으로 dlwocks는 2200++, 저는 2100, Coffeetea와 DHDroid는 1900인데 dlwocks31은 몰라도 저는 거품레이팅이었기 때문에 거품이 꺼진 지금은 1900 정도, 잘쳐주면 퍼플 중간쯤의 CP 실력을 가지고 있는 것으로 보입니다.

- `Gratus907` : 수학적인 문제에 비교적 강하고, 말리지 않을때까지는 구현이 빠르지만 말리면 한없이 말리는 경향이 있습니다.
- `Dlwocks31` : 가장 C++ 구현을 깔끔하게 잘 하고, 구현에서 덜 말리는 편입니다.
- `DHDroid` : Constructive한 문제에 매우 강하고, 관찰을 정당화 (증명) 하는 능력이 뛰어납니다. 
- `Coffeetea` : 그리디하거나 휴리스틱한 관찰, 대략적인 경향성의 파악에 강합니다. 뭔가 문제에 빙의하는 특성이 있어서 글쓸때 Coffeetea의 표현을 많이 빌리게 됩니다 :) 
  
## Preperation
Hashcode 대회를 준비하기 위해서 올해는 많은 노력을 기울이지 못했습니다. 작년에는 비교적 많은 노력을 했는데, 여러가지 교훈을 얻었습니다. 작년 대회 후기는 제 티스토리 블로그에서([링크](https://gratus907.com/92)) 볼 수 있습니다.

- 문제의 구현량이 상당히 많아서, 구현에서 말리면 상당히 힘듭니다. 기본적으로 dlwocks31이 구현이 가장 덜 말리니까 전체적인 구현을 맡되, 필요하다면 언제든 구현에 저나 다른 팀원들이 참여해야 합니다.
- Parameter Tuning이 많은 도움이 됩니다. 파인 튜닝을 자동화하는 코드를 미리 준비했는데, 이를 위해서는 신속하고 정확하게 채점을 받고 싶습니다.
  - 채점을 웹 환경에서 제출하는 데 많은 시간이 걸립니다. 이는 상당히 불편하기 때문에, 경우에 따라 **채점기를 짜는** 것이 의미가 있습니다. 
  - **채점기를 작성하는** 것의 단점은 당연하게도 4시간이라는 짧은 대회시간에서 한명이 빠져서 1시간정도를 채점기에 써야 한다는 점입니다.
  - **그럼에도 불구하고**, 채점기 작성을 통해 문제 상황을 좀더 깊이 이해할 수 있다는 점, 경우에 따라 채점기의 시뮬레이션 같은 부분들은 본 솔루션에서도 응용할 수 있다는 점이 있어서 고려할만 합니다.
- 결국 상위권(5-10%)에서 최상위권(1%)을 결정하는 것은, (작년에는) 엔드스펙급 알고리즘 최적화였습니다. 구체적으로는, 특정 데이터의 경우 적절한 환원을 통해 3-SAT 같은 문제로 바꿀 수 있었고, 이를 적절한 3SAT 솔버에 먹여서 답을 구한다거나, greedy 대신 MCMF를 쓴다던가 하는 솔루션들이 최상위권을 겨루었습니다. 다시 같은 최상위권 내에서는 Parameter Tuning이 세부등수를 결정합니다. 
  - 그래서, 이번에는 상용 NP-Complete Solver들을 준비했습니다. 이런쪽에 비교적 제가 조금더 해본게 많기 때문에, 이것저것 찾아 모으고, 제 최대의 목표는 **이거 사실 3SAT인데** 를 찾는 것이라고 스스로 생각했습니다. (결국 틀렸습니다)
  - Glucose SAT Solver, Concorde TSP Solver, Google ORTools(LP, Flow, IP) 정도는 세팅되어 있었습니다.
- 생각보다 높은 Computation power가 필요한 경우가 있습니다. 팀원 전원이 i7급 이상의 노트북을 사용했으며 필요할때 사용할 수 있는 i7급 데스크탑 2대가 세팅되었습니다. 카카오 클라우드, 네이버 클라우드 등이 준비되어있었던 다른 팀에 비하면 부족할지도 모르지만 저희가 확보할 수 있는 컴퓨팅 파워는 나쁘지 않았고, 결국 그 무엇도 필요 없었습니다.

### 전략 
1. 첫 1시간 정도, 제가 Grader를 짜기로 했습니다.
2. 그동안, DHDroid와 Coffeetea는 데이터를 분석하기로 했습니다. 예를 들어 그래프 데이터가 주어진다면, 몇개의 허브가 존재하는 데이터인지, Degree-bounded인지 등의 정보가 있으면 일반적인 그래프에서는 상상도 못할 것들이 가능하기 때문에 이런 정보는 정말 필수적입니다. 경우에 따라 이 두명이 어느정도의 그리디한 솔루션을 제공해 줄 것입니다. Grader 작성은 그냥 깡 시뮬이기 때문에, 이 두명의 논의를 제가 어느정도 들으면서 짤 수 있습니다,
3. Dlwocks31이 이때 튜닝가능한 제네릭 솔루션을 작성하기로 했습니다. 이 코드는 나중에 같이 돌아가면서 고치고 튜닝해야 하므로, 비교적 읽기 쉽게 짜야 하고, IO같은 (다른 사람들이 몰라도 되는) 부분들을 분리하기로 했습니다. 
4. 이후 2-3시간 동안, 네명이 같이 솔루션을 잡으면서 알고리즘 개선과 파라미터 튜닝을 반복하며 계속 제출하는 방식입니다.

전반적으로 첫 1시간동안 저랑 dlwocks31의 코딩실력에 조금 의존하는 감이 있습니다만, 저희가 할 수 있는 최선이었고 지난 몇년치 예선을 풀어봤을 때는 말이 되는 전략이었습니다. 이정도 복잡도의 구현은 저희 둘은 어떻게든 가능하긴 했었고, 평소 PS때와는 달리 1초의 Strict time limit이 없으므로 set, map 같은 것들을 마구 남용하며 짜도 되긴 합니다. 

이 전략은 올해 해시코드에서 한계에 부딪히게 됩니다.

### 작년 팀연습들
몇몇 해시코드 예선 문제를 작년에 같이 풀어보았었습니다. 그때 위 1-4 전략도 정립했는데, 몇가지 전략적인 튜닝도 있었습니다.
1. 문제의 구현 복잡도가 높다면, 체커를 짜는 것은 별로 바람직하지 못합니다. 이건 2016 Qual라운드의 DRONE이라는 문제에서 느꼈습니다. 해시코드를 준비한다면 꼭 풀어보길 바랍니다.  
   반면, 구현 복잡도는 적절한데 Simulated annealing같은걸 박을수있는 문제라면 무조건 체커를 짜야 합니다.
2. 어떤 문제는, 아예 독립적인 두개이상의 알고리즘을 요구한다는 사실을 알게 되었습니다. 예를 들어 그래프 문제에서 어떤 데이터는 Deg-bounded고 어떤 데이터는 다섯개의 허브와 9995개의 가지정점으로 구성되어 있다면, 두 문제는 사실 아예 다른 문제이기 때문입니다. 이경우 구현페이즈가 n배 힘들어지는데, 이를 빠르게 파악해야 하므로 두명이 데이터를 생각보다 많이 분석해야 한다는 결론을 내렸습니다. 구현이 아닌 데이터 분석에 2명을 배정한 이유가 여기 있습니다.
3. 이를 위해 dlwocks31이 구현을 정말 **최대한 제네릭하게** 짜야 함을 깨달았습니다.

### 팀연습 : 2020 Hashcode WF 
가장 좋은 해시코드 연습셋은 해시코드기 때문에, 작년 해시코드 월파를 같이 돌았습니다. 정말 충격적인 난이도의 문제로 인해 저희 전략의 한계가 느껴졌습니다.

대충 얘기하자면 정말 빡센 구현 문제였고, 대충 시뮬레이션만 성공해도 월파 중간쯤의 점수가 나오는 미친 셋이었습니다. 위 전략이 다음과 같이 실패했습니다.
1. 팀연습때는 온라인 채점을 받을 수 없으므로, 한명을 지정해서 한명이 미리 체커를 짜 옵니다. 제가 체커를 짜 왔는데, 집에서 혼자 체커를 짜는데 일단 1시간보다 훨씬 오래걸렸고, 정확성도 별로 보장되지 않았습니다. 그래도 그럭저럭 말이 되는 것 같았는데 뭐 이부분은 잘 모르겠습니다. 중요한 것은 체커를 1시간 내로 짜지 못했다는 것입니다.
2. 데이터를 분석하고 그리디를 떠올려야 하는데, 그리디하게 뭘 할 수 있을지도 난해했습니다. 지나치게 구현난이도가 높아서, Coffeetea의 장점을 살린 아이디어들이 쏟아졌지만 구현가능해 보이는 솔루션이 없었습니다.
3. dlwocks31이 1시간은커녕 2-3시간에 걸쳐서도 가능한 C++ 코드를 작성하지 못했습니다. 이건 blame할 일은 절대 아닌게, 다른 3명이 잡았으면 하루 종일 짰어도 못 짰을 것입니다.
4. 솔루션이 없으므로 튜닝할 파라미터도 개선할 알고리즘도 코드를 작성할수가 없습니다.

2020 WF를 풀면서, 저희 전략이 dlwocks31의 구현력에 얼마나 의존하는지 깨닫게 되었습니다. 경우에 따라 체커를 던지더라도 이 구현은 피할 수 없고, 이 구현에서 말리면 0점으로 대회를 마무리하는 참사가 벌어지기 때문입니다.

필요하다면 구현을 나누어야 한다는 직감이 들었으므로, 처음으로 이런 대회 중에도 Git을 이용하기로 했습니다. 최대한 같은 파일을 동시에 2명이 만지는 일을 피하면서, 필요하다면 파일을 많이 늘려서라도 코드를 적절히 공유할 필요가 있었기 때문입니다. 여러 파일로 나누어 구현한 다음 합치는 방법을 포함해서, 부족한 구현력을 전략으로 메우기 위한 많은 시도가 있었습니다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="competition" /><summary type="html">이 글은 올해 해시코드를 준비하는 과정 등에 대한 이야기이고, 해시코드 2021에 Specific한 (문제 등) 은 다음 글(링크에서 다룹니다.</summary></entry><entry><title type="html">Google Hash Code 2021 : Global #211 (2%) 후기</title><link href="http://localhost:4000/Hashcode-2021-prelim/" rel="alternate" type="text/html" title="Google Hash Code 2021 : Global #211 (2%) 후기" /><published>2021-02-26T00:00:00+09:00</published><updated>2021-02-26T00:00:00+09:00</updated><id>http://localhost:4000/Hashcode-2021-prelim</id><content type="html" xml:base="http://localhost:4000/Hashcode-2021-prelim/">이 글은 올해 해시코드 대회 과정에 대한 후기이고, 준비 과정은 앞 글([링크](/Hashcode-2021-prep/))에 있습니다.

&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## 결과 
```
A - An Example       2,000
B - By the Ocean     4,566,842
C - Checkmate        1,300,355
D - Daily Commute    1,574,469
E - Etoile           716,984
F - Forever Jammed   1,417,038
TOTAL SCORE          9,577,688
```
**Global rank #211 / 9,000+ teams** 

**Korea rank #11**

## 문제 설명 
- **교차로**, **도로**, **차량** 들이 주어집니다. 
- **도로** 들은 그래프에서 **방향 있는 간선** 입니다. **교차로** 에서 **교차로** 로 이어져 있고, **길이** 가 있습니다. 
- **교차로** 는 그래프에서 **정점** 입니다. 교차로에는 **신호등** 이 있는데, 특정 시점(초)에는 **정확히 1개의 incoming edge** 에만 초록불이 켜져 있어야 합니다.
- **Incoming edge** 에 초록불이 들어와 있다면, 그 교차로의 그 도로에 서 있는 차량들 중 1초에 1대씩만 그 교차로에서 출발하는 간선들 중 하나로 이동할 수 있습니다. 
- **차량** 들은 가고 싶은 경로가 주어집니다. 경로는 간선들의 순서로 주어지고, 시작점은 첫 간선의 ending intersection에 서 있는 것으로 주어집니다. 차량들은 1초에 1씩 이동하는데, **교차로**를 만나면 내가 지금 서 있는 도로의 초록불이 켜질때까지 기다립니다. 

예를 들어, 교차로 A에서 B로, B에서 C로, A에서 C로, C에서 D로 도로가 있다고 가정해 봅시다. 여기서 차량 1이 A-B에서 출발, 차량 2가 A-C에서 출발한다고 생각해 봅시다. 차량 1이 B 앞에 서 있을 때, B교차로는 (A-B) 도로 외의 다른 incoming 도로가 없으므로 여기에 초록불을 켜 주면 됩니다. 이러면 교차로를 바로 지나쳐서 B-C 도로로 올라탈 수 있습니다. 

위 예시에서 C 교차로는 B-C 간선과 A-C 간선 두개의 endpoint입니다. 이때, B-C 간선에 초록불이 켜 있다면, 앞에 차가 없더라도 A-C 간선에는 빨간불이 켜 있으므로 A-C간선의 끝에서 C교차로를 바라보는 차량은 통행할 수 없습니다. 

또한, 차들은 겹치지 않는다는 점도 (1초에 차량은 1대씩만 통행합니다) 중요합니다.

- **신호등** 은 교차로마다 설치되어 있는데, incoming edge들을 도는 사이클 형태로 신호등 스케쥴링이 가능합니다. 

- **신호등 스케쥴링** 이란, 위 예시를 다시 빌리자면 C교차로에서 다음과 같이 스케쥴링합니다.
  - `{B-C, 2} {A-C, 1}`
  - 이 표현의 해석은 `B-C` 간선에 2초간 초록불을 켜주고, `A-C` 간선으로 1초간 바꿨다가, 다시 `B-C` 간선을 2초간 켜주는 식으로 반복한다는 뜻입니다.
  - 즉, 사이클로만 돌릴 수 있고, 세부적으로 신호등을 조작할 수는 없습니다. 대충 생각해 보면, 교차로의 각 도로들을 위해 신호를 켜주는 순서와 그 비중을 조정할 수 있는 것입니다.

Hashcode 문제는 여기서 **신호등 스케쥴링 사이클** 을 만드는 문제입니다. 다른 모든 것은 주어집니다.

점수는, **제한 시간 내에 도착한 차의 개수** 에 따라 점수를 받으며, **빨리 도착할수록** 보너스 점수가 있습니다. 타임아웃 난 차량은 0점입니다.

## 데이터 설명 
데이터는 총 6개로 구성되어 있습니다. A는 예제고, 나머지 데이터들은..
- B : 그냥 평범한 데이터입니다. 큰 특징은 없습니다.
- C : 격자형태로 도로가 구성된 데이터입니다. 
- D : 시간이 굉장히 빡빡해서, 조금만 지체해도 모든 차들이 타임아웃납니다. 몇개의 허브정점들과 다수의 정점들이 포도송이처럼 연결된 형태입니다.
- E : 모든 정점들이 하나의 허브에 연결된 STAR 형태의 그래프입니다. Etoile는 프랑스어로 별이라고 합니다.
- F : 교차로가 매우 많고, 차량들이 교차로에 Stuck하는 데이터입니다.

## 대회 전략의 실패 
- 구현 복잡도가 높아서, 체커를 작성하지 못했습니다. 저 혼자 대략 1시간 정도 시간을 써 보고, 포기하기로 결정했는데, 그 이유는
  - Coffeetea와 DHDroid가 제시한 알고리즘은 기본적으로 차의 운행을 Simulation해야 합니다. 만약 그런 알고리즘을 실제로 코드로 옮긴다면, Simulation을 통해 점수를 연산하는 별도의 체커 없이도, 코드에 시뮬레이션을 내장할 수 있습니다.
  - 더이상 체커를 잡기에는 시간이 너무 아까웠기 때문입니다.
- 마찬가지 이유로, dlwocks31이 시뮬레이션 코드 작성에 실패했습니다. 대회 후반부에는 시뮬레이션 비슷한게 돌아갔는데, 정확히 성공했는지 여부는 잘 모르겠습니다. 예상 점수와 실제 점수 간에 조금의 오차가 있는 것으로 보아 어딘가 문제가 여전히 있는 것으로 보입니다.
- Coffeetea / DHDroid 듀오의 데이터분석 및 구상은 탁월했습니다. 
- 결과적으로 거의 이 두명이 대회를 캐리해 버렸습니다. 저랑 dlwocks31은 계속 고통받은 대회였습니다 :(

## Algorithm : Demand - Proportional - Scheduling
앞서 **신호를 켜주는 순서와 그 비중을 조정할 수 있다** 라고 했는데, 저희는 그중 비중에 집중했습니다. 구체적으로는, 시뮬레이션을 돌리면서, 각 차량들이 특정 교차로의 특정 도로에 잡혀있을 때마다, 그 정보를 report 합니다.

이런 정보들을 모아둔다면, 교차로 X에서 도로 a, b의 total jam-time을 계산할 수 있고, 이 total jam-time이 높은 도로의 신호를 더 많이 열어 줄 필요가 있음이 자명해 보입니다. (거기 잡혀있는 차가 많으니까, 더 넉넉하게 열어 주는 것입니다) 따라서 이 **DEMAND** 에 비례하는 (또는 뭐 적당히 루트라던가...) 시간가중치를 주어 사이클을 돌리는 방식입니다. 

### Fine Tuning
위 알고리즘에서 튜닝할 수 있는 아이디어는 제가 추가로 들어가고 나서 잠깐씩 Discuss하면서 계속 발전시켜나갔습니다. 대표적으로 이런 것들이 있습니다.
- $t = 1$ 에서의 demand와 $t = 1000$에서의 demand의 가치는 동등하지 않다고 보았습니다. 둘중 하나라면 초반이 빠른 편이 유리하기 때문인데, 똑같이 1초만큼 빨라진다면 초반에 빨라져야 빠르게 차들이 줄어들어서 후반이 덜 막히기 때문입니다.
- 구현하지는 못했지만, 본래 계획에는 실제 시뮬레이션을 거친 다음, 아깝게 시간이 지나 통과하지 못한 차들의 demand에 더 큰 가중치를 부여하는 방안이 있었습니다. 이 방안은 (테스트해보지 못했지만) 충분히 의미가 있었을 것이라고 보입니다.
- 가중치 $w = f(d)$ 는 demand 개수에 대한 함수입니다. $f$를 조금씩 바꾸면서 튜닝할 수 있습니다.

이 모든 튜닝의 결과가 맨 위에 기록된 결과입니다.

## 결과 / Discussion
대회가 끝나고, 바로 근처에서 대회를 치른, 평소 잘 아는 사이인 서울대학교 @channel 팀과 간단한 Discussion을 했습니다. 그 팀은 2018년도에 Hashcode World Final에 진출했던 팀으로, 이번 대회에서는 저희보다 20만점 정도 높은 점수로 40등의 높은 성적을 거두었습니다. 서로 성적을 보는 순간 놀랐는데, 
- @channel 팀은 D에서 240만점 가까이 (저희보다 80만점 높은) 성적을 거두었습니다.
- 반면, F번의 점수는 저희 팀이 60만점 정도 높았습니다. 서로 D와 F를 보며 어떻게 한 거냐고 물으며 디스커션을 진행했는데, 이 팀에게 들은 방법은 (제가 올바르게 이해했다면) 대략 다음과 같습니다.
  - D번의 경우, Degree가 평균적으로 매우 작습니다. 따라서, 굳이 긴 시간동안 한 길을 열어주기보다는, 1초씩 바로바로 바꿔주더라도 특정 도로의 대기시간이 그렇게까지 길지 않으므로, 모든 신호 사이클은 1초로 고정합니다.
  - 그러나, 어떤 순서로 사이클을 돌릴지는 중요합니다. 이를 실제 시뮬레이션을 진행하면서, 해시테이블에 기록하는 식으로 각 intersection마다 어디에 대기가 걸리는지를 파악해서 사이클의 순서를 최적화합니다.
  - 결론적으로, **신호를 켜주는 순서와 그 비중을 조정할 수 있다** 에서, **비중** 을 버리고 **순서** 에 집중한 형태의 솔루션으로 보입니다. 일종의 **Dynamic Cycle Ordering** 이라는 이름을 붙일 수 있겠네요.
- 1등팀의 점수는 1050만 점 정도고, 1000만점을 넘으면 10위권 팀이었습니다. 결과적으로, 저희의 **Demand-Proportional Scheduling** 과 @channel의 **Dynamic Cycle Ordering**이 상호 보완적인 방법이며, 저희가 잘 푸는 케이스 (F) 와 @channel팀이 잘 푼 케이스 (D) 의 max점수를 취하면 1030만 점 정도임을 볼 때, 최상위권 팀은 이 두 가지 전략을 각각 코딩해서 제출했거나, 두 전략을 절충한 방안이 있거나, 또는 우리 모두 생각지 못한 Novel한 방법 (있을지는 모르겠습니다만) 일 것으로 보입니다. 두 가지 모두 어떻게 보면 자연스럽기도 해서, 두가지 모두 구현하는데 성공했으면 월클팀이 아니었나 싶습니다.

## 앞으로를 위해
해시코드류 대회는 사실 저희에게는 매우 재밌기도 하고, 이런 평소에는 생각하기 어려운 것들을 공부하는 기회이기 때문에 나름대로 팀으로써 공부하는 즐거움이 있습니다. 그래서 아마 (적어도 내년에는) 같은 팀으로 나갈 예정인데, 그때를 위해, 또는 다른 프로그래밍 대회를 위해서라도 이번 대회를 통한 교훈을 기록해 두려고 합니다.
- 결국은 구현력이 중요합니다. 특히 Hashcode가 매년 극도로 구현이 빡세지고 있고, 제한시간 4시간 (실제로는 15분동안 스트리밍으로 시간을 날리기 때문에 3시간 45분) 동안 문제의 기본적인 그리디 솔루션을 제시하기조차 어려워지는 현상이 가속되고 있습니다. 결국 이번 대회의 최상위권 전략 중 하나는, **Demand-Proportional Scheduling** 과 **Dynamic Cycle Ordering** 이라는 전혀 결이 다른 두가지 방법을 모두 코딩하는데 성공하는 것인데, 이를 위해서는 적어도 2명 이상의 팀원이 안정적으로 솔루션을 코드로 옮기는 능력이 필요합니다. 
  - Dlwocks31이 우리 중에서는 구현을 가장 잘하지만, 나머지 3명의 구현력이 현저히 떨어지는 것은 굉장히 큰 결점입니다. 이를 보충하기 위해, 최대한 저희가 (특히 그나마 C++ 구현력이 나은 제가) dlwocks31을 보조해주기 위해 이번에는 파일을 나누어 GIT을 써보기도 했는데, 결국 대회가 끝나고 느낀 것은 이 모든 방법은 부족한 구현력을 메워보려는 시도였고 근본적인 해결책이 되지 않는다는 것입니다.
- 아이디어 캐칭 이후, 이걸 바로 코드로 옮겨서 테스트해봐야 합니다. 실제로 Coffeetea가 제시한 많은 휴리스틱한 방법들의 반도 채 쓰지 못했는데 이것도 결국 시도해봐야 아는 문제입니다.

------

작년에도 비슷하게 했던 말이지만, 대회 자체는 해보면 정말 재밌습니다. 솔루션 깎는 과정이 뭔가 다른 PS대회랑 굉장히 이질적이면서도 점수 올라갈때 짜릿한 그런 맛이 있는데, 구현보다는 조금더 최적화 맛이 나는 대회가 되었으면 하는 기대가 있지만 반대로 가는것 같습니다.

여전히 작년 Library처럼, 추한 테크닉으로 가르더라도 결국 진출권은 SAT과 MCMF최적화가 가르는 메타가 옳다는 믿음에는 변화가 없습니다. 그에 비하면 이번 대회는 진짜 구현컵인것 같아서 조금... 하지만 작년에도 그랬듯이, 까보면 누군가 이상한 최적화를 들고왔을수도 있으므로 아직 예단하지는 않으려고 합니다.

구체적으로 DEF중 하나에 뭔가 플로우로 최적화할수 있는게 있을거라고 의심하고 있습니다. 그래프에서 뭔가 지나가고 어쩌고 하는게 딱 플로우 냄새가 나서요...

PS를 즐긴다면 그냥 색다른 느낌으로 즐길만한, 그렇지 않고 원래 Data Science 나 Optimization쪽에 관심이 있더라도 한번쯤 해볼만한 대회라고 생각합니다. 내년에도 파이팅! 

Little Piplup 수고 많았어요 :) + @channel팀의 월파 진출을 응원하겠습니다 :)</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="competition" /><summary type="html">이 글은 올해 해시코드 대회 과정에 대한 후기이고, 준비 과정은 앞 글(링크)에 있습니다.</summary></entry><entry><title type="html">BOJ 16532, ICPC Latin 2018 Looking for the Risk Factor</title><link href="http://localhost:4000/algorithms/BOJ16532/" rel="alternate" type="text/html" title="BOJ 16532, ICPC Latin 2018 Looking for the Risk Factor" /><published>2021-02-21T00:00:00+09:00</published><updated>2021-02-21T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/BOJ16532</id><content type="html" xml:base="http://localhost:4000/algorithms/BOJ16532/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## 풀이 
문제를 요약하자면, 매 쿼리 $(x, y)$ 마다, 2부터 $x$까지의 수 중 소인수가 모두 $y$ 이하인 수의 개수를 세는 문제이다. 두가지 서로 다른 웰노운 문제를 잘 해결할 수 있다면 합쳐서 어렵지 않게 해결할 수 있다. 

1. 에라토스테네스의 체를 살짝 응용하면, 2부터 $M$ 까지의 주어진 수들에 대해서 **가장 큰 소인수** 를 전부 찾는데 $O(n \log \log n)$ 시간이 걸린다. 소인수분해 체와 거의 똑같고 한두줄만 바꾸면 된다.
2. 이제, **가장 큰 소인수** 를 모두 알았으므로, 어떤 수열이 주어졌을 때 문제는 $[2, x]$ 까지의 인덱스들 중 $a_i \leq y$ 인 수들의 개수를 세는 문제가 된다. 이는 [수열과 쿼리 3](https://www.acmicpc.net/problem/13544) 문제와 비슷한데 (시작 인덱스가 고정되어 있으므로 조금 더 쉽다), 크게 두 가지 방법으로 풀 수 있다.

   - 쿼리를 정렬해서, 오프라인으로 풀 수 있다. 이렇게 풀면 세그먼트 트리나 펜윅 트리 같은 걸로, 상수도 작고 시간복잡도도 $O(n \log n)$ 을 유지할 수 있다. 
   - 머지 소트 트리를 쓰면 온라인으로도 풀 수 있다. 머지 소트 트리에 대해서는 언젠가 글을 쓸 수도 있는데, 대략적으로 설명하자면 머지소트를 수행하는 **중간 과정** 을 모두 **실제로** 트리의 형태로 들고있는 자료구조이다. 빌드는 merge를 쓰는지 대충 하는지 여부에 따라 정말 쉽게 코딩하고 싶으면 $O(n \log^2 n)$ 시간에 트리를 빌드해도 되고, 진짜 머지소트를 쓰면 $O(n \log n)$ 시간에 빌드해도 된다. 아래 코드는 $n \log n$ 빌드.
     - 이제, 머지 소트 트리는 $[i, j]$ 에서 $k$ 보다 작거나 같은 수의 개수 (수쿼3) 형태의 쿼리를 `lower_bound, upper_bound` 같은 STL 함수들로 빠르게 처리할 수 있으며, 한번 쿼리에서 이 함수들을 최대 $O(\log n)$ 번 호출하므로 매 쿼리를 $O(\log^2 n)$에 처리하는 셈이 된다.
     - 쿼리는 세그먼트 트리랑 거의 똑같은 느낌으로 쿼리한다. 한번 읽어보면 대충 어떤 느낌의 자료구조인지 알기 어렵지 않다. 

아래 코드는 머지소트트리, $O(n \log n)$ 버전으로 작성되어 있다. 

## 코드 
```cpp
#include &lt;bits/stdc++.h&gt;
#pragma GCC optimize(&quot;O3&quot;)
#pragma GCC optimize(&quot;Ofast&quot;)
#pragma GCC target(&quot;avx,avx2,fma&quot;)
#define ll long long
#define eps 1e-7
#define all(x) ((x).begin()),((x).end())
#define usecppio ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
using namespace std;
#define int ll
using pii = pair&lt;int, int&gt;;

#define MAXN (1&lt;&lt;18)
struct merge_sort_tree
{
    vector &lt;int&gt; tree[MAXN];
    int n;
    void construct (vector &lt;int&gt; data)
    {
        n = 1;
        while(n &lt; data.size()) n &lt;&lt;= 1;
        for (int i = 0; i&lt;data.size(); i++)
            tree[i+n] = {data[i]};
        for (int i = data.size(); i&lt;n; i++)
            tree[i+n] = {};
        for (int i = n-1; i&gt;0; i--)
        {
            tree[i].resize(tree[i*2].size()+tree[i*2+1].size());
            for (int p = 0, q = 0, j = 0; j &lt; tree[i].size(); j++)
            {
                if (p == tree[i*2].size() || (q&lt;tree[i*2+1].size() &amp;&amp; tree[i*2+1][q]&lt;tree[i*2][p]))
                    tree[i][j] = tree[i*2+1][q++];
                else tree[i][j] = tree[i*2][p++];
            }
        }
    }
    int greater(int s, int e, int k, int node, int ns, int ne)
    {
        if (ne &lt;= s || ns &gt;= e)
            return 0;
        if(s &lt;= ns &amp;&amp; ne &lt;= e)
            return tree[node].end() - upper_bound(all(tree[node]), k);
        int mid = (ns+ne)&gt;&gt;1;
        return greater(s,e,k,node*2,ns,mid) + greater(s,e,k,node*2+1,mid,ne);
    }
    int greater(int s, int e, int k)
    {
        return greater(s,e,k,1,0,n);
    }
};

int M = 100000;
int lpd[101010];
vector &lt;int&gt; v(M, 0);
int32_t main()
{
    usecppio
    for (int i = 2; i &lt;= M; i++)
    {
        if (lpd[i]) continue;
        for (int j = i; j &lt;= M; j += i)
            lpd[j] = i;
    }
    for (int i = 1; i &lt;= M; i++)
        v[i-1] = lpd[i];
    merge_sort_tree t;
    t.construct(v);
    int q; cin &gt;&gt; q;
    while(q--)
    {
        int n, k; cin &gt;&gt; n &gt;&gt; k;
        cout &lt;&lt; n - t.greater(0, n, k) - 1 &lt;&lt; &apos;\n&apos;;
    }
}
```</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="number-theory" /><category term="data-structures" /><category term="merge-sort-tree" /><category term="algorithms" /><summary type="html">Contents</summary></entry></feed>