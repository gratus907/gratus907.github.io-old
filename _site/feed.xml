<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-07-28T23:46:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gratus907’s Study Note</title><subtitle>Hello World!</subtitle><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><entry><title type="html">7월 4-5주차 Weekly PS</title><link href="http://localhost:4000/ps_weekly/ps-weekly-21Jul4/" rel="alternate" type="text/html" title="7월 4-5주차 Weekly PS" /><published>2021-07-28T00:00:00+09:00</published><updated>2021-07-28T00:00:00+09:00</updated><id>http://localhost:4000/ps_weekly/ps-weekly-21Jul4</id><content type="html" xml:base="http://localhost:4000/ps_weekly/ps-weekly-21Jul4/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#recent-updates&quot; id=&quot;markdown-toc-recent-updates&quot;&gt;Recent Updates&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rounds&quot; id=&quot;markdown-toc-rounds&quot;&gt;Rounds&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#testing-codeforces-global-round-15&quot; id=&quot;markdown-toc-testing-codeforces-global-round-15&quot;&gt;(Testing) Codeforces Global Round 15&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problems&quot; id=&quot;markdown-toc-problems&quot;&gt;Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-1766-문제집&quot; id=&quot;markdown-toc-boj-1766-문제집&quot;&gt;BOJ 1766 문제집&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#poi-1994-ones-and-zeros-boj-8111-0과-1&quot; id=&quot;markdown-toc-poi-1994-ones-and-zeros-boj-8111-0과-1&quot;&gt;POI 1994 Ones and Zeros (BOJ 8111 0과 1)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-1602-도망자-원숭이&quot; id=&quot;markdown-toc-boj-1602-도망자-원숭이&quot;&gt;BOJ 1602 도망자 원숭이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#icpc-germany-regional-gcpc-2010-d-field-plan-boj-3977-축구-전술&quot; id=&quot;markdown-toc-icpc-germany-regional-gcpc-2010-d-field-plan-boj-3977-축구-전술&quot;&gt;ICPC Germany Regional (GCPC) 2010 D Field Plan (BOJ 3977 축구 전술)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-4196-도미노&quot; id=&quot;markdown-toc-boj-4196-도미노&quot;&gt;BOJ 4196 도미노&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#icpc-jakarta-regional-2018-boomerangs-boj-16583&quot; id=&quot;markdown-toc-icpc-jakarta-regional-2018-boomerangs-boj-16583&quot;&gt;ICPC Jakarta Regional 2018 Boomerangs (BOJ 16583)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;July 19 - July 28, 2021&lt;/p&gt;

&lt;p&gt;이 글에 구현코드 링크가 없더라도 &lt;a href=&quot;https://github.com/gratus907/Gratus_PS&quot;&gt;PS 레포 링크&lt;/a&gt; 에 가서 대회 단위로 들어가면 보통 제가 올려놓은 코드를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;7월 마지막 주는 일반생물학 시험을 비롯, 몇가지 할일이 있어서 PS를 거의 못할듯 합니다 :(&lt;/p&gt;

&lt;p&gt;읽는 사람이 문제를 읽고 조금 생각해봤다고 가정하고, 대략적인 아이디어만 간단히 적을 생각입니다 ㅎㅎ&lt;/p&gt;

&lt;h2 id=&quot;recent-updates&quot;&gt;Recent Updates&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어리석은 실수로 UCPC에 참가하지 못하게 되었습니다.&lt;/li&gt;
  &lt;li&gt;뭔가 SCPC 2차 준비는 마땅히 할수있는게 없고 해서… 순수하게 재밌는 공부를 하려고 노력 중입니다.&lt;/li&gt;
  &lt;li&gt;ICPC 철이 되면 팀원들과 함께 또 재밌게 할수있을듯 합니다. 팀연습이 제일 재밌는거 같아요&lt;/li&gt;
  &lt;li&gt;올해 PS 성과는 코드잼 R3 간걸로 마무리하게 될듯…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rounds&quot;&gt;Rounds&lt;/h2&gt;
&lt;h3 id=&quot;testing-codeforces-global-round-15&quot;&gt;(Testing) Codeforces Global Round 15&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Global Round 15에 테스터로 참여했습니다.&lt;/li&gt;
  &lt;li&gt;제가 테스팅했을때랑 비교하면, B번 문제가 새로 생겼고, 원래의 B번이 D번으로 이동했습니다. 테스팅했을때도 B (지금의 D) 가 너무 어려운거 같다는 생각은 들었었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;
&lt;p&gt;그래프 연습.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;boj-1766-문제집&quot;&gt;BOJ 1766 문제집&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Gold 2&lt;/li&gt;
  &lt;li&gt;사용하는 알고리즘들에 대한 이해만 명확하면 쉽습니다.&lt;/li&gt;
  &lt;li&gt;BFS로 노드들을 위상 정렬하는 방법을 따르되&lt;/li&gt;
  &lt;li&gt;queue 대신 항상 가능한 쉬운 문제를 풀라는 조건이 있으므로 BFS에서 Queue 대신 Priority Queue를 쓰면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;poi-1994-ones-and-zeros-boj-8111-0과-1&quot;&gt;POI 1994 Ones and Zeros (BOJ 8111 0과 1)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 5&lt;/li&gt;
  &lt;li&gt;어떤 수의 뒤에 0과 1을 이어서 다음 수를 만들 수 있습니다. 이를 0부터 $N-1$까지의 노드가 있다고 생각하면 나머지가 $r$에 서, $10r$ 또는 $10r + 1$ 로 노드가 이어져 있음을 관찰합니다.&lt;/li&gt;
  &lt;li&gt;이제 1에서 BFS를 통해 노드들을 방문하면서, 0이 100-step 이내에 방문 가능한지 확인하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;boj-1602-도망자-원숭이&quot;&gt;BOJ 1602 도망자 원숭이&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 5&lt;/li&gt;
  &lt;li&gt;노드 가중치는 합이 아니라, 경로 상의 가중치의 max만 한 번 더합니다.&lt;/li&gt;
  &lt;li&gt;이 문제를 해결하는 방법은, 그냥 노드 순서대로 ‘중간 노드’ 를 쓰는 F-W와는 달리 노드 가중치가 작은 것부터 중간 노드로 써서 업데이트하는 것입니다.&lt;/li&gt;
  &lt;li&gt;이렇게 하면, 새로운 노드를 쓰는 경우 항상 노드가중치는 새 노드의 것을 따라가게 되므로, 비교적 쉽게 해결할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;icpc-germany-regional-gcpc-2010-d-field-plan-boj-3977-축구-전술&quot;&gt;ICPC Germany Regional (GCPC) 2010 D Field Plan (BOJ 3977 축구 전술)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 4&lt;/li&gt;
  &lt;li&gt;그래프를 SCC로 묶어서 생각합니다. 같은 SCC에 있는 정점끼리는 언제든 서로 오갈 수 있기 떄문입니다.&lt;/li&gt;
  &lt;li&gt;이제, indegree가 0인 SCC를 찾아서, 그 SCC로부터 출발하면 됩니다.&lt;/li&gt;
  &lt;li&gt;단, indegree가 0인 SCC가 여러개이면 이 두개를 서로 오갈수가 없어서, 불가능합니다.&lt;/li&gt;
  &lt;li&gt;SCC 구현은 Tarjan 아니면 Kosaraju인데, Tarjan이 구현할게 적고 좀더 빠릅니다. Kosaraju는 최소 2번 이상의 DFS를 돌아야 하기 때문입니다.&lt;/li&gt;
  &lt;li&gt;별개로 저는 예전에 짜놓은 Kosaraju를 대충 박아넣었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;boj-4196-도미노&quot;&gt;BOJ 4196 도미노&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 4&lt;/li&gt;
  &lt;li&gt;마찬가지로, SCC를 묶은 다음 indegree가 0인 SCC를 찾는 문제입니다. 위 문제와 거의 똑같습니다.&lt;/li&gt;
  &lt;li&gt;다만 이번엔 불가능한 경우가 아니라, indegree가 0인 모든 SCC를 직접 넘어트리면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;icpc-jakarta-regional-2018-boomerangs-boj-16583&quot;&gt;ICPC Jakarta Regional 2018 Boomerangs (BOJ 16583)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 2&lt;/li&gt;
  &lt;li&gt;먼저, 트리에 대해 문제를 풀어 봅시다. 어떤 노드의 child가 짝수개라면, 짝수개의 자식노드들과 현재 노드를 부메랑으로 서로 이어주면 됩니다.&lt;/li&gt;
  &lt;li&gt;홀수개라면, 방금전처럼 잇고, 이어지지 않은 하나의 노드와 현재 노드, 현재 노드의 부모 노드를 부메랑으로 이어주면 됩니다.&lt;/li&gt;
  &lt;li&gt;이때, 부모 노드에게 현재 노드는 이미 사용되었으므로 부모 노드의 자식노드를 잇는 과정에 참여하면 안 된다는 사실을 report해야 합니다.&lt;/li&gt;
  &lt;li&gt;이렇게 하면, 트리를 DFS 순서로 돌면서 모든 간선을 (간선이 홀수개면 1개 빼고) 부메랑에 참여시킬 수 있습니다.&lt;/li&gt;
  &lt;li&gt;따라서, 트리에 대해서는 문제를 해결하였습니다. 이를 일반화해서 임의 그래프에 대해 해결해 보겠습니다.&lt;/li&gt;
  &lt;li&gt;우리는 정점이 중요하지 않고, 간선만 중요하므로, 그래프를 강제로 트리처럼 펴면 됩니다. 이 방법은, 사이클을 이루기 시작하는 간선을 만나면 그 간선의 끝에 새로운 정점을 만들어서, 사이클을 이루지 못하게 막으면 됩니다. 이때 새로운 정점은 나중에 부메랑을 만들 때 다시 원래 정점으로 돌려줘야 하기에, 이 사실을 기억해야 합니다.&lt;/li&gt;
  &lt;li&gt;말은 복잡하지만, 코드는 굉장히 깔끔하게 나옵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build_tree(r, p)&lt;/code&gt; 함수를 보면 됩니다.&lt;/li&gt;
  &lt;li&gt;전체 과정을 DFS 2번으로 해결할 수 있습니다. 두번째 BFS인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build_boo(r, p)&lt;/code&gt; 에서, child node 들 중 이미 사용한 노드를 표현하는 등 디테일은 조금 주의해야겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ps_weekly" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">서울대학교 컴퓨터공학부 / 수리과학부 과목 소개 및 한줄평</title><link href="http://localhost:4000/snu-courses/SNU-courses/" rel="alternate" type="text/html" title="서울대학교 컴퓨터공학부 / 수리과학부 과목 소개 및 한줄평" /><published>2021-07-24T00:00:00+09:00</published><updated>2021-07-24T00:00:00+09:00</updated><id>http://localhost:4000/snu-courses/SNU-courses</id><content type="html" xml:base="http://localhost:4000/snu-courses/SNU-courses/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#컴퓨터공학부&quot; id=&quot;markdown-toc-컴퓨터공학부&quot;&gt;컴퓨터공학부&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1학년-과목&quot; id=&quot;markdown-toc-1학년-과목&quot;&gt;1학년 과목&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#컴퓨터의-개념-및-실습&quot; id=&quot;markdown-toc-컴퓨터의-개념-및-실습&quot;&gt;컴퓨터의 개념 및 실습&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#프로그래밍-연습&quot; id=&quot;markdown-toc-프로그래밍-연습&quot;&gt;프로그래밍 연습&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#이산수학&quot; id=&quot;markdown-toc-이산수학&quot;&gt;이산수학&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2학년-과목&quot; id=&quot;markdown-toc-2학년-과목&quot;&gt;2학년 과목&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#컴퓨터-프로그래밍&quot; id=&quot;markdown-toc-컴퓨터-프로그래밍&quot;&gt;컴퓨터 프로그래밍&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#논리설계&quot; id=&quot;markdown-toc-논리설계&quot;&gt;논리설계&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#자료구조&quot; id=&quot;markdown-toc-자료구조&quot;&gt;자료구조&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#컴퓨터구조&quot; id=&quot;markdown-toc-컴퓨터구조&quot;&gt;컴퓨터구조&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#프로그래밍-언어&quot; id=&quot;markdown-toc-프로그래밍-언어&quot;&gt;프로그래밍 언어&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#전기전자회로&quot; id=&quot;markdown-toc-전기전자회로&quot;&gt;전기전자회로&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3학년-과목&quot; id=&quot;markdown-toc-3학년-과목&quot;&gt;3학년 과목&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#알고리즘&quot; id=&quot;markdown-toc-알고리즘&quot;&gt;알고리즘&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#양자-컴퓨팅의-기초&quot; id=&quot;markdown-toc-양자-컴퓨팅의-기초&quot;&gt;양자 컴퓨팅의 기초&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#데이터베이스&quot; id=&quot;markdown-toc-데이터베이스&quot;&gt;데이터베이스&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;컴퓨터공학부&quot;&gt;컴퓨터공학부&lt;/h2&gt;
&lt;h3 id=&quot;1학년-과목&quot;&gt;1학년 과목&lt;/h3&gt;
&lt;h4 id=&quot;컴퓨터의-개념-및-실습&quot;&gt;컴퓨터의 개념 및 실습&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2018년 1학기 (1학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;굉장한 과목입니다. 들을 때는 몰랐는데, 다른 학교의 1학년 첫 컴공과 기초 과목이 보통 파이썬이나 C를 가르치는데 비해 이 과목은 무려 컴퓨터구조에 대해 배웁니다. LC-3라는 toy computer의 어셈블리는 물론, 기계어로 직접 뭔가를 짜게 합니다.&lt;/li&gt;
  &lt;li&gt;이게 무슨 말이냐면, 보통 C를 배운 후 어셈블리로 넘어가서 C를 통해 어셈블리와 컴퓨터 구조를 이해하는게 일반적인 테크지만, 저희는 반대로 컴퓨터의 폰 노이만 구조와 Program counter, memory model을 먼저 배운 뒤, 어셈블리 (진짜 어셈은 아니지만) 단계에서 이를 이해해보고, 거꾸로 C를 그 위에서 쌓아 나갑니다. 이렇게 배우면 포인터가 안 어렵다는 정도? 장점이 있는것 같습니다.&lt;/li&gt;
  &lt;li&gt;힘들었지만 재밌었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;프로그래밍-연습&quot;&gt;프로그래밍 연습&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2018년 2학기 (2학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;C언어의 기초를 배웁니다.&lt;/li&gt;
  &lt;li&gt;기말프로젝트가 카드 뒤집으면서 기억력으로 페어 맞추는 게임 (게임 이름을 까먹었네요) 만드는 거였는데, 재밌었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;이산수학&quot;&gt;이산수학&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2021년 1학기 (7학기차) 에 수강했습니다. (왜?? ㅋㅋㅋ)&lt;/li&gt;
  &lt;li&gt;Logic, Group, Probability, Graph, Algorithm 등 종횡무진 뛰어다니며 넓고 얕게 배웁니다.&lt;/li&gt;
  &lt;li&gt;CS/MATH이고 7학기차였으므로 저는 이 과목에서 배우는 모든 내용을 다른 과목에서 배워본 상태였습니다. 처음 듣는 컴공 전공이라면 증명이나 논증을 체계적으로 하는 법을 익히는 좋은 과목이라고 생각합니다. 저는 그 역할을 해석개론이 대신해 줬습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2학년-과목&quot;&gt;2학년 과목&lt;/h3&gt;
&lt;h4 id=&quot;컴퓨터-프로그래밍&quot;&gt;컴퓨터 프로그래밍&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 1학기 (3학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;객체지향 프로그래밍, 객체지향의 개념에 대해 배웁니다.&lt;/li&gt;
  &lt;li&gt;기말 과제로 체스를 구현하는 과제가 있었습니다. 처음 하면서 꽤 어려웠던 기억이 있습니다.&lt;/li&gt;
  &lt;li&gt;이런걸 익히려면 해보는 방법밖에 없다는 말을 체감하게 됩니다. 코딩을 하다보면 아 이게 그런 말이구나 할 때가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;논리설계&quot;&gt;논리설계&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 1학기 (3학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;Boolean Algebra와 카르노 맵으로 시작해서, 논리 게이트, Adder 등 간단한 논리 회로에 대해 배웁니다. 끝부분에는 FSM을 다룹니다.&lt;/li&gt;
  &lt;li&gt;마지막에는 베릴로그로 CPU 짜는 과제가 있었습니다.&lt;/li&gt;
  &lt;li&gt;Verilog 3부작 중 1부인데, 저는 정말 힘들었습니다. 저는 Verilog와 진짜 안 맞는다는걸 깨달았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;자료구조&quot;&gt;자료구조&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;저는 입학하자마자 SNUPS에서 kipa00님한테 PS를 배우면서 C++를 익히는 것으로 시작해서, PS를 꽤 열심히 했었기 때문에 이때는 블루~퍼플 근처의 실력이었습니다. (지금도 퍼플을 못 벗어나고 있네요 ㅋㅋ) 2년 더 이때처럼 Training했으면 제가 PS를 더 잘 했을까요? 모르겠네요…&lt;/li&gt;
  &lt;li&gt;가장 집중적으로 PS를 공부했던 시점이라서 자료구조는 정말 쉽게 공부했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;컴퓨터구조&quot;&gt;컴퓨터구조&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;제 개인의 주관을 최대한 배제하고서, 컴퓨터공학이 뭔지 알기 위해 딱 2개의 수업만 들을수 있다면 저는 자료구조 또는 알고리즘과 컴퓨터구조를 뽑겠습니다. 컴퓨터구조에서는 논설의 끝부분을 시작으로, CPU의 내부 구조, Pipelining, Memory Hierarchy, 멀티코어와 멀티스레드 등을 다룹니다.&lt;/li&gt;
  &lt;li&gt;컴퓨터 자체에 대해 가장 많은 내용을 배울 수 있습니다. 언젠가 고급 컴퓨터 구조를 듣고 싶은데 여력이 될지 모르겠습니다.&lt;/li&gt;
  &lt;li&gt;Verilog로 파이프라이닝이 있는 CPU를 짜는 과제가 나왔었는데, 여기서 거의 0점에 가까운 점수를 받았습니다. 이 과제가 아니었다면 나머지는 A+를 충분히 받을 수 있는 성적이었는데 이 과제 하나 때문에 A0를 받았습니다. Verilog는 너무 어려워요…&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;프로그래밍-언어&quot;&gt;프로그래밍 언어&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;OCaml로 함수형 프로그래밍, 메모리 관리, 재귀 호출 등 PL의 핵심 아이디어들을 배웁니다.&lt;/li&gt;
  &lt;li&gt;인터프리터 만드는 과제가 꽤 많은데, 과제가 재밌지만 오래 걸렸습니다.&lt;/li&gt;
  &lt;li&gt;OCaml 프로그래밍이 굉장히 생소했습니다. 그후로 한번도 안써서 이제는 많이 잊어버렸습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;전기전자회로&quot;&gt;전기전자회로&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;일반적인 전기전자회로 수업입니다.&lt;/li&gt;
  &lt;li&gt;힘들고 어려웠습니다. 돌이켜 생각해보면 내용이 막 어렵진 않았는데, 공부하기가 너무 힘들었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3학년-과목&quot;&gt;3학년 과목&lt;/h3&gt;
&lt;h4 id=&quot;알고리즘&quot;&gt;알고리즘&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;자료구조와 같은 이유로 비교적 편하게 들었습니다.&lt;/li&gt;
  &lt;li&gt;모든 알고리즘 강의에서 강의하는 시간복잡도, 정렬, 탐색, DP, 그리디, 그래프, 최단경로, MST까지 배웁니다.&lt;/li&gt;
  &lt;li&gt;그 후로는 NP-Complete 문제들과 그 환원, matroid 등 재밌는 개념들을 좀 배웠습니다. 이쪽이 주력이셨던 교수님이셨기 때문에 특히 그랬던듯 합니다.&lt;/li&gt;
  &lt;li&gt;비슷한 PS 실력의 다른 사람들에 비해, 저는 이론적인 알고리즘에 관심이 많은 편입니다. 이때쯤에는 이쪽 분야 진학을 계획하기 시작했기 때문에, PS 공부를 이 이후로는 거의 못 했습니다. 그와는 별개로 알고리즘 수업은 정말 재밌게 들었습니다.&lt;/li&gt;
  &lt;li&gt;그리고 뭐… 어쨌든 퍼플이면 학부 알고리즘 수업은 무난하게 들을 수 있습니다. 특히 construction에 강한 사람들보다 (PS를 진짜 잘하는건 이분들입니다) 저처럼 대학와서 PS를 시작해서 academic하게 공부한 사람은 더 그렇습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;양자-컴퓨팅의-기초&quot;&gt;양자 컴퓨팅의 기초&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;물리학이라고는 1학년 1학기에 교양 B0 맞은 이후로 쳐다본적도 없는데, 갑자기 양자역학의 기초 원리들을 배우게 되어 어려웠습니다.&lt;/li&gt;
  &lt;li&gt;선형대수학을 열심히 들었다면 할만하고, 그렇지 않다면 듣기 힘든 과목인것 같습니다.&lt;/li&gt;
  &lt;li&gt;나머지 CSE 과목들과 아예 다른 트랙 위에 서 있어서, 이것만 들어도 들을만 합니다 (Lin Alg를 안다면)&lt;/li&gt;
  &lt;li&gt;새롭고 재밌었습니다. 아예 새로운 내용을 배우는 과목은 대체로 좋아하는 편입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터베이스&quot;&gt;데이터베이스&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;제게는 학부 지도교수님이신 교수님께서 강의하시는 과목입니다. 상담때 정말 많은 조언을 받았기 때문에 항상 감사한 마음입니다.&lt;/li&gt;
  &lt;li&gt;무려 JAVA로 밑바닥부터 SQL 쿼리를 파싱하고, 이를 처리하는 프로젝트가 있습니다.&lt;/li&gt;
  &lt;li&gt;모든 DB 강의에서 배우는, DB의 원리들, SQL, DB가 가져야할 원칙 등을 배우는, standard한 수업입니다.&lt;/li&gt;
  &lt;li&gt;하지만 프로젝트의 코딩량이 정말 충격적입니다. 저는 주언어가 C++이었고 JAVA 코딩은 컴프-자구 과제 해본게 다였기 때문에 정말 어려웠습니다. 솔직히 C++로 짰으면 짤 수 있었을것 같은데, 뭐 이건 제 코딩실력의 문제이므로 수업 자체의 난이도와는 좀 다른 얘기가 아닌가 싶습니다.&lt;/li&gt;
  &lt;li&gt;공대지만 Engineering스러운 과목은 많이 듣지 못했는데, 이 과목은 좀 CS에서는 Engineering스러운 마인드의 과목이라서 나름의 재미가 있었습니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="snu-courses" /><summary type="html">Contents</summary></entry><entry><title type="html">Karger-Stein Minimum Cut</title><link href="http://localhost:4000/advanced_algorithms/karger-stein-mincut/" rel="alternate" type="text/html" title="Karger-Stein Minimum Cut" /><published>2021-07-23T00:00:00+09:00</published><updated>2021-07-23T00:00:00+09:00</updated><id>http://localhost:4000/advanced_algorithms/karger-stein-mincut</id><content type="html" xml:base="http://localhost:4000/advanced_algorithms/karger-stein-mincut/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## Min Cut 
Min Cut 문제란, 어떤 그래프 $G = (V, E)$ 가 주어졌을 때, $V$의 정점들을 두 집합 $S, T$ 로 나누어서, $$\Setcond{(u, v) \in E}{u \in S, v \in T}$$ 즉, 한쪽 끝이 $S$에, 다른쪽 끝이 $T$에 들어가는 간선들의 개수를 최소화하는 문제입니다.
Weighted graph에서는 간선의 개수가 아니라 weight의 합을 최소화하는 문제로 바꾸어 생각하면 됩니다.

우리는 논의를 위해, 편의상 그래프를 unweighted connected의 경우로만 한정하겠습니다. Directed / Undirected는 (그림은 undirected로 그리더라도) 사실 문제 자체가 똑같습니다. 알고리즘의 측면에서는 조금 차이가 있으므로, 좀더 일반적인 directed graph의 경우를 생각하겠습니다.   

![picture 2](../../images/6847c6f5d096dda16e319ccb61c02cc4d3f7dd6a2dc0198741a96670c976cad9.png)  

예를 들어 이 그림에서 빨간색 cut은 간선 3개짜리 cut이지만, 초록색 cut은 간선 1개짜리입니다.  

## s-t min cut
Min cut 문제의 variation 중 하나는, s-t min cut 이라는 문제입니다. 이 문제는 $s, t$ 라는 두 정점이 각각 $S, T$에 속해야 한다는 추가 제약조건이 걸린 min cut 문제입니다. 
- 매우 유명한 Max-Flow-Min-Cut Theorem에 의하면, s-t min cut 문제는 s-t max flow로 계산할 수 있습니다. 구체적으로, $s$ 에서 $t$로 가는 max flow와 $s-t$ min cut의 크기가 같다는 정리입니다.
- 이 정리의 핵심 아이디어는 두 문제를 각각 LP (Linear Programming) 문제로 바꾼 후, 두 LP를 비교하는 것입니다. 두 LP는 서로 primal-dual 관계에 있음을 알 수 있는데, Dual Linear Program의 Strong duality theorem에 의하면, LP의 경우 strong duality를 갖기 때문에 두 문제의 최적값, 즉 max-flow와 min-cut의 결과값이 같습니다. 
- Primal-Dual LP나 Strong duality에 대한 증명은 이 포스팅의 범위를 넘어가는 이야기이기 때문에 생략합니다. 궁금하다면 [^1] 을 참고. Farkas Lemma 등 알아야 할 내용이 상당히 많습니다. 
- Dinic의 알고리즘으로 max flow를 $O(V^2 E)$ 에 해결할 수 있고, $E$ 를 $V^2$ 까지 갈 수 있음을 감안하면[^2] 현재 실질적으로 가장 빠른 flow는 $O(V^3)$ 시간에 도는 알고리즘들이 있습니다. (Push-Relabel with FIFO)

이제, 일반적인 min cut을 풀고자 한다고 생각해 봅시다. 당연히, 모든 정점 페어를 $s, t$로 잡고 s-t min cut을 해보는 방법을 생각할 수 있으므로, 우리는 적어도 $O(V^5)$ 알고리즘을 가지고 있습니다. 이보다 나은 방법을 생각해 봅시다. 이하, 시간 복잡도를 쓸 때 정점이 $n$ 개, 간선이 $m$개라고 생각하겠습니다. 즉 $\abs{V} = n, \abs{E} = m$.

## Karger's Algorithm
지금은 MIT의 교수로 계신 Prof. David R Karger가 제시한 Karger's Algorithm은 Edge contraction이라는 연산에 기반하는, 매우 간단하고 elegant한 알고리즘입니다. 

### Edge contraction
Edge contraction이란, 말 그대로 edge 양쪽 끝을 접합하는 연산입니다. Edge $e = (u, v)$를 contract한 그래프 $G / e$ 는 다음과 같은 과정을 통해 만들어집니다.

- $(u, v)$ 의 양쪽 vertex $u$ 과 $v$를 합쳐 하나의 vertex $w$를 만듭니다.
- $(u, x)$ 나 $(v, x)$ 가 있으면 이걸 모두 $(w, x)$ 로 만듭니다. 이때, parallel edge는 허용되어야 합니다. [^3]
- 같은 방법으로 $(x, u), (x, v)$ 에 대해서도 같은 과정을 거칩니다. 
- 단, $(u, v)$ 간선은 삭제합니다. self loop은 허용하지 않고, $(w, w)$는 없애 버립니다.

예를 들어 이런 식입니다. 그림을 보면 거의 바로 이해가 갈듯 합니다. 
![picture 1](../../images/2c92dd9b9bc3f0c9411cacedc64addffa22ed1adce7826e5922051264953e220.png)  

### Algorithm
Karger's Algorithm은 정말 어이가 없을 정도로 간단합니다. 
- Edge Contraction을 계속 진행해서, 노드 두개와 그 노드 두개 사이의 간선 $k$ 개가 남았다고 합시다. 
- 재미있는 사실은, 우리의 Edge contraction은 사실 **이 두 정점은 같은 집합에 있다** 라고 처리하는 것과 동치입니다. 
- 따라서, 남은 두개의 정점 $a, b$에 대해 **a로 합쳐진 정점의 집합** 과 **b로 합쳐진 정점의 집합** 을 $S, T$로 삼으면, 마지막 순간에 $a, b$를 잇는 $k$개의 간선이 cut edge가 됩니다. 
- 그러므로, 정점을 무작정 랜덤하게 줄여나가다가 2개가 남으면 (min cut은 아니겠지만) cut을 하나 얻습니다. 
- 우리는, 이걸 충분히 많이 반복하면 min cut을 얻을 확률이 충분히 높음을 논증하고자 합니다. 구체적으로, 이렇게 cut을 하나 얻는 과정까지를 $q$ 번 반복하여, 그동안 얻은 cut들 중 가장 작은 (간선이 적은) cut을 취하는 것을 생각하겠습니다.  

### Proof 
min cut의 크기를 편의상 $K$ 라고 하고, 실제 cut edge의 집합을 $C$라고 하겠습니다. 이제, 위 알고리즘이 C를 반환할, 즉 올바른 답을 제공할 확률은 $K$개의 Edge가 $n-2$번의 contraction을 모두 살아남아야 합니다. 각 contraction에서는 남은 edge들 중 하나를 **임의로** contraction해버리므로, 매 스텝을 모두 살아남을 확률은 
$$\prod_{i = 0}^{n-3} \left(1 - \frac{K}{E - i}\right)$$
이렇게 계산됩니다. 그런데, $\frac{K}{E - i}$ 는 잘 생각해보면 좋은 바운드를 잡을 수 있습니다. 

Contraction을 진행하는 과정 중 한 번이라도 만약 어떤 정점 $u$ 가 $d_u &lt; K$ 를 만족한다면, $u$ 와 나머지를 자르는 cut의 크기가 $d_u$ 가 되기 때문에, 정의로부터 모든 정점의 degree는 $K$보다 언제나 크게 됩니다. 따라서 $i$번째 contraction 이전 남은 정점이 $n - i$개이므로 전체 edge의 개수는 $\frac{K(n-i)}{2}$ 개보다 크고, 위 확률 계산은 
$$p_{success} \geq \prod_{i = 0}^{n-3} \left(1 - \frac{2}{n - i}\right) = \frac{1}{\binom{n}{2}}$$
이렇게 계산되게 됩니다. 

편하게, 대충 성공 확률이 $1 / n^2$ 스케일이 된다고 하겠습니다 (이거보다 2배 좀 더되게 높습니다). 만약 우리가 이 알고리즘을 $n^2 \log n$ 번 시도한다면, 개별적인 성공확률이 $1 / n^2$ 인 베르누이 시행을 $n^2 \log n$ 번 하는 것이므로, 모두 실패할 확률은 $\left(1 - \frac{1}{n^2}\right)^{n^2 \log n}$ 이고, 이 값은 $1/n$ 미만입니다. [^4]

이정도 실패확률이라면 충분히 큰 $n$에 대해서 받아들일만 합니다. 따라서, 우리는 이 알고리즘을 $n^2 \log n$ 번 정도 실행하면 된다고 생각할 수 있습니다.

### Time Complexity
그래프 알고리즘이 대개 그렇듯 한번당 드는 시간은 구현하기 나름입니다. Adjacency matrix가 있다면 $O(n^2)$ 으로 구현하면 되고, Adj list가 있다면 $O(m)$ 비슷한 시간이 걸리는게 그럴듯해 보입니다. 가장 쉽게 짜는 방법은 Kruskal 알고리즘을 구현할 때처럼 구현하는 방법이고, 이 방법의 구현체는 (언젠가 제가 구현하면 구현체 링크를 올릴 예정입니다) $O(m \log m)$ 정도에 돌게 할 수 있습니다. 이렇게 짜면 $m \approx n^2$ 일 때 최대 $O(n^2 \log n)$ 이 되므로, 전체 복잡도는 $O(n^4 \log^2 n)$ 이 되겠습니다.

구현을 잘 하면 한번 iteration을 $O(m)$ 에 돌게 해서, $O(n^4 \log n)$ 에 구겨 넣을 수 있습니다만, 이건 그래프 구현을 잘 하는지의 문제이므로 우리는 다루지 않겠습니다. 다만, 알고리즘의 분석에는 중요하므로, Karger 알고리즘을 잘 구현했을 때의 복잡도는 한번 Iteration에 $O(n^2)$, $n^2 \log n$ 번 반복할 것이므로 $O(n^4 \log n)$ 이다 라고 쓰겠습니다. 


## Karger-Stein Algorithm
Karger-Stein은 위 알고리즘과 거의 똑같지만, Clever idea가 살짝 추가되어 훨씬 빨라집니다. 다시 앞서의 확률 계산으로 돌아가겠습니다. 
$$p_{success} \geq \prod_{i = 0}^{n-3} \left(1 - \frac{2}{n - i}\right)$$
이제, 여기서 관찰하고 싶은 사실은, 초반보다 후반에 성공확률이 빠르게 낮아진다는 점입니다. 즉 초반에는 마구 뽑아도 대충 맞을것이라고 기대할 수 있지만, 후반에는 점점 불안해지기 시작한다는 것이죠. 따라서, 초반에는 대충 뽑아서 믿음을 가지고 돌리다가, 후반에는 좀 빡세게 보면 좋지 않을까요?

이점에 착안한 Karger-Stein은 노드 개수가 대충 $V / \sqrt{2}$개가 될때까지는 그냥 노드를 Karger처럼 줄이다가, 노드가 저만큼 남으면 두배로 많이 검토합니다. 이 수치를 쓰는 이유는, 계산해 보면 $V / \sqrt{2}$개의 노드가 남을 때까지 Contraction을 하면 이동안 min cut이 살아남을 확률이 $1/2$ 가 살짝 넘기 때문입니다. 즉, 원래 Karger 알고리즘은 $n$개부터 $2$개까지 줄여보는걸 한 스텝이라고 정의했지만, $n$ 개부터 $n / \sqrt{2}$ 개까지는 그냥 막 줄이고, $n / \sqrt{2}$ 부터 $n / 2$ 개가 될 때까지 줄여보는 행동은 두번 해서 나은걸 고르고... 이런 식입니다. 단, 재귀적으로 작동한다는 점을 주의해야 합니다. Pseudocode를 쓰면, 

![picture 1](../../images/a6218b939c81ba01c49e2e77a0a361466d92cb79b6f7de646e29f7602ef6a480.png)  

여기서 `contract(G, t)` 함수는 $G$의 edge가 $t$가 될 때까지 랜덤하게 contraction해서 줄이는 함수입니다. 6은 별 의미가 있는 상수는 아니고, 그냥 base case를 준 것으로 생각하시면 됩니다.


이 알고리즘의 성공 확률과 실행 시간에 대해 이해해 보겠습니다. 단, 위키피디아나 여러 자료에는 ceil 등으로 좀 정확하게 써있지만 우리는 어차피 big-O notation에 ceil을 하냐마냐는 영향도 없고... 대충 모든 수를 정수라고 생각하고 넘기겠습니다. $n / \sqrt{2}$ 같은걸 대충 쓰기로 합시다. (사실 분석에는 아무 문제 없습니다!)

### Time Complexity of iteration
편하게, Ceiling 같은거 다 날리고 점화식을 써 보겠습니다. 위 Pseudocode의 `fastmincut(G)`가 정점 $n$개의 그래프일 때, Contract 한번이 정점 개수만큼의 시간을 소모함을 고려하면[^5] , $\sum_{i = n / \sqrt{2}}^{n} i$ 는 $O(n^2)$ 이므로 (대충 $n^2 / 4$ 정도 된다는걸 보이기 별로 어렵지 않습니다),  
$$T(n) = 2 T(n / \sqrt{2}) + O(n^2)$$
이런 점화식을 얻습니다. 우리 모두 알고리즘 시간에 이미 배운 마스터 정리를 쓰면, $\log_{\sqrt{2}} 2 = 2$ 이므로, $T(n) = O(n^2 \log n)$ 을 얻습니다. 즉, 한번 연산에는 $n^2 \log n$ 시간이 걸린다는 것입니다. 앞서의 Karger과 비교하면, 두배로 연산을 늘리는 과정에서 $\log n$ 만큼의 시간을 추가로 지불했다는것을 알 수 있습니다.

### Probability of Success
이제 한번 시도의 성공 확률에 대해 알아야 합니다. $P(n)$ 을 $n$개 정점에 대해 `fastmincut`의 결과가 올바를 확률이라고 하면, 이 함수가 실패하기 위해서는 두 개의 `fastmincut(n / sqrt(2))` 가 모두 실패해야 합니다. 따라서, 다음 점화식을 쓸 수 있습니다.
$$P(n) = 1 - \left(1 - \frac{1}{2} P\left(\frac{n}{\sqrt{2}}\right)\right)^2$$
- 먼저, 맨 안쪽에 붙는 1/2 는, $n$개에서 $n / \sqrt{2}$ 로 줄일 때 맞게 줄였을 확률이 1/2 밖에 되지 않기 때문입니다. 사실 이 확률이 1/2보다 살짝 크다는 것을 증명할 수 있기 때문에 $P(n) \geq$ 로 시작하는 부등식으로 쓰는 것이 맞습니다.
- 그다음은 당연히, $P(n / \sqrt{2})$ 로, 이 알고리즘이 재귀적으로 맞을 확률을 써 줍니다.
- 우리는 `1 - (둘 다 실패할 확률)` 을 구하므로, 이는 다시 `1 - (하나가 실패할 확률)^2` 가 됩니다. 하나가 실패할 확률은 `1 - (하나가 성공할 확률)` 이므로, 위와 같이 구하는 것이 정당합니다.

이제, 이 식을 푸는 방법은 Induction입니다.

위 식을 잘 전개하면, $P(n) = P(n / \sqrt{2}) - \frac{1}{4} P(n / \sqrt{2})^2$ 임을 알 수 있습니다. 

우리는 이제 $P(n) \geq \frac{1}{\log{n}}$ 을 주장합니다. (단, 로그는 로그2) By induction, 다음의 오른쪽 부등호를 증명하면 증명이 끝납니다.
$$P(n) \geq \frac{1}{\log(n/\sqrt{2})} - \frac{1}{4\log^2(n/\sqrt{2})} \geq \frac{1}{\log n}$$
이 부등식을 직접 풀기는 조금 귀찮지만, 별로 어렵지는 않습니다. 솔직히, 대학원 알고리즘 수업에서 배우는 내용에 대한 글을 여기까지 읽을만큼 흥미와 관심이 있는 ~~이상한~~ 사람이라면 저정도 부등식은 증명하기 별로 어렵지 않을 것 같지만, 칼을 들었으면 무를 썰어야 한다는 철학에 의해 중간 스텝을 대충 생략하더라도 대충 스케치해 보겠습니다. 

밑이 2인 로그를 쓰고 있으므로, 위 식은 이렇게 정리가 됩니다. 
$$\frac{1}{\log n - 1/2)} - \frac{1}{4(\log n - 1/2)}$$

이제, 이 식을 꾸역꾸역 통분해서 
$$\frac{4 \log n - 3}{4\log^2 n - 4\log n + 1} = \frac{1}{\log n} + \frac{1 - 1 / \log{n}}{4\log^2 n - 4\log n + 1} \geq \frac{1}{\log n}$$

이렇게 얻습니다. 부등식을 더 이쁘게 패면 $2 / \log n$ 인가? 하는 바운드도 잡을 수 있을텐데, 별로 중요한 논의는 아닙니다. 

어쨌든, 우리는 한번 성공확률이 $1 / \log n$ 수준임을 알았습니다.

### Total time complexity
몇번 수행할 것인지만 정하면 끝입니다. 앞서 Karger 알고리즘의 시간 복잡도 증명에서 했던 것과 똑같은 연산을 해 보면, 성공확률이 $p(n)$ 인 베르누이 시행을 반복해서 $1/n$ 이하의 실패확률을 갖게 하려면, $q(n)$ 번 실행한다고 할 때
$$\left(1 - p(n)\right)^{q(n)} \leq 1 / n$$
이 식을 목표로 하는 것인데, $(1 - x)^{1/x}$ 의 값이 $1/e$ 이하임을 다시 이용 ($p(n) \leq 1$이므로!), $q(n)$ 을 $\frac{\log n}{p(n)}$ 번으로 잡아주면 된다는 것을 알 수 있습니다. 따라서, $q(n) = \log^2 n$ 으로 잡아주면 됩니다.

우리는 개별 시간이 $O(n^2 \log n)$ 인 수행을 $\log^2 n$번 수행하기로 결정했으므로, 전체 시간복잡도는 $O(n^2 \log^3 n)$입니다. 간단한 아이디어로 충격적인 향상을 이루었음을 볼 수 있습니다.

특히 $n^2$ 비슷한 시간이 나왔다는게 중요한데, 간선이 $n^2$ 개일 때 적어도 이 간선들을 검토는 해봐야 하므로 이 문제는 이론상 $O(n^2)$ 보다 빠를 방법이 아예 없습니다. 어렵지 않은 아이디어를 잘 이용해서 이정도까지 복잡도를 내렸다는 점에서, Randomized algorithm의 힘을 잘 보여주는 예시가 아닌가 싶습니다.

## Extension
이 알고리즘의 재밌는 extension은 $k$-cut입니다. $k$-cut이란, 노드를 $k$개의 connected component로 쪼개기 위한 min cut을 구하는 문제입니다. 우리가 지금까지 공부한 문제는 $k = 2$ 인 경우라고 생각하면 되겠습니다.

이 문제가 재미있는 이유는, 조금만 extension했을 뿐인데 미친듯이 어렵기 때문입니다. 이 문제는 $k$도 입력으로 주어지는 경우, NP-complete함이 잘 알려져 있습니다. 간단히 생각해보면, 2-cut은 적어도 s-t min cut 문제로 환원한다음 그걸 디닉으로 푸는 방법이 있었는데, 이 문제는 플로우 모델링이 아예 안 됩니다.

다양한 상황에서 approximation을 한다던가 하는 아이디어들이 연구되고 있지만, 쉽지 않습니다. Gomory-Hu tree를 쓴다던가 등등... 

Karger-Stein algorithm은 $k$-cut에 대해 굉장히 잘 대응합니다. 단순히, 최종적으로 남기는 vertex를 2개가 아닌 $k$개로 남기면 됩니다. 이 방법이 성공할 확률이 그래서 얼마인지, 복잡도가 얼마인지 등은 굉장히 어려운 문제입니다. 

Interestingly, Karger-Stein 알고리즘을 정말 잘 분석하면 $k$-cut에 대해 이 알고리즘이 optimal하다는 것을 보일 수 있다고 합니다. 이 글을 제가 쓰게 된 이유도 엊그제 이 주제 (Karger-Stein is optimal on $k$-cut) 를 다루는 세미나가 있었기 때문에 공부했던 내용을 리뷰할 겸 해서 쓰게 된 것인데요. 언젠가 저 논문을 전부 읽을 수 있을지는 사실 자신이 없습니다. 굉장히 재밌어 보이지만 증명이 Martingale을 쓰는 등 상당한 배경 지식을 요구하는 것 같아 보였습니다. 관심이 있으신 분들은 [2019년 논문 링크](https://arxiv.org/pdf/2005.08301.pdf) 가 있습니다.

별론으로, 세미나에서는 Karger 알고리즘을 랜덤하게 edge들을 순서대로 고르는 대신, 각 edge들에 exponential clock이라고 해서, essentially 각 edge에게 특정 시간에 이벤트가 일어날 확률을 부여하고 그 이벤트가 터지면 contraction해 버리는 식으로 알고리즘을 살짝 다르게 분석했습니다. 이 method가 있다는 것을 다른 곳에서 들었었는데, 처음 들었을 때는 아 그렇구나 라고만 생각했는데 이런식으로 그래프 알고리즘에 적용하면 문제를 연속적인 공간으로 끌고와서 해석적인 기법들을 이용한 분석이 가능하다는 것을 새로 배웠습니다. 

------


[^1]: Stephen Boyd, Lieven Vandenberghe, *Convex Optimization*, Chapter 4
[^2]: Sparse graph에 대해서는 Orlin 등 더 빠른 알고리즘들이 있지만, 우선은... 
[^3]: Edge contraction을 정의할때 edge가 겹치면 하나만 남기는 저자들이 있는데, 저희는 그러지 않겠습니다.
[^4]: $\left( 1 - \frac{1}{x}\right)^x \leq e^{-x}$ 가 $1/e$ 보다 작음을 이용합니다.
[^5]: 위 Karger 알고리즘의 시간 복잡도 분석에서 말한 바와 같이 Kruskal처럼 구현하면 여기에 로그가 하나 더 붙습니다만, 우리는 일단 구현을 잘해서 $O(n)$ 에 한 contraction을 처리할 수 있다고 하겠습니다!</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="advanced_algorithms" /><category term="algorithms" /><category term="graph_theory" /><summary type="html">Contents</summary></entry><entry><title type="html">UCPC 팀 해체</title><link href="http://localhost:4000/ucpc_team_broken/" rel="alternate" type="text/html" title="UCPC 팀 해체" /><published>2021-07-22T00:00:00+09:00</published><updated>2021-07-22T00:00:00+09:00</updated><id>http://localhost:4000/ucpc_team_broken</id><content type="html" xml:base="http://localhost:4000/ucpc_team_broken/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

이번 UCPC는 개인 신청 후 팀 신청을 따로 해야 하는데, 이 과정을 3명 모두가 동시에 잊고 있었던 어처구니없는 이유로 UCPC에 참여하지 못하게 되었습니다.  

주최측에 메일을 보내 보기도 했고, 여러가지 방법으로 contact를 시도해 보았으나 원칙적으로 불가하다는 답변을 받았습니다.  

처음에는 솔직히 조금 받아들이지 못하기도 했습니다. 개인신청을 진행하기도 했으니 어떻게든 추가로 등록이 되지 않을까 하는 생각도 했었던 것 같습니다. 
그래서인지, 전대프연측에 보낸 메일을 쓰면서 솔직히 깊게 생각하지 못하고, 감정적으로 대처한 부분도 있지 않나 싶습니다. 여기를 보실 확률은 매우 낮지만 진심으로 죄송하게 생각하고, 언젠가 이부분은 정리가 되고나면 개인적으로라도 꼭 연락을 드리려 합니다.

저희가 잊고 있었던 탓이니 누구를 탓할수 있는것도 아니고... 그냥 좀 허탈하네요. 원래는 PS에 대한 동력도 확 잃었었는데, SCPC도 있고, 올해 ICPC도 있으니 나름대로 동력을 잃지 않고 해보려고 합니다. 

여튼 굉장히 기대했던 UCPC 팀은 여기까지로 마무리하게 되었습니다. 올해가 마지막 UCPC 참가가 되었던 `gyuni`님께 특히 죄송한 마음입니다. 팀연습하고 디스커션하고 정말 재밌게 했는데 이렇게되어 너무 아쉽네요. 

멘탈이 돌아온다면 이 멤버로 Open contest라도 돌 수 있을지도 모르겠습니다. 지금은 UCPC는 약간 의도적으로라도 어떻게 더 생각하지 않아 보려고 합니다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><summary type="html">Contents</summary></entry><entry><title type="html">7월 3주차 Weekly PS</title><link href="http://localhost:4000/ps_weekly/ps-weekly-21Jul3/" rel="alternate" type="text/html" title="7월 3주차 Weekly PS" /><published>2021-07-18T00:00:00+09:00</published><updated>2021-07-18T00:00:00+09:00</updated><id>http://localhost:4000/ps_weekly/ps-weekly-21Jul3</id><content type="html" xml:base="http://localhost:4000/ps_weekly/ps-weekly-21Jul3/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------


July 11 - July 18, 2021

이 글에 구현코드 링크가 없더라도 [PS 레포 링크](https://github.com/gratus907/Gratus_PS) 에 가서 대회 단위로 들어가면 보통 제가 올려놓은 코드를 볼 수 있습니다. 

## Recent Updates 
- 2021 SCPC 라운드 1은 뭐 무난히 통과했습니다. 

## Rounds 
### (팀연습) 서강대학교 2020 SPC Div.1 (Champion)
- [포스팅 링크](/cp_practice/team_practice_1/) 에 포스팅했습니다.
  
### (대회) SCPC 2021 Round 1
- [포스팅 링크](/cp_rounds/SCPC-2021-Round1/) 에 포스팅했습니다.
  
### (Atcoder) Atcoder Beginner Round 210
- [라운드 링크](https://atcoder.jp/contests/abc210/tasks)
- 582등, -9 (1844 -&gt; 1835).
- D번 DP문제를 못 풀어서 레이팅을 좀 깎아먹었습니다. 대신 E번 (수학..이라긴 좀 애매하고 잘 모르겠습니다) 을 풀어서 본전은 친듯 합니다.

## Problems
이번에는 DP 연습을 하기로 했습니다. 백준 번호를 적어놨으므로 문제설명은 가급적 생략합니다.

------

### IOI 2009-4, Raisins (BOJ 5463 건포도)
- 난이도 Gold 1
- IOI에 이런 문제가 나온적 있는지는 몰랐습니다. 무슨 20세기 대회도 아니고 2009년에..?
- 거의 straightforward한 DP로 해결이 가능합니다.
  - `dp[r1][c1][r2][c2]` 를 직접 $[r1, c1] \times [r2, c2]$ 사각형의 DP값이라고 정의하면, 
  - 이제 이 값은 모든 가로/세로 컷을 직접 확인하면 됩니다.
  - 구현 코드 가 상당히 간단하므로 확인하면 도움이 될것 같습니다. 레포에서 IOI를 찾아가면 됩니다.
- 시간 복잡도는 $O(n^4)$ 칸 DP를 칸당 $O(n)$ 시간에 채우는 것이므로 $O(n^5)$ 입니다.

------

### 서강대학교 SPC 2015-1F, 몬스터 (BOJ 11573)
- 난이도 Gold 1
- 마찬가지로 `dp[i][j][k]` 를 빨간색 노란색 파란색이 $i, j, k$ 마리 남은 상황이라고 생각하면 됩니다.
- 이때, Random choice에 의해 빨간색과 노란색이 만날 확률은 $\frac{ij}{ij + jk + ki}$ 입니다.
- 이렇게 각 state transition의 확률을 구해서, 확률을 탑다운 DP로 찾아주면 됩니다.
- 어떤 특정 종의 몬스터가 아예 없어지면 두 종류 중에는 항상 이기는 쪽이 정해져 있으므로 확률이 (1, 0, 0) 형태로 나옵니다. 이를 베이스 케이스로 쓰면 됩니다.
- 대칭성을 잘 이용하면 $n^3$ 개의 실수값만으로 계산할수 있는것 같은데, 저는 $p_1, p_2, p_3$ 을 struct로 묶어서 돌렸습니다.

------

### 연세대학교 2018-C 나무 위의 입자 (BOJ 15669)
- 난이도 Platinum 5
- 정점 U, V에 대해, 편의상 `depth(u) &lt; depth(v)` 라고 합시다.
- 이때, `v`의 '위에서' 하나, '아래서' 하나를 골라서 그 거리가 홀수/짝수가 되는 정점쌍 개수를 세는 문제입니다.
  - 가장 쉬운 방법은, `dp[i]` 에 `i`를 루트로 하는 서브트리에서 깊이가 홀수/짝수인 점의 개수를 미리 세 놓고
  - 거리가 짝수이려면 `v` 아래 서브트리에서 짝수 깊이, `v` 아래가 아닌 곳에서 짝수 깊이
  - 또는 둘다 홀수 깊이인 노드들의 개수의 곱입니다.
- 역시 코드가 조금더 보기 쉬운 문제입니다. 모든 정보는 DFS를 돌리면서 Tree DP 할 수 있어서 $O(n)$ 에 해결 가능합니다. 
  
------

### 연세대학교 2018-L 연세워터파크 (BOJ 15678)
- 난이도 Platinum 5
- 핵심은 $D_i = \max_{i - d \leq j &lt; i} (D_j + A_i)$ 라는 DP식이고,
- 이 식에서 $A_i$는 이미 정해져 있으므로 $[i - d, i)$ 구간의 최댓값을 빨리 구할수 있으면 됩니다.
- Deque DP Optimization이라는 방법을 적용하는 기본 연습문제입니다. 이 방법은 언젠가 따로 소개하겠습니다. 
- $n$ 이 작아서 세그먼트 트리로 $O(n \log n)$ 에도 풀 수 있습니다.

------


### IOI 2002-4, Batch Scheduling (BOJ 5498)
- 난이도 Platinum 3
- 지문이 굉장히 이해하기 어렵습니다.
- `T` 의 부분합을 `TS`, `F`의 부분합을 `FS` 라고 생각하겠습니다.
- 뒤에서부터 역순으로 Batch를 만들면서 오는 식으로 생각합니다.
  - Batch 블록 하나가 `i, i+1, ... j` 구간을 커버한다면, `t + s + (TS[j] - TS[i-1])` 에 `(FS[j] - FS[i-1])` 에 곱해야 하는데, 각 블록의 시작점 `t`를 도저히 계산할 방법이 없습니다.
- 이 문제를 해결하기 위해, 앞 블록에서의 소모 시간을 뒷 블록에 계속 더해 주는 식으로, `(s + (TS[j] - TS[i-1])) * (FS[n] - FS[i-1])` 로 계산해서 더해주면 모든 블록을 더했을때 결과가 같습니다.
- 따라서 다음 DP식을 생각합니다. 
  $$D_i = \min_{i \leq j} (D_j + (s + TS_{j} - TS_{i-1}) (FS_{n} - FS_{i-1}))$$
  이 식은 그냥 계산하면 $O(n^2)$ 라서, 더 줄이고 싶습니다.
- 여기서, $j$와 무관한 항을 다 min 밖으로 빼서 정리하면, $D_j + TS_{j} \times u_i$ 들의 minimum을 빠르게 계산하는 문제가 됩니다 ($u_i$는 $i$에 의해 결정되는 상수값)
  - 이러한 DP를 Convex Hull Trick으로 빠르게 처리할 수 있음이 알려져 있습니다. $TS_{j}$의 성질을 매우 잘 이용해서 스택에 잘 왔다갔다하는 $O(n)$ 풀이도 가능하고...
  - Li-Chao Tree같은 놀라운 (이제 리차오는 별로 놀라운까지는 아닙니다) 자료구조를 박으면 $O(n \log n)$ 에 풀 수 있습니다.
  - Li-Chao Tree에 대해서는 [kjp4155님의 소멤 글](http://www.secmem.org/blog/2019/01/03/lichao-tree/) 이 잘 알려져 있고, 무지성 복붙 가능한 최고의 코드입니다.
  - ICPC에도 몇번 나온 자료구조인만큼 하나 가지고 있으면 좋을듯 합니다
- 이와는 별론으로, 이 문제는 무려 20년 전의 문제라서 $O(n)$ 이 정해이면서 ($n \log n$ 까지는 허용했고) $n$이 1만밖에 안 됩니다. 요즘에 나온다면 500만이나 최소 100만으로 내지 않았을까요? 500만 리차오는 불가능할거고, 100만 리차오는 잘 모르겠습니다. 
- 슬프게도, 이것 때문에 $O(n^2)$의 나이브한 DP가 100ms대로 통과합니다. 세월의 흐름이 느껴지기도 하면서, 동시에 만약 지금보다 컴퓨터가 다시 10배 빨라져서 지금 $O(n^2)$ 가 안 뚫리는 문제들이 다 뚫리게 되면 기존 문제들을 온라인저지 상에서 리마스터할 필요가 있을수도 있겠다, 하는 (저와는 별로 상관없는 일이지만) 생각도 들게 하네요.

------

### JOI 2009-4 散歩 (BOJ 5573 산책)
- 난이도 Platinum 4
- 이번주에 제가 포스팅하는 문제중 가장 어려웠습니다. 
- $N-1$ 번째의 보드 상태를 알고 있다면, $N$번째는 직접 시뮬레이션해서 도착할 수 있습니다.
- 특정 칸에 지금까지 도달한 횟수를 안다면, 그 칸의 상태를 알 수 있습니다.
- $(1, 1)$ 을 밟는 횟수는 $N-1$번입니다.
- 어떤 칸을 밟는 횟수가 $K$번이면, 계속 오른쪽과 아래가 왔다갔다하므로 그중 절반은 오른쪽으로, 절반은 아래로 내려가게 됩니다. 
  - 단, $K$가 홀수이면 0번째에 어느 방향이었는지를 보고 한번 더가면 됩니다.
  - 즉, `dp[i][j+1], dp[i+1][j]` 에 `dp[i][j]/2` 를 (필요하다면 1만큼 더) 더해주면 됩니다.
- 이 아이디어가 굉장히 떠올리기 힘들었습니다. 역시 DP는 어렵네요.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ps_weekly" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">삼성 SCPC 예선 1라운드 풀이 / 후기</title><link href="http://localhost:4000/cp_rounds/SCPC-2021-Round1/" rel="alternate" type="text/html" title="삼성 SCPC 예선 1라운드 풀이 / 후기" /><published>2021-07-16T00:00:00+09:00</published><updated>2021-07-16T00:00:00+09:00</updated><id>http://localhost:4000/cp_rounds/SCPC-2021-Round1</id><content type="html" xml:base="http://localhost:4000/cp_rounds/SCPC-2021-Round1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

# SCPC
SCPC는 삼성전자 (정확히는 Samsung Research) 가 주관하는 알고리즘 문제풀이 대회로, 한국에서 열리는 기업 대회중 가장 큰 규모를 자랑하는 대회입니다. 한국의 코드잼이라고나 할까요.

ICPC, UCPC 등 팀대회와는 달리 개인전이고, 예선 1라운드 - 예선 2라운드 - 본선으로 구성됩니다.

예선 1라운드는 24시간, 예선 2라운드는 12시간이라는 엄청난 시간이 주어지고 지구력을 강하게 요구합니다. 또한 제출 기회가 10번(문제에 따라 20번)으로 제한되어 있다는 점도 특징입니다.

참고로, 2020년 대회는 예선 1라운드를 통과하고 2라운드를 멋지게 말아먹었습니다. 저는 부분점수 시스템을 탓하기로 했습니다만 작년 대회 문제를 다시 stress-test 해보니 꼭 그렇지는 않은 모양입니다. 작년 대회에 대한 (감정이 많이 실린) 후기는 [여기](https://gratus-blog.tistory.com/121) 에 적혀 있습니다. 

작년에는 1차 예선 5번을 해결하지 못했지만, 올해는 시작 약 4시간 만에 모든 문제에서 만점을 받을 수 있었습니다. 올해의 구현 코드 링크는 [여기](https://github.com/gratus907/Gratus_PS/tree/master/Contests/Others/%5BSamsung%5D%20SCPC/2021/Round%201) 에 있습니다.

![picture 1](../../images/1884fd79ae1d82e347df360ba2645a98a53fe3170016d0cd18a3e88a4a4dfdd5.png)  

# 문제 풀이 / 후기 
시간복잡도에 대한 모든 언급은 테스트케이스 한개당 복잡도입니다.

구현체를 업로드하긴 하곘지만, 대회중 구현한 코드라서 굉장히 바보같은 실수와 redundant한 구현이 있습니다.  
코드를 정리해서 쓰지 않고 incremental하게 생각해서 그런데, codeground에 연습이 올라오면 정리를 해볼지도 모르겠습니다. 현재 코드가 라운드 중 제 생각의 과정을 그대로 반영해서 오히려 이런 글에 더 적절하다는 생각도 듭니다. 
## Problem 1. 친구들 
### 문제설명
- $i$ 번 사람이 $i + D_i$ 번과 친구이고, 친구관계가 equivalence relation을 이룰 때, 친구 관계인 극대 그룹의 개수를 출력하는 문제입니다.
- 극대 그룹이란 &quot;현재 이 그룹 안에서 뽑은 임의의 2명이 서로 친구이면서&quot;, &quot;이 성질을 깨지 않고 이 그룹에 누군가를 추가할 수 없음&quot; 을 말합니다.
 
### 풀이 (Disjoint Set)
- 즉, equivalence class의 개수를 세는 문제입니다.
- Disjoint Set Union (DSU) 또는 Union Find (UF) 라고 알려진 자료구조를 써서 쉽게 구현할 수 있습니다.
- DSU의 구현체와 마지막에 개수를 어떻게 세느냐에 따라 $O(n \log^* n)$ 에도 풀 수 있지만, 저는 그냥 평범하게 merge by size &amp; path compression을 쓰고 set을 써서 $O(n \log n)$ 으로 구현했습니다. 단 한번도 UF가 느려서 문제가 생기는걸 본적이 없습니다. 
- 대략 8분 정도 만에 AC를 받았던것 같습니다. 어떤 대회든 시작하면 순간 심박수가 확 높아지는 제 심각한 단점에 의해 필요 이상으로 힘들었습니다.
 
## Problem 2. 이진수
### 문제설명
- N비트 비트열 $A$로부터 $B$를 다음과 같이 만듭니다.
- `B[i] = A[i - t] || A[i + t]` (단, 인덱스가 1 - N 범위를 벗어나면 무시) 
- B가 주어질 때, A를 복원하는 문제입니다. 가능한 A가 여러가지이므로 이진수로 볼 때 가장 작은 - 즉, 사전순으로 가장 앞서는 답을 출력해야 합니다.

### 풀이 (Greedy)
- 사전순이라는 조건 때문에, 앞비트를 0으로 만들 수 있다면 무조건 0으로 만들어야 합니다. 따라서, 최대한 앞비트에 0이 많이 오게 Greedy하게 풀면 됩니다.
- 주의할 점은, $B_i$가 0이면 $A_{i - t}$ 와 $A_{i + t}$ 가 무조건 0이어야 하므로, 어떤 $A_j$ 들은 0으로 고정당합니다. 이것 때문에 앞과 뒤 중 앞을 1로 만들어야만 하는 (사전순으로는 뒤를 1로 만들고 싶겠지만) 상황들이 발생합니다. 
- 저는 `fix` 라는 배열을 관리하고, `fix` 배열에 True가 켜져 있으면 손을 못댄다고 생각하는 방식으로 구현했습니다. 
- 대략 30분 정도 만에 AC를 받았습니다. fix를 생각하지 않고 그리디하게 했다가 뭔가 답이 안나와서 잠깐 고민했고, 버퍼 이슈 때문에 한번 TLE를 받았습니다. 

## Problem 3. No Cycle
### 문제설명 
- Directed Acyclic Graph $G$와, 방향이 정해지지 않은 간선들이 주어집니다.
- 간선들에 정방향 (입력방향) 또는 역방향 (입력 반대방향) 을 줍니다. (각각을 0과 1로 표시)
- 목표는 방향을 다 정해서, 결과 그래프가 여전히 Acyclic하게 만드는 것입니다. 당연히 여러 개의 답이 있는 경우들이 있으며, 이런 경우에는 간선들을 0 1 로 표시했을 때 사전순으로 가장 앞서는 답을 출력합니다.

### 풀이 (Greedy + Graph)
- Subtask 1은 간선개수 10개, 정점개수 10개이므로 $2^{10}$가지 경우의 수를 확인하는 풀이가 가능합니다. 이걸로 41 / 180점을 받습니다.
- 사전순을 일단 생각하지 말고, 사이클 없는 간선 방향 정하기만 생각해 봅시다. 여기까지는 굉장히 많이 알려진 문제이며, 주어진 DAG를 Topological sorting한 다음 Topological order를 기준으로 간선을 앞 -&gt; 뒤로 모두 정해버리면 사이클이 발생하지 않습니다. 임의의 Directed Graph가 주어졌을때 사이클이 있는지 확인하는 방법 중, 위상정렬하고 back edge가 있는지 보는 방법이 있음을 알고 있다면 이 방법은 쉽게 떠올릴 수 있습니다. 제가 PS를 처음 시작하고 얼마 안되어 codeforces에 이 문제가 한번 나왔는데 한참 생각해서 풀고 기분이 꽤 좋았던 기억이 있습니다. 
- 여기까지, Subtask 2를 해결할 수 있으며, 52 / 180점을 받습니다. 서브태스크 1과 함께하면 93 / 180점입니다.
- 문제 전체를 해결하기 위해서는 조금더 잘 생각해볼 필요가 있습니다. 먼저, 사전순 조건 때문에 만약 가능하다면 항상 앞간선에 0번방향을 부여하고 싶다는 사실을 기억합시다.
- $n \times n$ 의 비트 행렬 `R` 이라는걸 생각하겠습니다. `R[i][j]` 는, $i$ 에서 $j$로 가는 경로가 있음을 의미합니다.
- $(u, v)$ 간선의 방향을 정하는데, `R[v][u]` 가 True이면 $u \to v$ 방향으로 간선을 줄 수 없습니다.
- 그렇지 않다면, $u \to v$ 방향으로 간선을 줄 수 있으므로 주어야 합니다.
- 이제, 간선을 추가했다면 `R` 행렬을 업데이트해야 합니다. `R` 행렬을 업데이트하는 것은 
  - $u$ 에 도달 가능한 모든 정점 $i$에 대해, 즉 `R[i][u]` 가 참인 모든 $i$에 대해
  - `R[i][j]` 에 $i \to u \to v \to j$ 경로의 존재성을 반영합니다. 즉, `R[i][j] |= R[v][j]` 를 해줘야 합니다.
- 따라서, 각 간선을 볼때마다 최대 $O(n^2)$ 칸의 `R` 행렬을 업데이트해야 하기 때문에, $O(n^2 k)$ 알고리즘이 됩니다.
- $n = 500, k = 2000$ 이므로, 이 시간은 기분이 몹시 나쁩니다. $500 \times 500 \times 2000$ 짜리 테스트케이스 한개면 모를까, 그걸 70개 해결할 수는 없어 보입니다.
- `R` 행렬을 `std::bitset` 으로 관리하면, 시간복잡도는 줄어들지 않지만 비트연산을 묶어서 처리함으로써 64배 빨라집니다. 이를 이용하여, $O(n^2 k)$ 알고리즘을 시간내에 구겨넣을 수 있습니다.
- bitset을 쓰는 추한 풀이가 싫다면, 매번 간선을 추가할때마다 간선을 0-방향으로 추가해보고 사이클이 있는지 검증하고, 1-방향으로 추가해보는 식으로 $O(nk)$ 에도 풀 수 있다고 합니다. 어떻게 이걸 생각을 못했지????? 이건 라운드가 끝나고 `dhdroid`랑 디스커션하다가 알았고, bitset을 쓰는 추한 풀이로 욕을 먹었습니다. ㅎㅎ;;
- `R` 행렬을 처음에 바보같이 DFS로 계산하는 과정에서 실수를 해서, 이문제 AC를 받는데 무려 1시간 30분 정도가 걸렸습니다. (1시간 58분 AC) 중간에 혹시 못풀수도 있겠다는 공포에 52점을 먹는 등 (22.5시간이 남았음에도...) 24시간 대회는 대회 전략을 고려하지 않고 편한 마음으로 PS를 해야하는데 제가 그게 좀 안 됩니다. 작년 2차 3번의 악몽때문에 제출 기회 제한을 두려워하는 것도 좀 있습니다. 중간에 4번을 좀 생각하다가 돌아와서, 4번은 좀 빨리 풀었습니다.

## Problem 4. 예약 시스템
### 문제설명 
- $2$행 $m$열로 방들이 있고, 같은 열의 위아래 행들과 같은 행의 양 옆 열들을 '인접' 하다고 정의합니다.
- 사람 $2m$ 명이 각각 스트레스 지수를 가지고 있고, $n$개 그룹으로 나뉘어 있습니다.
- 인접한 방에 다른 그룹의 사람을 배치하면, 그 두 방에 들어간 사람의 스트레스 지수 합만큼 페널티가 발생합니다.
- 이를 최소화하는 방 배치를 찾고자 합니다. 
- 재밌게도, 각 그룹은 5명 이상이라는 조건이 있습니다. 이 조건이 없으면 문제가 정말 끔찍할 것입니다. 

### 풀이 (Greedy + Casework)
- 어렵지만 재밌었습니다. 먼저, 그룹 $i$의 사람 숫자가 실제로 몇명인지보다는 홀수인지 짝수인지가 중요함을 관찰합니다. 
- 왜냐면, 어차피 같은 그룹의 사람들끼리 붙여주면 그 벽에서는 페널티가 발생하지 않고, 페널티가 발생하는 경우는 아래 케이스들밖에 없기 때문입니다. 

![picture 1](../../images/132e43e2b169d80f9b5245bff9986d0214096cfa2e192ee741ef2c06cb2d20bd.png)  

- 잘 관찰해 보면, 홀수 블록이든 짝수 블록이든 끝 4명정도만 중요합니다. 대신 홀수블록이 포함된 연산에서는 2번 페널티를 일으키는 사람이 있게 됩니다.
- 또한, 가장자리 블록은 스트레스를 덜 발생시킵니다.
- 홀수 블록과 짝수 블록에 대해 다음을 계산합니다. 각 블록의 스트레스 지수가 작은 사람부터 정렬했다고 합시다.
  - **(홀수 블록)** `l3 = 2 * s[0] + s[1]` 은 가장자리 홀수 블록이 다른 홀수 블록과 만날때 스트레스 값입니다.
  - **(홀수 블록)** `l5 = 2 * s[0] + s[1] + s[2] + s[3]` 은 가장자리가 아닌 홀수 블록이 한쪽으로 다른 홀수 블록과, 다른 쪽으로 짝수 블록과 만날때 스트레스 값입니다.
  - **(짝수 블록)** `l2 = s[0] + s[1]` 은 가장자리 짝수 블록이 다른 짝수 블록과 만날때 스트레스 값입니다.
  - **(짝수 블록)** `l4 = s[0] + s[1] + s[2] + s[3]` 은 가장자리가 아닌 짝수 블록이 좌우로 다른 짝수 블록과 만날때 스트레스 값입니다.
  - **(짝수 블록)** `l6 = 2 * s[0] + 2 * s[1] + s[2] + s[3]` 은 가장자리가 아닌 짝수 블록이 좌우로 홀수 블록과 만날때 스트레스 값입니다. 
- 서브태스크 1, 모든 그룹이 짝수명일 때는 가장자리 두 블록은 `l2`, 나머지 블록들은 `l4` 만큼 스트레스를 발생시킵니다. 따라서, 모든 블록의 `l4` 를 더한 다음, `l2 - l4` 값이 가장 작은 두 블록에 대해서만 `l4`를 `l2`로 바꿔치기하면 됩니다.
- 서브태스크 2, 모든 그룹이 홀수명일 때도 거의 똑같습니다. 다만 이때는 `l5`와 `l3`이 됩니다. 
- 여기까지 해서 88 / 190점을 받을 수 있습니다.
- 이제, 다시 경우를 나눕니다. 여기서 하나 의문을 가질만한 것은, `l6` 이 어떨때 필요한지 생각하는 것입니다. 
  - (홀수, 짝수 블록 여러개, 홀수) 블록이 있는데, 이 블록들이 가장자리가 아닌 곳에 배치한다면, `l5 + l6 + l6 + l6 + ... + l5` 가 될 것입니다. (각 블록의 `l5, l6` 값을 보고 있으므로 `l6 + l6` 이 같은 `l6`이 아니라, 각 블록의 `l6`-값을 의미합니다)
  - 그런데, (홀수, 홀수, 짝수....) 로 배치를 바꾸면, `l5 + l5 + l4 + l4 + .... + l4` 를 지불하게 됩니다. 따라서, '가장자리 이득' 을 보고 싶은 상황이 아니라면 `l6`은 아예 필요가 없습니다.
  - 같은 방법으로 (벽, 홀수, 짝수, 짝수, ... 홀수) 를 분석하면, 이것도 이득이 없습니다. 
  - `l6`이 말이 되는 유일한 상황은, (벽, 홀수, 짝수, 짝수, ...., 홀수, 벽) 인 상황입니다. 
  - 또한, (홀수, 짝수, 짝수, ..., 홀수, 홀수, 짝수, 짝수, ... 홀수) 도 잘 분석해 보면 홀수블록들끼리 묶어주는게 이득임을 알 수 있기 때문에, 경우의 수를 잘 나누면 `l6`이 말이 되는 유일한 상황은 위 상황에 추가로 홀수가 벽에 붙은 저 두개밖에 없어야 함을 압니다.
  직관적으로 홀수블록의 세번째, 네번째 사람 스트레스값이 너무 커서 이 사람들한테 벽에 붙은 방을 주는게 갈등의 절대적인 개수를 줄이는 것보다 이득이라고 생각하면 됩니다.
  - 따라서, 이 경우는 별도로 계산합니다. 홀수 블록 두개의 l3와 나머지의 l6을 더하는 경우가 되겠습니다.
  - 이외에는, 한쪽 벽에 (홀수, 홀수) 블록이 박히는 경우를 생각해 줘야 합니다. 이것도 l3, l5 더하고 나머지는 다 l4를 더하다가 맨 오른쪽 끝 블록에서는 l2를 더하는 것이므로, 어렵지 않게 계산 가능합니다.
- 홀수블록이 2개보다 많이 있다고 가정합시다. 이제, `l6`은 아예 생각할 필요가 없습니다.
- 홀수블록은 가장자리에 들어가면 `l3`, 그외에는 모두 `l5`의 스트레스를, 짝수블록은 각각 `l2` 와 `l4` 를 발생시킵니다.
- 따라서, `l5` 와 `l4` 들을 모두 더해주고, `l3` 나 `l2` 로 바꿀 수 있는 기회를 두번 준다고 이해하면 됩니다. 이건 struct에 점수를 계산하는 함수를 몇개 구현하면 정말 이쁘게 구현할수 있습니다. 
- 말하는것보다 코드를 보면 조금더 이해가 쉽습니다.
- 대략 1시간 정도 걸려서, 3시간 02분 시점에 AC를 받았습니다. `l6`을 고려하지 못해서 2번 틀렸고, 단순 코딩 실수로 1번 틀렸습니다. 

## Problem 5
### 문제 설명
- 두가지 쿼리가 주어집니다. `1 i j k` 쿼리는, $X_i - X_j = k$ 임을 의미합니다. `2 i j` 쿼리는 $X_i - X_j$ 값을 묻습니다.
- 1번쿼리로 주어진 상대적인 정보만을 가지고 2번쿼리의 값을 계산할 수 있다면 계산하고, 계산하지 못한다면 '비교 불가능'을 출력합니다.
- 단, 1번 쿼리가 inconsistent하게 주어질 수 있습니다. 만약 2번쿼리가 들어왔는데 $X_i - X_j$가 여러 가지가 가능해서 계산이 불가능하다면 이를 출력합니다.

### 풀이 (DSU-based)
- 의도한 것인지 알 수 없으나, 백준에 대단히 비슷한 문제가 있습니다. [3830번](https://www.acmicpc.net/problem/3830) 입니다.
- 3830번과 이 문제의 차이는 Inconsistency의 유무밖에 없습니다. 그 외에는 모든점에서 동일합니다.
- 3830번은 Platinum III 이긴 하지만, 비교적 많이 풀린 문제이므로 구글링해보면 솔루션은 많이 있습니다. 다시 설명하기는 너무 기니까 대충 요약하자면, DSU를 쓰되, DSU에 추가하면서 이 노드와 이 노드가 포함된 집합의 루트와의 차를 기억하면서 DSU를 쓰면 됩니다.
- 이 코드로 서브태스크 1, 3 (inconsistency 없음) 을 쉽게 풀 수 있습니다.
- 이제, Inconsistency를 생각해 봅시다. 만약 현재 $x_1, x_2, x_3$ 에 대해 $x_1$ 을 0이라고 할 때 relatively $x_2 = 3, x_3 = 2, x_4 = 6$ 이라는 정보가 있다고 합시다.
  - $x_2 - x_3 = 1$ 이라는 정보가 주어지면 무시하면 됩니다.
  - 만약, $x_2 - x_3 = 2$ 와 같이 틀린 정보가 주어지면, $x_2$의 relative한 값을 이제 알 수 없게 됩니다.
  - 재밌는 사실은, 아무 상관 없어 보이는 $x_4$ 도 미지의 값이 된다는 점입니다. 그 이유는, $x_3$ 이 ?가 된 상황에서 위 정보로부터 $x_4 - x_3 = 4$ 와 같은 정보도 implicit하게 주어져 있다고 가정해야 하기 때문입니다. 
  - 따라서, ?와의 차이를 계산당하는 과정에서 $x_1$을 루트로 하는 트리 전체가 ?가 되어 버립니다.
- 그러므로 DSU를 하면서, 루트와의 차이 뿐 아니라 이 노드가 이미 망했는지 여부까지 같이 들고 다니면 됩니다. 모든 노드에 망했다는 정보를 뿌리기에는 시간이 너무 많이 들기 때문에, 루트에만 저장해 놓고 '이 트리가 통째로 망했다' 라고 기억하면 됩니다. 저는 DSU에서 생각하다가 살짝 꼬여서 find하면서도 정보를 갱신하게 해놨는데 아마 필요 없는 것 같습니다. 
- 3830을 풀어봤기때문에 1시간 정도 걸려서 4시간 쯤에 AC를 받았습니다. 

### 후기
- 작년 1차보다는 문제가 많이 쉽다고 느껴졌습니다. 특히 후반 문제가 많이 쉬워졌습니다. 작년에는 1차 예선 4번에 금광세그가 출제되고, 5번문제가 충격적으로 어려워서 오전 9시에 시작한 대회가 저녁시간까지 5번 만점자가 한자리수, 4번이 30여명 정도밖에 없었던 기억이 있습니다. 작년에 비해 대회 4시간 만에 4번, 5번 만점자가 40여명 나왔네요. 
- 작년에는 2번부터 DP를 prefix sum으로 최적화하는 등 '시간 복잡도를 낮추기 위한 아이디어' 를 요구했었습니다. 그에 비하면 이번 2번은 그냥 그리디인것도 차이가 명확해 보입니다. 
- 저는 체감상 4번이 5번보다 어려웠습니다. 실제 만점자수도 현재 (대회 절반 시점) 127 : 79인데, 보통 4번을 먼저 읽을 것임을 고려할때 이정도면 4번이 5번보다 어렵다고 느낄만한 여지도 충분하다고 생각합니다. 3번과 4번의 차이도 1.5배밖에 안 나네요. 
- 재밌었습니다. 다만... 2차를 통과할 수 있을지는 솔직히 자신은 별로 없습니다. 반반 정도 봅니다.


## 부록 : 버퍼 이야기 (SCPC 주의사항)
- 주의 : 제 컴퓨터구조/시스템 프로그래밍 실력은 매우 미약하기 때문에 올바르지 않은 주장이나 사실이 있을 수 있습니다. 건설적인 피드백을 200% 환영합니다.
- SCPC의 부분점수 시스템은 굉장히 특이합니다.
- 구체적으로, 문제가 모두 multi-testcase 형으로, 처음에 testcase의 개수 T를 받고 T개의 TC를 해결하는 식입니다. 예를 들어, TC i의 답이 i라고 하면, 다음과 같이 출력합니다.
```text
Case #1
1
Case #2
2
....
```
- 서브태스크 1, 2, 3이 있고, 각각이 TC 10개 씩이라면, 1~10, 11~20, 21~30 이런 식입니다.
- 그래서, 23번 TC가 틀리고 그 전까지 다 맞았다면 서브태스크 1과 2의 점수를 받습니다.
- 여기서 시간 초과가 발생하는 상황을 생각해 보겠습니다. 예를 들어 23번 테스트케이스를 수행하다가 시간 초과가 났습니다. 우리의 직관은 23번 TC가 WA인것과 TLE인 것이 동치이므로, 역시 서브태스크 2에 대한 점수를 받을 것으로 예측할 것입니다.
- 하지만, C언어의 출력은 Buffered I/O이기 때문에, (어떤 이유로든) 17번 TC까지는 출력이 되었지만 18~22번 TC까지의 결과는 아직 버퍼에 들어 있을 수도 있습니다. 즉, &quot;현재까지의 출력&quot; 은 17번 TC까지의 정답을 가지고 있고, &quot;버퍼&quot; 가 18번~22번 TC까지의 정답을 가지고 있는데 TLE가 났으면, SCPC는 버퍼에 든 내용물을 무시하고 17번 TC까지 맞은것으로 간주, 서브태스크 1에 대한 점수만 받을 수 있습니다.
- 이러한 문제를 해결하기 위해, SCPC는 printf를 이용하는 경우 `setbuf(stdout, NULL)` 할 것을 권하고 있습니다.
- 재밌는 사실은, 저걸 하면 매 printf마다 버퍼를 비우기 때문에, printf할 내용이 많으면 조심해야 합니다. 예를 들어, 5만글자짜리 string을 하나의 string으로 묶어서 출력하는 것에 비해, `printf` 를 5만번 호출하는 경우 후자는 버퍼를 5만번 처리하기 때문에 후자는 미친듯이 느립니다.
- 예를 들어, 오늘 2번(이진수) 의 제 코드 중, 이 부분은 시간 초과를 받습니다 ($n$ 은 5만입니다)
```cpp 
for (int i = 1; i &lt;= n; i++) {
    printf(&quot;%c&quot;,A[i]?'1':'0');
}
printf(&quot;\n&quot;);
```
- 하지만, 이 부분을 이렇게 바꾸면 매우 넉넉하게 통과합니다.
```cpp
string str;
for (int i = 1; i &lt;= n; i++) {
    str.push_back(A[i]?'1':'0');
}
printf(&quot;%s\n&quot;,str.c_str());
```
- 사실 printf를 5만번 호출하면 원래 한번에 찍는것보다 느린게 맞습니다. 그러나, 버퍼를 매번 비우도록 강제하는 setbuf 때문에 원래 느려야 할 것보다 더 많이 느립니다. 
- 결과적으로, 부분점수를 받기 위해서는 코드가 더 느려질 위험을 감수해야 합니다. 특히 출력물이 10만줄씩 되는 5번문제 같은 경우, '원래 맞을 수 있는 코드를 버퍼 비우다가 TLE나는게 아닌지' 도 고민해야 합니다. 
- 이런 방법으로 채점을 하는 장점에 대해서는 전혀 알지 못합니다. 구글 코드잼도 출력 양식이 거의 같은데, 내부적으로 같은 방법으로 채점하고 있는지도 모릅니다. 다만 이 방법이 절대적인 프로그램의 실행 횟수를 줄여서 채점 속도에는 조금 도움이 될 것 같습니다.
- 여튼, 작년에도 저는 SCPC 2차예선에서 저걸로 한번 당했습니다. 올해도 어김없이 이 이슈로 한번 틀렸기 때문에, 조심해야 할 부분을 같이 공유해보고 싶었습니다.
- 채점이 특이한 대회는 사실 이거 말고도 꽤 있습니다. 대표적으로 해커컵...</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp_rounds" /><category term="algorithms" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1</title><link href="http://localhost:4000/cp_practice/team_practice_1/" rel="alternate" type="text/html" title="2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1" /><published>2021-07-14T00:00:00+09:00</published><updated>2021-07-14T00:00:00+09:00</updated><id>http://localhost:4000/cp_practice/team_practice_1</id><content type="html" xml:base="http://localhost:4000/cp_practice/team_practice_1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

## Our Team
이번 UCPC 팀은 이렇게 구성되게 되었습니다. 
- `gyuni` : DGIST에서 석사과정을 올 8월에 마무리하고 졸업합니다. ICPC는 석사 1년차까지, UCPC는 석사과정 (석박통합 2년차까지) 임을 감안하면 사실상 이번 UCPC가 대학생 프로그래밍 대회의 마지막을 장식하게 될 것인지라, 저 개인적으로 매우 영광으로 생각하고 있습니다.
- `dlwocks31` : 병특 중에 있습니다. 제 블로그에도 여러번 언급되었지만... 해시코드를 함께하고 있는 Little Piplup 팀으로, 둘이서 1:1 연습을 많이 해봤습니다만 전통적인 CP대회를 같이뛰는건 처음입니다.
- `gratus907`

세명의 Codeforces max rating은 2100+지만, 저랑 dlwocks는 파킹에 실패해서 퍼플로 낙하했습니다. 퍼플+퍼플+오렌지 팀 정도로 볼 수 있을것 같습니다.

전력을 잠깐 생각해 보자면, `gyuni`님의 스타일은 제가 잘 모르지만 저랑 `dlwocks31`은 동일 레이팅의 2인 팀치고는 아마도 꽤 강할 것 같습니다. 제가 상대적으로 조합/정수를 잘 풀고, `dlwocks31`이 자료구조/구현 문제를 잘 풀다 보니... 그래서, 3인팀도 나름대로 스타일은 명확하고 잘 맞는것 같습니다. 

작년에 `dlwocks31` / `coffeetea` / `diordhd` 팀이 2020 ICPC 예선에서 12등인가 하는 놀라운 성적을 얻었는데, 객관적인 전력은 그 근처 어딘가라고 생각합니다. 

## Practice : Sogang 2020 Div1
3시간 정도밖에 시간이 없어서, 돌만한 셋이 별로 없었습니다. Japan ICPC 예선전 정도가 3시간인데, 난이도가 널뛰기하는데다가 백준에서 푼사람이 아무도 없어서 데이터의 올바름을 확신하기 어렵기도 하고... 
서강대학교 대회는 Div 1 과 Div 2로 나뉘어 있고, 원래는 개인대회 3시간짜리 대회입니다. 난이도가 실-골-플-다 문제가 1-2-3-2로 분포된 형태가 UCPC 예선이랑 비슷할것이라고 판단, 이 대회를 3시간 3PC로 돌아보기로 했습니다.

## Phase 0 : Start 
리얼리티를 위해 문제 순서를 shuffle 하고, `gyuni-gratus907-dlwocks31` 순서로 3 3 2 나눠 읽기로 랬습니다. 

## Phase 1 : Easy Problems
### A. 파일 정리 
Solve : `dlwocks31`  
Code : `dlwocks31` (00:07)
'쉬운 구현문제니까 그냥 잡을게요' 라고 말하고 7분에 AC를 받아왔습니다. 무슨문제인지 안읽어서 모르겠습니다.

------

### F. 폰친구
Solve : `gratus907`  
Code : `gratus907` (00:30)  
재밌는 조합 문제였습니다.  
$N$ 명에게 $K$ 개를 나눠주는데 1인당 $m$개 이상 $M$개 이하를 받는 경우의 수를 계산하는 문제입니다. 미리 $m$개씩 나눠주고 시작하면, $L = K - mN$ 개의 사탕을 $N$명에게 나눠주되 각자가 $x = M - m$ 개 이하로만 받는 경우의 수를 세면 됩니다.  

먼저, $x$개 조건이 없다면 답은 중복조합을 이용하여 $_N H _L$ 개입니다. $x$개 조건은 여사건을 이용하여 계산할 수 있습니다. 반대로, '누가 $x+1$개 이상을 받을지' 를 미리 정하고 갑시다. $u$명이 $x+1$개 이상을 받는다면, 미리 얘네들한테 $x+1$개씩 나눠주고 나머지들에게 사탕을 잘 나눠주는 경우를 생각하면 됩니다. 따라서, $_N H _{L - (x+1)u}$ 가 될 것입니다.

그러나, 이 방법의 문제는 '나머지들에게 잘 나눠줄때' 나머지들 중에 또 $x+1$개 이상을 받는 사람이 있을수도 있다는 것입니다. 이를 포함-배제 원리를 이용하여, 다음과 같이 처리하면 됩니다.
$$\sum_{u = 1}^{n} (-1)^u \times {_N C _u} \times {_N H _{L - (x + 1)u}}$$

------

### C. 연료가 부족해
Solve : `gyuni`  
Code : `gyuni` (00:33, 1WA)  
역시 쉬운문제라고 판단하고 30분 정도 시간에 AC를 받았습니다. DP였다고 합니다. 역시 무슨문제인지 안읽어서 잘 모르겠습니다.

------

### B. 컨설팅 
Solve : `gratus907`  
Code : `gratus907` (00:58, 1WA)  
쉬운 문제인데 구현이 귀찮아서 조금 시간이 걸렸습니다. 요점은, Greedy하게 정말 필요할때만 WAIT를 걸어주면 된다는 것을 어렵지 않게 알 수 있고, WRITE의 시작점들 / 도착점들 / (시작, 도착)Pair 들을 각각, READ의 대상을 하나. 이렇게 해서 집합들을 관리하고 조건을 잘 그대로 코딩하면 됩니다. 파이썬 썼는데 set같은걸 shallow copy한다는걸 까먹어서 1틀했습니다.

------

## Phase 2 : 3 Graph Problems
### E. 사탕 배달 
Solve : `dlwocks31`, `gyuni`  
Code : `dlwocks31` (00:52, 1WA)  
뭔지 잘 모르겠지만 트리에서 뭔가를 하는 문제입니다. 제가 파이썬 구현으로 싸우고 있는 사이에 팀원 두명이 AC를 받아왔습니다. 

------

### D. 에어컨 설치
Solve : `gyuni`, `dlwocks31`, `gratus907`  
Code : `gyuni` (01:36)  
문제는 다음과 같습니다.
- $\Z^3$에 정점들이 뿌려져 있고 거리가 1인 정점들을 '인접하다' 고 정의하여 그래프를 만듭니다.
- 그래프에 '에어컨' 을 설치합니다. 이 에어컨 한 대는 설치한 정점과 그 인접한 정점을 커버합니다.
- 이제, 최소 개수의 에어컨을 달아서 모든 정점을 커버하는 문제입니다.

제가 B번을 맞고 갔을때는 이미 어느정도 둘이 솔루션을 discuss하고 있었던 중이었습니다. 여기에 같이 아이디어를 구상하고 `gyuni`님이 코딩을 바로 들어갔습니다.
- 먼저, 어차피 각 connected component별로 생각해야 하므로 그래프가 연결되어 있다고 하겠습니다.
- 이제, 이 문제는 **최소 버텍스 커버** 와 같은 문제임을 압니다.
- 이 문제는 NP-Complete이지만, 이분 그래프에 대해서는 빨리 풀 수 있음이 알려져 있습니다.
- $(a, b, c)$ 에 대해, $a + b + c$의 홀짝성에 따라 정점에 색깔을 칠해주면 이 그래프가 이분 그래프임을 보일 수 있습니다.
- 따라서, 이 그래프에서 최소 버텍스 커버를 짜면 됩니다.

저는 이걸 알아도 이분그래프에서 최소 버텍스 커버를 어떻게 짜는지 자신이 없었지만, `gyuni`님이 그건 짤수 있다고 확신을 줬기 때문에 (:fan:) 맡기고 저랑 `dlwocks31`은 남은 2문제를 잡으러 갔습니다.

------


코딩을 맡긴게 대략 01:00 시점쯤이고, 5AC에 1문제는 코딩만 남은 상황이었기 때문에 난이도에 대해 심각한 의심이 있었습니다. 실버 1, 골드 2, 플레 2문제 + 1문제 구상까지를 1시간에 밀었다는것도 그렇지만, 지금까지 문제들 중 플레급이라고 생각이 드는건 A번 정도였기 때문입니다. C번은 제가 직접 문제를 보지 않아서 뭐라고 할수가 없고, F번은 나중에 생각해보면 포함배제 쓰는 조합문제가 익숙하지 않다면 어려울것 같기도 합니다만 그럭저럭 꽤 많이 나온 스타일의 문제였지 않나 싶습니다.

------

### G. Confuzzle
Solve : `dlwocks31`, `gratus907`  
Code : `dlwocks31`  
- 정점 $n$개의 트리가 주어지고, 각 노드가 $1 \leq c_i \leq n$ 의 색깔을 가집니다. 이때, 색깔이 같은 노드 페어 $v_i, v_j$들 중, 서로의 거리가 가장 가까운 노드 간의 거리를 계산하는 문제입니다. 
- 트리에서 두 정점 사이의 거리는 LCA를 이용하면 ($O(n \log n)$ 전처리를 하고) $O(\log n)$에 계산할 수 있습니다. Range Minimum Query를 잘 이용하면 $O(1)$에도 할 수 있음이 알려져 있지만, 실제로 이게 필요한 상황은 본적이 없는것 같습니다. 
- 다만, 이때 $O(n^2)$ 개의 pair를 확인해야 하므로, $O(n^2 \log n)$ 시간이 걸리는데, 도저히 답이 없는 복잡도입니다.
- 각 점마다 map에, &quot;이 노드를 루트로 하는 서브트리에서, 색깔이 $c$ 인 노드들 중 이 노드에서 가장 가까운 노드까지의 거리&quot; 를 저장한다고 생각합니다. 이를 $M_i$ 맵이라고 생각하겠습니다.
- 내 자녀 노드의 $M_i$들을 모두 알고 있다면, 이들을 합치는 과정에서 두개 이상의 서브트리가 같은 색깔의 노드를 가지고 있다면 이들까지의 거리를 이용하여 페어의 거리를 계산할 수 있습니다. 이 방법이 최단 거리 페어를 항상 찾을 수 있음은 서브트리에 대해 재귀적으로 증명 가능합니다. 
- 그러나, 이 방법은 잘 생각해보면 맵을 합치는 데 $O(n \log n)$ 까지 걸리기 때문에, $O(n^2 \log n)$ 시간이 걸립니다.
- 트리에서 두 Map을 합치는데, `small-to-large` 테크닉을 적용 [(ex : BOJ 4002번 풀이 링크)](/algorithms/BOJ4002/) 하면, $O(n \log^2 n)$ 시간으로 줄일 수 있습니다.

Small to Large 테크닉을 적용하자는 말을 `dlwocks31`이 거의 5분만에 했고(:fan:), 10분만에 코딩했으나 사소한 실수로 디버깅에 40분이 걸렸습니다. 무려 $n^2 \log n$ 솔루션을 코딩해서 스트레스테스트로 반례를 찾아야만 했습니다. :(  
별론으로, 정해가 상당히 멋집니다. 각 색깔에 대해 그 색깔의 노드가 몇개 없으면 ($k \leq \sqrt{n}$) $O(k^2 \log k)$ 알고리즘을 돌리고, 노드가 많으면 멀티소스 BFS를 돌리는... sqrt decomp스타일 아이디어였습니다.  
하지만 여전히 dlwocks31의 스몰투라지가 복잡도면에서 더 좋은 풀이일 뿐 아니라, 코딩도 매우 간단합니다. :fan:

------

## Phase 3 : Pizza Madness

해결하지 못한 H번에 대한 이야기입니다.
- 어떤 수열 $A$와 작은 수열 $B$가 주어지고, $A$를 원형으로 연결했을 때 $B$에 해당하는 패턴을 매칭하는 문제입니다.
- 단, 패턴이 실제로 맞을 필요는 없고, '원소들 간의 순서' 가 맞으면 됩니다. 예를 들어, (4, 3, 6) 과 (2, 1, 3) 을 매칭된 것으로 본다는 것입니다. 

- 다양한 아이디어들이 등장했습니다. 각 수를 좌표압축해서, 좌표압축된 $n$개의 수를 라빈카프처럼 해싱하자는 아이디어라던가...
- 해싱된 수열의 일부를 오른쪽 / 왼쪽으로 미는 연산이 기존의 해싱에서 불가능합니다. 
- 미는 부분이 구간을 연산한다는 점에 착안하여 각 노드가 구간의 라빈카프 해시값을 가지고 있는 세그먼트 트리 같은 아이디어가 나오고
- 세그먼트 트리도 중간에 노드를 날리지는 못하기 때문에, 여기에 무슨 스플레이 트리를 써서...

=&gt; **이게 될리가 없습니다**. 그렇게 한시간동안 셋이서 해괴한 트리들을 꺼내다가 연습을 종료했습니다.  
결국 답은 KMP 알고리즘의 변형이던데, 꽤 멋진 문제인것 같네요.

------

## 후기 
비대면 팀연습이지만 굉장히 재밌었습니다. 배울것도 많았고..ㅋㅋㅋ 특히 작년 ICPC같은경우는 제가 나이로나 PS짬밥으로나 맏이였는데 이번에는 양쪽으로 다 막내인 팀이라서 (?) ㅋㅋㅋ 또 색다른 팀인듯 합니다.  
남은 기간 공부도 재밌게 하고, 무엇보다 대회를 즐길 수 있을 것 같아서 기대가 됩니다.  


Little Piplup을 2명 2명 (저랑 dlwocks / coffeetea와 dhdroid) 먼저 갈라놓고 새 팀원을 찾아보기로 했을때 얘기했던것중 하나가 PS를 즐길수 있었으면 한다는 것이었습니다. 사실 무슨 뉴텔라급이 아닌이상 UCPC는 수상할 수 있는 대회가 아니고, 지금으로써는 예선 통과를 걱정하는 상황도 아니기 때문에 순수하게 문제풀이의 즐거움을 추구하기로 했습니다. 2019년 말~2020년 초에는 정말 PS를 즐겼다고 생각하는데, 그후로 학교공부가 바빠지면서 그러지 못했다가 이제 다시 그때의 마음가짐이 돌아오는것 같아서 개인적으로 굉장히 행복합니다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp_practice" /><summary type="html">Contents</summary></entry><entry><title type="html">논문읽기 : DELTACON</title><link href="http://localhost:4000/cs-adventure/deltacon/" rel="alternate" type="text/html" title="논문읽기 : DELTACON" /><published>2021-07-12T00:00:00+09:00</published><updated>2021-07-12T00:00:00+09:00</updated><id>http://localhost:4000/cs-adventure/deltacon</id><content type="html" xml:base="http://localhost:4000/cs-adventure/deltacon/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

처음으로 정리해볼 논문은 2013년 SDM(SIAM International Conference on Data Mining)에 발표된 DeltaCon입니다. 

## Introduction
두 그래프 $G_1 = (V_1, E_1), G_2 = (V_2, E_2)$ 가 주어졌을 때, 우리는 두 그래프의 `유사도` 를 측정하는 어떤 좋은 메트릭을 갖고 싶습니다. 이 메트릭이 있으면</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cs-adventure" /><category term="graph theory" /><summary type="html">Contents</summary></entry><entry><title type="html">7월 1-2주차 Weekly PS</title><link href="http://localhost:4000/algorithms/ps-weekly-21Jul1/" rel="alternate" type="text/html" title="7월 1-2주차 Weekly PS" /><published>2021-07-08T00:00:00+09:00</published><updated>2021-07-08T00:00:00+09:00</updated><id>http://localhost:4000/algorithms/ps-weekly-21Jul1</id><content type="html" xml:base="http://localhost:4000/algorithms/ps-weekly-21Jul1/">&lt;div id=&quot;toc&quot;&gt;
Contents
&lt;/div&gt;
* TOC
{:toc}
----------

July 01 - July 11, 2021

이 글에 구현코드 링크가 없더라도 [PS 레포 링크](https://github.com/gratus907/Gratus_PS) 에 가서 대회 단위로 들어가면 보통 제가 올려놓은 코드를 볼 수 있습니다. 

## Recent Updates 
- 2021 UCPC에 (팀명은 미정) 참여할 예정입니다. 현재 계획된 팀원은 `dlwocks31` 과 `gyuni` 로, dlwocks31은 지난 2년간 PS를 같이 돌아왔었고 `gyuni`님과는 2019 UCPC쯤에 팀연습 스파링(?) 으로 만나본적이 있습니다.
- 2021 SCPC도 일단은 출전합니다. 

## Rounds 
### Atcoder Beginner Round 208
- [라운드 링크](https://atcoder.jp/contests/abc208/tasks)
- 420등, +4 (1840 -&gt; 1844).
- D번까지 무난하게 풀었는데 E번 구현에서 너무 심하게 말렸습니다. 딱히 재밌지는 않고... F번은 좀 재밌는 수학문제같던데 E에 말려서 읽어보지도 못했네요.

### (Virtual) Codeforces Round 490 (Div.3)
- E번이 좀 재밌는 문제였습니다. 나머지는 딱히.
- Directed Graph가 주어지고, 정점 $s$가 있어서 여기서 모든 점이 도달가능하기 위해 최소 개수의 간선을 추가하는 문항입니다. $n, m$은 5천으로 $O(nm)$ 풀이가 무난한 정도 크기.
- 모든 점에서 BFS를 돌아서 도달가능한 점들을 미리 계산하여, 각 점에서 도달가능한 집합 $R_i$를 들고있기로 합시다. 이제, $s$에서 도달 불가능한 점들을 $T$라고 하고, 어차피 도달가능한 점들은 의미가 없으므로 $R_i$ 대신 $R_i \cap T$를 생각함으로써 모든 $R_i \subset T$가 되게 합니다. 그러면 $R_i$들 중 최소 개수의 집합으로 $T$를 덮는 문제가 됩니다. 
- 이는 set cover라는 매우 유명한 NP-complete 문제이므로 당연히 그대로는 풀 수 없습니다. 그러나, $R_i$들에 대해 순서가 존재함을 기억합시다. 
- $a$에서 $b$로 갈 수 있다면, $R_a$는 $R_b$를 포함합니다.
- 따라서, 서로 도달가능한 점들을 묶고 나면, 남은 $R$들은 set inclusion에 의해 어떤 partial order를 이룹니다.
- 어차피 점 한개를 먹는다면, partial order의 체인을 생각할때 무조건 각 체인의 가장 위에 있는 점들을 먹는것이 이득입니다.
- 이들을 어떻게 구분할 수 있을까요? 가장 간단한 방법은, $R_i$ 들 중 큰 것부터 먹으면 됩니다. 체인의 머리는 그 아래 노드들보다 크므로, 이렇게 하면 머리를 안 먹은 체인에서 아래 노드를 먹을 일은 없습니다. 머리를 이미 먹었는데 그 아래 노드를 먹는 일을 방지하기 위해, 노드를 먹으면서 그 노드에서 도달가능한 ($R_i$에 포함된) 모든 정점들은 지웁니다. 
- 이 방법이 왜 정당한지 증명은 어렵지 않습니다. 
- [구현 링크](https://codeforces.com/contest/999/submission/122143517)
- 별개로, SCC를 잘 활용하면 직접 모든 점에서 BFS를 돌지 않는 Linear time 풀이가 있다고 합니다. 

## Problems
집나간 실력을 되찾기 위한 목적으로 몇개 밀었습니다. 주로 세그먼트 트리 문제를 밀기로 했습니다 :) 

세그먼트 트리 구현은 재귀 트리와 비재귀 트리를 섞어 쓰는 편입니다. 간단히 논의하자면, 양쪽에는 다음과 같은 장단점이 있습니다.
- 재귀트리는 밑바닥부터 제가 짰기 때문에, 동작을 보다 정확하게 이해하고 있어 변형문제를 풀기에 편합니다.
- 재귀트리가 근본적으로 (Fundamentally의 좋은 번역어가 떠오르지 않네요) 좀더 직관적입니다.
- 반면, 비재귀트리는 확실히 더 빠릅니다. 상수가 영향을 주는 문제를 많이 본적은 없지만, $O(n \log n)$ 솔루션이 있는 문제의 경우 가끔 빠른 $O(n \log^2 n)$은 통과하고 똑같은 솔루션에 상수가 크면 짤립니다. 이떄 가끔 유용합니다.
- 비재귀트리는 널리 알려진 구현체인 [Efficient and Easy Segment Trees](https://codeforces.com/blog/entry/18051) 를 가져와서 조금 고쳐 쓰고 있습니다. 많은 사람들이 공유하는 라이브러리를 쓴다는 것은 그 자체로 장점입니다.

제가 쓰는 재귀트리 구현체는 쿼리를 $[l, r]$ 에다 날리고, 비재귀트리 구현체는 가져온 코드라서 $[l, r)$ 에다 날립니다. 혹시 제 코드를 보실일이 있다면 참고해주세요..? ㅋㅋㅋ 

### ICPC Mid Atlantic 2006, BOJ 1849 순열 
- 난이도 : Platinum 4
- $1, 2, \dots n$ 의 permutation을 찾는 문제인데, 각 $i$에 대해, $i$ 앞에 있는 수들 중 $i$보다 큰 수의 개수 $A_i$ 가 주어집니다.
- 기본적인 아이디어는, 각 $i$가 들어갈 위치를 찾아주는 것입니다. 1을 제외한 모든 수가 1보다 크기 때문에, $A_1$이 주어지면 1이 들어가야 할 위치를 그냥 알 수 있습니다. 1을 찾고 나면, 2는 남은 자리들 중 $A_2$번째 자리에 들어가야 한다는 것을 어렵지 않게 알 수 있습니다.
- 결국은 $1, 2, \dots n$ 에 대해, 이 집합에서 수를 하나 뽑아내고, 남아 있는 수들 중 $k$번째를 빠르게 구하는 자료구조가 필요합니다.
- Order statistics tree를 이용하여 $O(n \log n)$에 쉽게 해결할 수 있고, segment tree로도 같은 복잡도로 구현할 수 있습니다. 

### CERC 2010D, BOJ 3429 방어선 
- 난이도 : Platinum 4
- 수열 $A_i$가 하나 주어지고, 수열에서 **최장 길이의 연속하는 증가 부분** 을 찾는 문제입니다. 단, 딱 한 번 원래 수열에서 연속한 부분 하나를 들어낼 수 있습니다.
- 예를 들어, 5, 3, 4, 9, 2, 8, 6, 7, 1 에서 (9, 2, 8) 부분을 떼어내고 가운데 3, 4, 6, 7을 취하는 식입니다.
- `DP1[i]`, `DP2[i]` 를 각각 $i$번째를 오른쪽 / 왼쪽 끝으로 하는 최장 길이의 연속하는 증가 부분이라고 합시다. 이제, 우리가 원하는 값은 모든 $i &lt; j$, $A_i &lt; A_j$에 대해, $D_1(i) + D_2(j)$ 를 계산하여 이를 maximize하는 것입니다.
- 위 표현을 Naive하게 계산하려고 시도하면 '모든 $i &lt; j$, $A_i &lt; A_j$' 에서 이미 $O(n^2)$ 시간이 걸립니다.
- 대신, $A_i$가 큰 것부터 $D_2(i)$의 값들을 세그먼트 트리 같은 자료구조에 업데이트하고, 여기에 $[i, n]$ 구간의 최댓값을 쿼리하는 식으로 생각하면 $O(n \log n)$ 시간에 문제를 해결할 수 있습니다. 코어 로직의 코드는...
```cpp
for (int i = n-1; i &gt;= 0; i--) {
        int u = arr[i].second;
        int q = s.query(u, n);
        s.modify(u, dp2[u]);
        dp[u] = dp1[u] + q;
        ans = max(ans, dp[u]);
    }
    cout &lt;&lt; ans &lt;&lt; '\n';
}
```
- `arr[i].second` 는 $A_i$ 순으로 정렬한 후 다시 인덱스를 가져오기 위함입니다. 대략적인 업데이트 순서는 바로 눈으로 보는 대로입니다. 
- 주의할 점은, $A_i = A_j$ 인 $i, j$가 없음이 보장되어있지 않기 때문에, 쿼리할 때 업데이트 순서를 조심해야 합니다. $A_i$가 같을 때 뭐부터 $D_2(i)$ 를 세그트리에 넣어주는지가 중요한데, $A_i = A_j$이면 $D_2(i)$의 유무가 후속하는 $j$ 쿼리에 영향을 줄 수 없도록, 왼쪽부터 업데이트해야 합니다.

### UCPC 2018 예선F, BOJ 15899 트리와 색깔
- 난이도 : Platinum 2
- 트리의 각 정점이 1부터 $C$ 사이의 색깔을 가지고 있고, $f(v, c)$ 를 $v$를 루트로 하는 서브트리에서 색깔이 $c$이하인 정점의 개수로 정의할 때 이를 빨리 계산하는 문제입니다.
- Euler Tour 라는 테크닉을 이용, 트리를 배열로 펴 주면 서브트리에 대한 쿼리가 우리가 잘 이해하고 있는 구간에 대한 쿼리로 바뀝니다.
- 쿼리를 오프라인 처리해서, 색깔이 작은 쿼리부터 처리하겠습니다.
- 이제, 색깔이 작은 것부터 업데이트하면서 중간중간 타이밍이 될때마다 쿼리를 처리해 주면 됩니다.

### BOJ 14287 회사 문화 3
- 난이도 : Platinum 4
- 위 문제와 똑같이 Euler Tour 를 이용하여 트리를 배열로 펴고
- 칭찬받은 노드에 값을 더한 다음
- 쿼리가 들어오면 그 노드의 서브트리가 받은 칭찬의 값을 합하면 끝입니다.
- 구현이 매우 단순해서, 오일러투어 구현을 확인하기에 적절합니다. 
- 나름대로 깨끗하게 구현하려고 노력한 [링크](https://www.acmicpc.net/source/30906316) 참고.

### BAPC 2005E, BOJ 5419 북서풍
- 난이도 : Platinum 4
- 전형적인 '스위핑 + 세그트리' 입니다. 
- 문제를 단순화하기 위해, 좌표평면에 N개의 점이 있고, 남동쪽 대신 북동쪽으로 간다고 생각해 봅시다. 좌표압축을 한다음 Y좌표들을 뒤집어 버리면 이렇게 만드는 것은 어렵지 않게 가능합니다. 
- 이제, 각 점들을 $(x_i, y_i)$ 라고 하고, 1차원 세그먼트 트리 하나를 만듭니다. 각 점을 세그트리의 $x_i$ 번 위치에 추가할 것입니다. 
- 우리가 원하는 것은, $(x_i, y_i)$에 서서 세그트리에 $[x_i, \infty]$ 쿼리를 날렸을때 여기서부터 북동쪽으로 갈수있는 점의 개수를 얻는 것입니다. 그러나 우리의 세그트리는 $y$좌표를 기억하지 않고 그냥 무작정 점의 개수를 세기 때문에, $y$좌표는 우리가 스위핑해야 합니다.
- $y$좌표가 큰 순서대로, 즉 위에서부터 세그트리에 점을 하나씩 넣으면서, 이 점까지 넣은 다음 동쪽을 바라보면 나보다 아래 (y좌표 기준) 점들을 아직 아예 추가가 되지 않았기 때문에 북동쪽 점들만 보이게 됩니다.
- 주의할 점은, 점을 정확히 세기 위해서는 $y$좌표가 같은 점들은 $x$좌표가 큰 쪽부터 처리해야 합니다.

### SCCC 2019E, BOJ 17131 여우가 정보섬에 올라온 이유
- 난이도 : Platinum 4
- 바로 위 문제와 거의 똑같습니다. 
- $y$ 좌표 순서대로 내려오면서 업데이트하고 쿼리합니다. 이문제는 $[0, x_i - 1]$ 과 $[x_i+1, \infty]$ 를 쿼리해서 곱하는 방식입니다.
- 딱 하나 주의할 점은, 위 문제와는 달리 $y$좌표가 같은 점들을 업데이트하는 순서를 어떻게 줘도 꼬이게 됩니다. $y$좌표가 같은 점들을 따로 기억해 놨다가 한번에 업데이트해야 합니다. 코드를 참고해 주세요.

### BOJ 16993, 연속합과 쿼리
- 난이도 : Platinum 2
- 연속합과 쿼리는 소위 '금광세그' 를 이용하여 풀 수 있음이 매우 잘 알려져 있습니다. 
- 세그먼트 트리를 사용하되, 다음과 같은 정보들을 저장합니다. 세그트리의 한 노드가 구간 $[l, r]$ 에 대응한다는 사실을 기억합시다.
  - 자기가 담당하는 구간의 왼쪽 끝에서 시작해서 얻을 수 있는 최대 구간합
  - 자기가 담당하는 구간의 오른쪽 끝에서 시작해서 얻을 수 있는 최대 구간합
  - 자기가 담당하는 구간의 최대 구간합
  - 자기가 담당하는 구간의 합
- 이 네 정보를 ls, rs, ms, s라고 하면, 두 노드를 합칠 때 다음과 같이 생각하면 됩니다.
  - 노드 $a$, $b$를 합쳐서 $e$로 만들 때,
  - `e.s` 는 자명합니다. 
  - `e.ls` 는, `e`의 왼쪽 끝에서 시작해야 하므로 `a.ls` 가 답일 수도 있고, a를 다 먹고 b의 왼쪽 일부를 먹는 경우가 답일 수도 있습니다. 후자는 `a.s + b.ls` 가 최대일 것입니다 (ls의 정의). 따라서, 두 값 중 최대를 취합니다.
  - 같은 원리로, `e.rs`는 `b.rs` 와 `b.s + a.rs` 중 큰 값을 고르면 됩니다.
  - 마지막은 `e.ms` 입니다. 이는 다시 경우를 나누어 생각하면, `a`구간에 포함된 답을 갖거나 (`a.ms`), `b`구간에 포함된 답을 갖거나 (`b.ms`), 두 구간에 걸친 답을 갖거나 (이 답이 `a.rs + b.ls`가 최선임을 관찰합니다) 세가지 경우 (대칭을 제외하면 두가지) 밖에 없습니다.
- 따라서, 상수배의 시간을 지불하여 모든 정보를 관리할 수 있고, 연속합 쿼리를 똑같이 날려줄 수 있습니다.
- 두 노드를 합칠때, 단순합에서는 좌우가 상관없지만 이런 특수한 연산을 할 때는 좌우를 조심해야 합니다. 

## Review
세그먼트 트리 문제를 오랜만에 밀면서 자료구조에 대한 이해를 되짚었다는 정도의 의의가 있는것 같습니다.</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="algorithms" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 1학기 종강</title><link href="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/" rel="alternate" type="text/html" title="2021 1학기 종강" /><published>2021-06-15T00:00:00+09:00</published><updated>2021-06-15T00:00:00+09:00</updated><id>http://localhost:4000/retrospects-and-plans/finishing-2021-spring</id><content type="html" xml:base="http://localhost:4000/retrospects-and-plans/finishing-2021-spring/">이번학기도 무사히...ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.

## Academic

### Spring Semester Courses

#### Hardware System Design (CSE, 3)

-   Verilog를 이용하여 행렬곱셈 하드웨어 가속기를 만들고, CNN을 빨리돌리는..뭐 그런걸 배우는 과목입니다.
-   저는 베릴로그 코딩을 굉장히 힘들어하기 때문에 팀원이 좀 많이 고생했습니다. 논리설계때 좀 열심히 들을걸 하는 깊은 후회와 미안함을 느끼고 있어서, 창통설은 제가 좀더 나서서 고생할 계획입니다 (아마도...)
-   그와는 별개로 배우는 내용은 매우 흥미로웠는데, 저한테는 좀 힘들었습니다. 제 관심 분야와는 멀다보니 전선이었다면 안 들었을 것 같은데 전필이라 (내 선택에 맡겼다면 있는지도 몰랐을 것들을) 배울 수 있었다는 데 의의가 있다고 생각합니다. 솔직히 NPU, 딥러닝용 FPGA 등이 매우 전망있고 미래에 중요한 기술일 거라는 생각은 듭니다. 다만 제가 개척할 미래는 아니고, 다른 훌륭한 엔지니어들이 수십배 빠른 NPU를 만들어 줄거라고 믿어 의심치 않습니다.
-   프로젝트가 정말 빡세지만 끝나고 보니 그럭저럭 재밌기도 했습니다. 다만 조금 힘들었던 부분들에 대해서는 언젠가 제 시간이 허락하고 팀원이 동의하면 셀프 검열을 좀 거쳐서 얘기해보고 싶습니다. 소개원실 프로젝트는 이렇게 말하고 영원히 검열을 통과하지 못했는데, 하시설은 그정도로 고통스럽지는 않았기 때문에 언젠가는 검열을 통과할수 있을 것 같습니다.

#### Discrete Mathematics (CSE, 1)

-   CS 101인데 지금듣는 놀라운 역수강의 결과입니다. Subgraph Isomorphism에 대한 논문을 읽다가 graph가 뭐고 simple graph가 뭔지 배우는 등... 많은 괴리가 있었습니다.
-   다른 학교의 이산수학과는 달리 저희는 Group이 무엇인지, Lattice가 무엇인지 등 좀 신기한 것들을 많이 배웁니다. Lattice는 처음 듣는 내용이라 당황해서 (정수론의 Lattice가 아닌 집합론의 Lattice입니다) 다른학교 컴공과 친구들 몇명 붙잡고 이게도대체 뭐냐고 물어봤지만 아무도 모르던데, 나름 신기한 뭐가 많았습니다.
-   별개로, 1학년때 들었다면 좋았을것 같습니다. 저야 수학을 복수전공하니까 Proof의 구조나 Function, Relation 등에 대해 공부할 일이 어차피 있었기 때문에 그 효용이 크지 않았겠습니다만 저처럼 수학을 많이는 공부하고 싶지 않더라도 CS 전공자에게 필요한 수학을 단시간에 빠르게 습득할 수 있는 과목이었다는 생각이 듭니다.

#### Numerical Linear Algebra (MATH, 3)

-   수리과학부 수치해석 루트의 과목입니다. MATLAB 또는 Python을 이용한 프로그래밍도 해야 하고, 그냥 과제의 양이 정말 충격적으로 많았는데 그만큼 많이 배웠다고 생각합니다. 중간고사 때까지는 사실 많은 내용을 어디서 주워들은 것들이라고 생각했었는데, 중간고사를 보고 그렇지 않음을 깨달은 뒤 (...) 기말고사는 열심히 공부하고 봤습니다.
-   간단히 요약하자면, 행렬에 대한 알고리즘을 배우는 과목입니다. numpy의 수많은 알고리즘들을 그대로 가져다 쓸수도 있겠지만, 누군가는 그런것들을 만들어야 하니까요. 예를 들어, 1000 \* 1000 행렬의 eigenvalue를 어떻게 구할지, eigenvalue 전부가 아니라 몇개만 필요하다면 어떻게 구할지... $Ax = b$는 정해진 해 $x = A^{-1} b$ 가 있지만, 세상에는 감히 역행렬을 구할 시도조차 할 수 없는 사이즈의 문제들이 있습니다. 그렇기에 iteration method 등 여러 clever 한 알고리즘들을 써야 하는데, 그런 부분들을 배웁니다.
-   컴퓨터공학부 알고리즘 수업은 아무래도 이산적인 구조에 집중하고, 다익스트라 알고리즘, 다이나믹 프로그래밍 등등을 배워야 하기 때문에 수치적 알고리즘은 다루지 않게 됩니다. 저희과는 수치해석에 대해서는 공학수학에서 조금 배우는 정도이기 때문에, 후반부 내용들은 굉장히 새로웠습니다.
-   필기노트를 언젠가 LaTeX로 바꿔서 블로그에 공유하고 싶은 과목으로 현재로서는 두번째에 있습니다 (첫번째는 지난학기에 들었던 최적화 이론입니다) 다만 가장 큰 문제는, LaTeX가 행렬 타이핑이 굉장히 어렵다는 점입니다. 고민해보고 있습니다.

#### Number Theory (MATH, 2)

-   수리과학부 2학년 과목이고, KMO 출신들을 이길수 없기 때문에 학점은 포기하고 들어야 하는 과목입니다. 다만 교수님께서 원래 Cryptography를 연구하시고, Pollard-Rho 알고리즘의 발전에 지대한 공헌을 하신 등 Computational Number Theory에 가까운 분이시기 때문에 저한테는 정말 재밌는 수업이었습니다. 수업중 Algorithmic한 부분들 - 예를들어 Lenstra의 소인수분해 등 - 에 대한 언급이 많았고, 격자이론이나 동형암호에 대한 특강 등 컴퓨터공학 전공인 저한테는 정말 배울게 많았습니다.
-   PS하면서 배운 정수론을 좀더 정확히 이해할 수 있었습니다. 초반에 빠르게 일반적인 정수론의 주제들 (중국인의 나머지 정리, 페르마 소정리, 오일러 피 함수, 르장드르 기호, 이차 잉여, 디리클레 합성곱 등) 을 달린 후, 후반에는 타원곡선, 무리수의 유리근사, 소수정리 등의 재밌는 주제들을 폭넓게 다루었는데 솔직히 80%도 채 소화하지 못한 것 같아 아쉽습니다. 언젠가 제가 ~정신을 잃고~ 대수적 정수론 같은걸 펴볼 날이 올까요?

#### Real Analysis (MATH, Grad 1) / Undergrad Real Analysis (MATH, 4)

-   이번학기를 지배한 실해석/실변수 세트입니다. 실해석학은 워낙 유명한 과목으로 대학원 1년차 과목임에도 학부생 수강생이 훨씬더 많고 타과생도 많습니다만 제기억에 컴공과는 저밖에 없었습니다. 주로 해석학을 배워야 하는 통계학과, 경제학과가 많았습니다.
-   GRA / URA로 구분하자면, GRA는 루딘의 Real and Complex Analysis의 앞부분 반정도를 커버하고, URA는 Folland의 Real Analysis를 기준으로 그중 일부를 나갑니다. 두 과목의 가장 큰 차이는 '세팅' 이었다고 생각하는데, GRA는 Locally Compact Hausdorff space X를 기본 세팅으로 두는데 비해 URA의 기본 세팅은 $\\R$ 또는 $\\R^2$ 입니다. 예를들어 Fourier Series를 이해하기 위해 URA에서는 직접 적분을 계산하고 Dirichlet Kernel, Fejer Kernel 등등을 이용하여 내용을 진행하는데 비해, GRA에서는 Hilbert space (완비내적공간)에 대한 일반적인 성질들을 공부하고 그걸 $L^2(\[-\\pi, \\pi\])$ 에 적용하는 식입니다.
-   그렇다보니 Measure theory, Lebesgue 적분 등을 두가지 관점에서 동시에 보면서 (뚝배기가 박살나긴 했지만) 재밌게 공부할 수 있었습니다. 종합해서 해석학에 대한 이해를 높일 수 있었다고 생각합니다.
-   다만 저처럼 수학을 찍먹할 사람이면 모를까, 수학 전 분야에 대한 이해를 좀 가져야 할 수리과학 전공생들에게 권할만한 테크인지는 잘 모르겠습니다. Redundancy가 있는건 사실이니까요. 저는 복수전공자니까 전필만 듣고나면 제가 듣고싶은거 적당히 골라듣고 챙기면서 움직여도 뭐 되지 않을까요.
-   Measure theory를 공부하게 된 계기는, 3학년 2학기 때 수강했던 최적화 이론입니다. 최적화 이론에서 Martingale 등 놀라운 이론들을 통해 수렴성을 얻는게 좀 있었는데, 도대체 수렴하면 수렴하는거지 Almost surely converge한다는건 무슨소리인가??? 에 대해 답할 수 있게 되었습니다. 최적화이론 수업 이후 조언을 구하였을 때, measure theory와 stochastic differential equation에 대한 공부가 최적화 분야의 엄밀한 이해에 도움이 될 것이라는 조언을 얻을 수 있었습니다.

### Extracurricular

-   지난 2학기 ~ 이번 4월까지 컴퓨터공학부 컴퓨터이론 및 응용 연구실에서 수행했던 UROP 결과로 작성에 참여한 논문을 한국정보과학회에서 주관하는 한국 컴퓨터 종합 학술대회 (Korea Computer Congress) 에 제출하여 발표 (발표는 제가 하는건 아니지만) 하게 되었습니다. 솔직히 짧은 경험과 부족한 지식, 코로나 시국이라 대부분이 비대면으로 진행된 현실 상 제가 뭔가 딥하게 할수 있었던건 별로 없고, 어떤식으로 이런 프로세스들이 돌아가는지 배웠다는 것, 논문 읽고 코드 좀 고쳐서 테스트해보면서 그래도 학교 공부와는 또 다른 느낌의 뭔가를 생각해봤다는데 의의가 있는게 아닌가 생각하기로 헀습니다.
-   연구실에서 감사하게도 KCC 참가비용을 지원해주셔서, 23-25일에는 발표도 듣고 그러게 되었습니다. 재밌는게 있으면 정리해서 뭘 배웠는지 또 포스팅 해보려고 합니다.
-   \[UPD\] KCC 2021에 결과물인 &quot;부분 그래프 매칭 문제를 위한 향상된 동적 매칭 순서&quot; 를 제출하여 Oral 발표 세션에서 발표될 예정입니다. (발표는 뭐 제가 하는건 아니고, 주저자이신 박사과정 연구원님께서 하십니다) 부족한 제게 정말 과분하게 좋은 경험이었고 감사하게 생각하고 있습니다.

### Miscellaneous

-   코로나 시국이라 Personal하게 크게 바뀔만한건 없는듯합니다.
-   가까운 친구/지인 몇명이 병특 등을 포기하고 군대를 갔습니다. 산업기능요원 TO 감소를 비롯하여 여러 이슈들이 겹쳐진것 같은데, 개인적으로 석전연/박전연 중 한쪽을 제 루트로 생각하고 있어서 현재는 입대는 계획에 없습니다. 그래도 유학 등 때문에 고민은 많네요...

## 2021 Summer

-   졸업을 해야 하므로 (...) 과학 교양을 채워야 합니다. 실험 듣기 싫어서 미뤘던 죄값을 치를 순간이 왔습니다. 이번 여름에 일반생물학과 일반생물학 실험을 듣게 되었습니다. 고등학교 때 암기가 싫어서 생명과학 2를 고르느니 물리2 화학2 수능을 보고 말겠다고 선언하고 (가오에 지배당해서) 실제로 그렇게 했던 제게는 너무나 끔찍한 형벌이 아닐 수 없습니다.
    -   그러나 늘 그렇듯 새로운걸 배우기 전까지는 알 수 없는 법입니다. 저는 제가 대학와서 수학을 이렇게 많이 공부할지 몰랐으니까요.
    -   라고 셀프 세뇌하고 있습니다.
-   수학과의 지인과 지식공유? 의 차원에서, 제가 자료구조/알고리즘과 C++ 프로그래밍을 좀 가르쳐주고 현대대수2의 내용을 좀 배우기로 했습니다. 다음학기에 현대대수2를 들을 예정인데 현대대수1을 모두 잊어버렸기 때문에 복습과 예습이 조금 필요합니다. 어제 그 지인분이 &quot;그렇게 아예 잊어버리기야 했겠느냐&quot;며,  &quot;Normal subgroup이 뭔지 기억하죠? Ideal이랑&quot; 라고 물었을 때 '어...$g$랑 $g^{-1}$를 앞뒤로 곱했던거 같은데...' 와 '아뇨 기억 안나는데요' 로 대답하는 놀라운 당당함을 보여줬습니다. 모르긴 몰라도 이샛기는 붕어인가?? 하는 생각에 FACEPALM하고 있지 않을까요?
-   그외 계획은 아직 미정입니다. PS도 좀 하고 (이건 이제 반쯤 취미죠)...</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="retrospects-and-plans" /><summary type="html">이번학기도 무사히…ㅋㅋㅋㅋ 학기에 뭘 배웠는지도 돌아보고, 공부했던거에 대한 생각을 적어보려고 합니다.</summary></entry></feed>