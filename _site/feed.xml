<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-08-02T23:16:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gratus907’s Study Note</title><subtitle>Hello World!</subtitle><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><entry><title type="html">8월 1주차 Weekly PS</title><link href="http://localhost:4000/ps_weekly/ps-weekly-21Aug1/" rel="alternate" type="text/html" title="8월 1주차 Weekly PS" /><published>2021-08-02T00:00:00+09:00</published><updated>2021-08-02T00:00:00+09:00</updated><id>http://localhost:4000/ps_weekly/ps-weekly-21Aug1</id><content type="html" xml:base="http://localhost:4000/ps_weekly/ps-weekly-21Aug1/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#recent-updates&quot; id=&quot;markdown-toc-recent-updates&quot;&gt;Recent Updates&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rounds&quot; id=&quot;markdown-toc-rounds&quot;&gt;Rounds&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#codeforces-educational-round-112&quot; id=&quot;markdown-toc-codeforces-educational-round-112&quot;&gt;Codeforces Educational Round 112&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#codeforces-round-736-div-1&quot; id=&quot;markdown-toc-codeforces-round-736-div-1&quot;&gt;Codeforces Round 736 (Div 1)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problems&quot; id=&quot;markdown-toc-problems&quot;&gt;Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#cf-edu112-e---boring-segments&quot; id=&quot;markdown-toc-cf-edu112-e---boring-segments&quot;&gt;CF Edu112 E - Boring Segments&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cf-r736-div1-b---integers-have-friends&quot; id=&quot;markdown-toc-cf-r736-div1-b---integers-have-friends&quot;&gt;CF R736 Div1 B - Integers have friends&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cf-r736-div1-d1---gregor-and-the-odd-cows-easy&quot; id=&quot;markdown-toc-cf-r736-div1-d1---gregor-and-the-odd-cows-easy&quot;&gt;CF R736 Div1 D1 - Gregor and the Odd Cows (Easy)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;July 29 - August 07, 2021&lt;/p&gt;

&lt;p&gt;이 글에 구현코드 링크가 없더라도 &lt;a href=&quot;https://github.com/gratus907/Gratus_PS&quot;&gt;PS 레포 링크&lt;/a&gt; 에 가서 대회 단위로 들어가면 보통 올려놓은 코드를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;읽는 사람이 문제를 읽고 조금 생각해봤다고 가정하고, 대략적인 아이디어만 간단히 적을 생각입니다 ㅎㅎ&lt;/p&gt;

&lt;h2 id=&quot;recent-updates&quot;&gt;Recent Updates&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SCPC Round 2에 대한 포스팅은 일요일에 따로 작성 예정입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rounds&quot;&gt;Rounds&lt;/h2&gt;
&lt;h3 id=&quot;codeforces-educational-round-112&quot;&gt;Codeforces Educational Round 112&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Div2 기준 274등, Rating 1947 -&amp;gt; 1995 (+48)&lt;/li&gt;
  &lt;li&gt;Performance 2096&lt;/li&gt;
  &lt;li&gt;몇달만의 Codeforces 복귀전.&lt;/li&gt;
  &lt;li&gt;Div2지만 E번까지 풀어서 굉장히 기분이 좋았습니다. 복귀전인것치고는 레이팅도 많이 올랐고…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;codeforces-round-736-div-1&quot;&gt;Codeforces Round 736 (Div 1)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Div2 기준 274등, Rating 1995 -&amp;gt; 2055 (+60)&lt;/li&gt;
  &lt;li&gt;Performance 2200&lt;/li&gt;
  &lt;li&gt;UCPC도 못나가고 하다보니 그냥 CP가 하고싶어져서 좀 자주 돌기로 했습니다. 오렌지 파킹하고 ICPC 팀 찾아야죠.&lt;/li&gt;
  &lt;li&gt;C번에 비해 D1번이 많이 쉬웠습니다.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cf-edu112-e---boring-segments&quot;&gt;CF Edu112 E - Boring Segments&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 2100&lt;/li&gt;
  &lt;li&gt;어떤 subset을 골라서 전체를 커버하되, 가중치의 최대-최소 값을 최소화해야 합니다.&lt;/li&gt;
  &lt;li&gt;이러한 문제를 Two pointer라는 방법으로 잘 해결할 수 있습니다. 또는, 각 시작점에 대해 가능한 끝점을 이분 탐색해도 됩니다.&lt;/li&gt;
  &lt;li&gt;다만, 두 경우의 차이는, $a-b$ 를 쓰다가 $a-(b+1)$ 을 쓰는걸로 전환하는게 빠르면 투포인터를 쓰고, 임의의 $a-b$를 시도하는 쿼리가 빠르면 이분탐색도 쓸 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이 문제는, 후자의 쿼리가 어렵기 때문에 (가능할거같긴한데 사실 잘 모르겠습니다) 투포인터를 씁니다. 따라서 고른 $[l_i, r_i]$ 들의 집합이 한개만큼 바뀔때 쿼리당 시간이 짧아야 합니다.&lt;/li&gt;
  &lt;li&gt;하나를 고를 때마다 $[l_i, r_i]$ 에 1을 더하고 (골랐던걸 뺄때는 당연히 -1), 마지막에 $[1, n]$ 의 최소값이 0인지 (커버하지 못함), 0보다 큰지 (커버함) 판정할 수 있습니다. 이 두 연산 모두 Lazy propagation이 적용된 segment tree로 잘 할수 있음을 알고 있습니다. 이경우 구간 하나를 추가하거나 빼는데 걸리는 시간이 $O(\log n)$, 판정 시간도 $O(\log n)$ 입니다.&lt;/li&gt;
  &lt;li&gt;이제, 마지막으로 생각할 것은 원래 문제에서는 $[1, 3], [4, 5]$ 가 겹치는 것으로 인정되지 않지만 세그트리로 바꿀때는 전체를 커버한다는 False positive의 가능성입니다. $[l_i, r_i]$ 들을 세그에 더할때는 $[l_i, r_i)$ 로 바꿔서 더하면 됩니다.&lt;/li&gt;
  &lt;li&gt;여담으로, 저는 $m, n$ 의 범위를 헷갈려서 삽질하다가 1시간 59분 51초에 대회종료 9초를 남겨두고 AC를 받았습니다. ㅋㅋ!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cf-r736-div1-b---integers-have-friends&quot;&gt;CF R736 Div1 B - Integers have friends&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;간단하게 생각할 수 있는 것은, 주어진 수들의 인접한 수들 간의 차를 새로운 배열로 만들고 나면, 이 배열에서 어떤 sub-array를 뽑아서 그 gcd가 1보다 크면 된다는 것입니다.&lt;/li&gt;
  &lt;li&gt;GCD가 1이 아닌 가장 긴 subarray를 찾는 것은 역시 위 문제와 똑같이, 투포인터 또는 각 시작점에서의 이분탐색으로 해결가능합니다.&lt;/li&gt;
  &lt;li&gt;어떤 부분구간의 GCD가 1인지 아닌지 빠르게 판정하기 위해서는, 노드에 gcd값을 저장하는 세그먼트 트리를 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;위 문제와 거의 같은 세그 + (투포인터 or 이분탐색) 문제입니다. 저는 위문제는 투포인터를, 이 문제는 이분 탐색을 썼습니다.&lt;/li&gt;
  &lt;li&gt;투포인터 사용시 $O(n \log A)$, 이분탐색은 $O(n \log n \log A)$인데, 이분탐색도 넉넉합니다. GCD는 생각보다 빨라서요.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cf-r736-div1-d1---gregor-and-the-odd-cows-easy&quot;&gt;CF R736 Div1 D1 - Gregor and the Odd Cows (Easy)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;픽의 정리에 의하면, 볼록다각형의 넓이 $A$, 경계면에 있는 격자점의 수 $B$, 안쪽에 들어있는 격자점의 수 $C$에 대해 $A = B/2 + C - 1$ 이 성립합니다.&lt;/li&gt;
  &lt;li&gt;즉, $A$ 와 $B/2$의 홀짝성이 같다면 $C$가 홀수가 될 것입니다.&lt;/li&gt;
  &lt;li&gt;고를 수 있는 모든 정수점이 짝수좌표를 갖는 상황에서, $A$와 $B/2$의 홀짝성에 대해 생각해 보겠습니다.&lt;/li&gt;
  &lt;li&gt;$A$, 즉 넓이는 외적공식을 통해 구할 수 있는데, 어차피 mod 4 위에서 구할 것이므로 원래 점의 좌표의 mod 4 값들만 알아도 충분합니다.&lt;/li&gt;
  &lt;li&gt;$B$ 를 mod 4한 값을 알아야 하는데, 잘 생각해 보면 $(x_1, y_1)$ 에서 $(x_2, y_2)$까지 선분을 이을 때 그 위의 정수 격자점의 개수는 $\gcd(x_2 - x_1, y_2 - y_1)$ 이 4의 배수인지 여부에 따라 결정됩니다.&lt;/li&gt;
  &lt;li&gt;따라서, 임의의 세 점 $p_i, p_j, p_k$에 대해, 각 점의 $x, y$ 좌표의 mod 4한 나머지값만 안다면, 이 점들은 사실 $A$와 $B/2$의 부호 면에서는 똑같습니다.&lt;/li&gt;
  &lt;li&gt;점을 네가지로 구분하고 ($x$와 $y$ 좌표를 0 또는 2로), 클래스 0-3의 점들 중 3개를 고르는 경우의 수 64가지를 생각해 줍니다. 같은 클래스의 점을 2개 고를 때 경우의 수는 이항계수로 구해야 함을 기억합시다.&lt;/li&gt;
  &lt;li&gt;코드는 간단하지만 Casework가 좀 있습니다.&lt;/li&gt;
  &lt;li&gt;이문제도 끝나기 10분정도 전에 AC를 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ps_weekly" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">7월 4-5주차 Weekly PS</title><link href="http://localhost:4000/ps_weekly/ps-weekly-21Jul4/" rel="alternate" type="text/html" title="7월 4-5주차 Weekly PS" /><published>2021-07-28T00:00:00+09:00</published><updated>2021-07-28T00:00:00+09:00</updated><id>http://localhost:4000/ps_weekly/ps-weekly-21Jul4</id><content type="html" xml:base="http://localhost:4000/ps_weekly/ps-weekly-21Jul4/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#recent-updates&quot; id=&quot;markdown-toc-recent-updates&quot;&gt;Recent Updates&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rounds&quot; id=&quot;markdown-toc-rounds&quot;&gt;Rounds&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#testing-codeforces-global-round-15&quot; id=&quot;markdown-toc-testing-codeforces-global-round-15&quot;&gt;(Testing) Codeforces Global Round 15&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problems&quot; id=&quot;markdown-toc-problems&quot;&gt;Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-1766-문제집&quot; id=&quot;markdown-toc-boj-1766-문제집&quot;&gt;BOJ 1766 문제집&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#poi-1994-ones-and-zeros-boj-8111-0과-1&quot; id=&quot;markdown-toc-poi-1994-ones-and-zeros-boj-8111-0과-1&quot;&gt;POI 1994 Ones and Zeros (BOJ 8111 0과 1)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-1602-도망자-원숭이&quot; id=&quot;markdown-toc-boj-1602-도망자-원숭이&quot;&gt;BOJ 1602 도망자 원숭이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#icpc-germany-regional-gcpc-2010-d-field-plan-boj-3977-축구-전술&quot; id=&quot;markdown-toc-icpc-germany-regional-gcpc-2010-d-field-plan-boj-3977-축구-전술&quot;&gt;ICPC Germany Regional (GCPC) 2010 D Field Plan (BOJ 3977 축구 전술)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#boj-4196-도미노&quot; id=&quot;markdown-toc-boj-4196-도미노&quot;&gt;BOJ 4196 도미노&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#icpc-jakarta-regional-2018-boomerangs-boj-16583&quot; id=&quot;markdown-toc-icpc-jakarta-regional-2018-boomerangs-boj-16583&quot;&gt;ICPC Jakarta Regional 2018 Boomerangs (BOJ 16583)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;July 19 - July 28, 2021&lt;/p&gt;

&lt;p&gt;이 글에 구현코드 링크가 없더라도 &lt;a href=&quot;https://github.com/gratus907/Gratus_PS&quot;&gt;PS 레포 링크&lt;/a&gt; 에 가서 대회 단위로 들어가면 보통 올려놓은 코드를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;7월 마지막 주는 일반생물학 시험을 비롯, 몇가지 할일이 있어서 PS를 거의 못할듯 합니다 :(&lt;/p&gt;

&lt;p&gt;읽는 사람이 문제를 읽고 조금 생각해봤다고 가정하고, 대략적인 아이디어만 간단히 적을 생각입니다 ㅎㅎ&lt;/p&gt;

&lt;h2 id=&quot;recent-updates&quot;&gt;Recent Updates&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어리석은 실수로 UCPC에 참가하지 못하게 되었습니다.&lt;/li&gt;
  &lt;li&gt;뭔가 SCPC 2차 준비는 마땅히 할수있는게 없고 해서… 순수하게 재밌는 공부를 하려고 노력 중입니다.&lt;/li&gt;
  &lt;li&gt;ICPC 철이 되면 팀원들과 함께 또 재밌게 할수있을듯 합니다. 팀연습이 제일 재밌는거 같아요&lt;/li&gt;
  &lt;li&gt;올해 PS 성과는 코드잼 R3 간걸로 마무리하게 될듯…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rounds&quot;&gt;Rounds&lt;/h2&gt;
&lt;h3 id=&quot;testing-codeforces-global-round-15&quot;&gt;(Testing) Codeforces Global Round 15&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Global Round 15에 테스터로 참여했습니다.&lt;/li&gt;
  &lt;li&gt;제가 테스팅했을때랑 비교하면, B번 문제가 새로 생겼고, 원래의 B번이 D번으로 이동했습니다. 테스팅했을때도 B (지금의 D) 가 너무 어려운거 같다는 생각은 들었었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;
&lt;p&gt;그래프 연습.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;boj-1766-문제집&quot;&gt;BOJ 1766 문제집&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Gold 2&lt;/li&gt;
  &lt;li&gt;사용하는 알고리즘들에 대한 이해만 명확하면 쉽습니다.&lt;/li&gt;
  &lt;li&gt;BFS로 노드들을 위상 정렬하는 방법을 따르되&lt;/li&gt;
  &lt;li&gt;queue 대신 항상 가능한 쉬운 문제를 풀라는 조건이 있으므로 BFS에서 Queue 대신 Priority Queue를 쓰면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;poi-1994-ones-and-zeros-boj-8111-0과-1&quot;&gt;POI 1994 Ones and Zeros (BOJ 8111 0과 1)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 5&lt;/li&gt;
  &lt;li&gt;어떤 수의 뒤에 0과 1을 이어서 다음 수를 만들 수 있습니다. 이를 0부터 $N-1$까지의 노드가 있다고 생각하면 나머지가 $r$에 서, $10r$ 또는 $10r + 1$ 로 노드가 이어져 있음을 관찰합니다.&lt;/li&gt;
  &lt;li&gt;이제 1에서 BFS를 통해 노드들을 방문하면서, 0이 100-step 이내에 방문 가능한지 확인하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;boj-1602-도망자-원숭이&quot;&gt;BOJ 1602 도망자 원숭이&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 5&lt;/li&gt;
  &lt;li&gt;노드 가중치는 합이 아니라, 경로 상의 가중치의 max만 한 번 더합니다.&lt;/li&gt;
  &lt;li&gt;이 문제를 해결하는 방법은, 그냥 노드 순서대로 ‘중간 노드’ 를 쓰는 F-W와는 달리 노드 가중치가 작은 것부터 중간 노드로 써서 업데이트하는 것입니다.&lt;/li&gt;
  &lt;li&gt;이렇게 하면, 새로운 노드를 쓰는 경우 항상 노드가중치는 새 노드의 것을 따라가게 되므로, 비교적 쉽게 해결할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;icpc-germany-regional-gcpc-2010-d-field-plan-boj-3977-축구-전술&quot;&gt;ICPC Germany Regional (GCPC) 2010 D Field Plan (BOJ 3977 축구 전술)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 4&lt;/li&gt;
  &lt;li&gt;그래프를 SCC로 묶어서 생각합니다. 같은 SCC에 있는 정점끼리는 언제든 서로 오갈 수 있기 떄문입니다.&lt;/li&gt;
  &lt;li&gt;이제, indegree가 0인 SCC를 찾아서, 그 SCC로부터 출발하면 됩니다.&lt;/li&gt;
  &lt;li&gt;단, indegree가 0인 SCC가 여러개이면 이 두개를 서로 오갈수가 없어서, 불가능합니다.&lt;/li&gt;
  &lt;li&gt;SCC 구현은 Tarjan 아니면 Kosaraju인데, Tarjan이 구현할게 적고 좀더 빠릅니다. Kosaraju는 최소 2번 이상의 DFS를 돌아야 하기 때문입니다.&lt;/li&gt;
  &lt;li&gt;별개로 저는 예전에 짜놓은 Kosaraju를 대충 박아넣었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;boj-4196-도미노&quot;&gt;BOJ 4196 도미노&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 4&lt;/li&gt;
  &lt;li&gt;마찬가지로, SCC를 묶은 다음 indegree가 0인 SCC를 찾는 문제입니다. 위 문제와 거의 똑같습니다.&lt;/li&gt;
  &lt;li&gt;다만 이번엔 불가능한 경우가 아니라, indegree가 0인 모든 SCC를 직접 넘어트리면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;icpc-jakarta-regional-2018-boomerangs-boj-16583&quot;&gt;ICPC Jakarta Regional 2018 Boomerangs (BOJ 16583)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 2&lt;/li&gt;
  &lt;li&gt;먼저, 트리에 대해 문제를 풀어 봅시다. 어떤 노드의 child가 짝수개라면, 짝수개의 자식노드들과 현재 노드를 부메랑으로 서로 이어주면 됩니다.&lt;/li&gt;
  &lt;li&gt;홀수개라면, 방금전처럼 잇고, 이어지지 않은 하나의 노드와 현재 노드, 현재 노드의 부모 노드를 부메랑으로 이어주면 됩니다.&lt;/li&gt;
  &lt;li&gt;이때, 부모 노드에게 현재 노드는 이미 사용되었으므로 부모 노드의 자식노드를 잇는 과정에 참여하면 안 된다는 사실을 report해야 합니다.&lt;/li&gt;
  &lt;li&gt;이렇게 하면, 트리를 DFS 순서로 돌면서 모든 간선을 (간선이 홀수개면 1개 빼고) 부메랑에 참여시킬 수 있습니다.&lt;/li&gt;
  &lt;li&gt;따라서, 트리에 대해서는 문제를 해결하였습니다. 이를 일반화해서 임의 그래프에 대해 해결해 보겠습니다.&lt;/li&gt;
  &lt;li&gt;우리는 정점이 중요하지 않고, 간선만 중요하므로, 그래프를 강제로 트리처럼 펴면 됩니다. 이 방법은, 사이클을 이루기 시작하는 간선을 만나면 그 간선의 끝에 새로운 정점을 만들어서, 사이클을 이루지 못하게 막으면 됩니다. 이때 새로운 정점은 나중에 부메랑을 만들 때 다시 원래 정점으로 돌려줘야 하기에, 이 사실을 기억해야 합니다.&lt;/li&gt;
  &lt;li&gt;말은 복잡하지만, 코드는 굉장히 깔끔하게 나옵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build_tree(r, p)&lt;/code&gt; 함수를 보면 됩니다.&lt;/li&gt;
  &lt;li&gt;전체 과정을 DFS 2번으로 해결할 수 있습니다. 두번째 BFS인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build_boo(r, p)&lt;/code&gt; 에서, child node 들 중 이미 사용한 노드를 표현하는 등 디테일은 조금 주의해야겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ps_weekly" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">서울대학교 컴퓨터공학부 전공과목 (주관적인) 소개</title><link href="http://localhost:4000/snu-courses/SNU-courses-CS/" rel="alternate" type="text/html" title="서울대학교 컴퓨터공학부 전공과목 (주관적인) 소개" /><published>2021-07-24T00:00:00+09:00</published><updated>2021-07-24T00:00:00+09:00</updated><id>http://localhost:4000/snu-courses/SNU-courses-CS</id><content type="html" xml:base="http://localhost:4000/snu-courses/SNU-courses-CS/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1학년-과목&quot; id=&quot;markdown-toc-1학년-과목&quot;&gt;1학년 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#컴퓨터의-개념-및-실습&quot; id=&quot;markdown-toc-컴퓨터의-개념-및-실습&quot;&gt;컴퓨터의 개념 및 실습&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로그래밍-연습&quot; id=&quot;markdown-toc-프로그래밍-연습&quot;&gt;프로그래밍 연습&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#이산수학&quot; id=&quot;markdown-toc-이산수학&quot;&gt;이산수학&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2학년-과목&quot; id=&quot;markdown-toc-2학년-과목&quot;&gt;2학년 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#컴퓨터-프로그래밍&quot; id=&quot;markdown-toc-컴퓨터-프로그래밍&quot;&gt;컴퓨터 프로그래밍&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#논리설계&quot; id=&quot;markdown-toc-논리설계&quot;&gt;논리설계&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#자료구조&quot; id=&quot;markdown-toc-자료구조&quot;&gt;자료구조&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#컴퓨터구조&quot; id=&quot;markdown-toc-컴퓨터구조&quot;&gt;컴퓨터구조&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로그래밍-언어&quot; id=&quot;markdown-toc-프로그래밍-언어&quot;&gt;프로그래밍 언어&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#전기전자회로&quot; id=&quot;markdown-toc-전기전자회로&quot;&gt;전기전자회로&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-4학년-과목&quot; id=&quot;markdown-toc-3-4학년-과목&quot;&gt;3-4학년 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#알고리즘&quot; id=&quot;markdown-toc-알고리즘&quot;&gt;알고리즘&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#양자-컴퓨팅의-기초&quot; id=&quot;markdown-toc-양자-컴퓨팅의-기초&quot;&gt;양자 컴퓨팅의 기초&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#데이터베이스&quot; id=&quot;markdown-toc-데이터베이스&quot;&gt;데이터베이스&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#소프트웨어-개발의-원리-및-실제&quot; id=&quot;markdown-toc-소프트웨어-개발의-원리-및-실제&quot;&gt;소프트웨어 개발의 원리 및 실제&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#시스템-프로그래밍&quot; id=&quot;markdown-toc-시스템-프로그래밍&quot;&gt;시스템 프로그래밍&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#하드웨어-시스템-설계&quot; id=&quot;markdown-toc-하드웨어-시스템-설계&quot;&gt;하드웨어 시스템 설계&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#창의적-통합-설계&quot; id=&quot;markdown-toc-창의적-통합-설계&quot;&gt;창의적 통합 설계&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#대학원-과목&quot; id=&quot;markdown-toc-대학원-과목&quot;&gt;대학원 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#계산이론&quot; id=&quot;markdown-toc-계산이론&quot;&gt;계산이론&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;가장 쓸 말이 많은 3설계 과목 (소개원실, 하시설, 창통설) 은 별개의 글로 남길 예정입니다.&lt;/p&gt;

&lt;h2 id=&quot;1학년-과목&quot;&gt;1학년 과목&lt;/h2&gt;
&lt;h3 id=&quot;컴퓨터의-개념-및-실습&quot;&gt;컴퓨터의 개념 및 실습&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2018년 1학기 (1학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;굉장한 과목입니다. 들을 때는 몰랐는데, 다른 학교의 1학년 첫 컴공과 기초 과목이 보통 파이썬이나 C를 가르치는데 비해 이 과목은 무려 컴퓨터구조에 대해 배웁니다. LC-3라는 toy computer의 어셈블리는 물론, 기계어로 직접 뭔가를 짜게 합니다.&lt;/li&gt;
  &lt;li&gt;이게 무슨 말이냐면, 보통 C를 배운 후 어셈블리로 넘어가서 C를 통해 어셈블리와 컴퓨터 구조를 이해하는게 일반적인 테크지만, 저희는 반대로 컴퓨터의 폰 노이만 구조와 Program counter, memory model을 먼저 배운 뒤, 어셈블리 (진짜 어셈은 아니지만) 단계에서 이를 이해해보고, 거꾸로 C를 그 위에서 쌓아 나갑니다. 이렇게 배우면 포인터가 안 어렵다는 정도? 장점이 있는것 같습니다.&lt;/li&gt;
  &lt;li&gt;힘들었지만 재밌었습니다. A-인가? 받았습니다. 저는 입학하고 프로그래밍이라는걸 처음 배워본지라… 이때까지는 과고 친구들과 경쟁자체가 안 되더군요 ㅋㅋ&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로그래밍-연습&quot;&gt;프로그래밍 연습&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2018년 2학기 (2학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;C언어의 기초를 배웁니다.&lt;/li&gt;
  &lt;li&gt;기말프로젝트가 카드 뒤집으면서 기억력으로 페어 맞추는 게임 (게임 이름을 까먹었네요) 만드는 거였는데, 재밌었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이산수학&quot;&gt;이산수학&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2021년 1학기 (7학기차) 에 수강했습니다. (왜?? ㅋㅋㅋ)&lt;/li&gt;
  &lt;li&gt;Logic, Group, Probability, Graph, Algorithm 등 종횡무진 뛰어다니며 넓고 얕게 배웁니다.&lt;/li&gt;
  &lt;li&gt;저는 CS/MATH이고 7학기차였으므로 저는 이 과목에서 배우는 모든 내용을 다른 과목에서 배워본 상태였습니다. 처음 듣는 컴공 전공이라면 증명이나 논증을 체계적으로 하는 법을 익히는 좋은 과목이라고 생각합니다. 저는 그 역할을 해석개론이 대신해 줬습니다.&lt;/li&gt;
  &lt;li&gt;너무 늦게 들어서 쉬웠습니다. 1학년 때였다면 느낌이 좀 달랐을것 같습니다. A+.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2학년-과목&quot;&gt;2학년 과목&lt;/h2&gt;
&lt;h3 id=&quot;컴퓨터-프로그래밍&quot;&gt;컴퓨터 프로그래밍&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 1학기 (3학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;객체지향 프로그래밍, 객체지향의 개념에 대해 배웁니다.&lt;/li&gt;
  &lt;li&gt;기말 과제로 체스를 구현하는 과제가 있었습니다. 처음 하면서 꽤 어려웠던 기억이 있습니다.&lt;/li&gt;
  &lt;li&gt;이런걸 익히려면 해보는 방법밖에 없다는 말을 체감하게 됩니다. 코딩을 하다보면 아 이게 그런 말이구나 할 때가 있습니다. A+.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;논리설계&quot;&gt;논리설계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 1학기 (3학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;Boolean Algebra와 카르노 맵으로 시작해서, 논리 게이트, Adder 등 간단한 논리 회로에 대해 배웁니다. 끝부분에는 FSM을 다룹니다.&lt;/li&gt;
  &lt;li&gt;마지막에는 베릴로그로 CPU 짜는 과제가 있었습니다.&lt;/li&gt;
  &lt;li&gt;강의가 정말 재밌고 흡입력있었지만 저는 내용에서 고통받았습니다.&lt;/li&gt;
  &lt;li&gt;Verilog 3부작 중 1부인데, 저는 정말 힘들었습니다. 저는 Verilog와 진짜 안 맞는다는걸 깨달았습니다. B+.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자료구조&quot;&gt;자료구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;저는 입학하자마자 SNUPS에서 kipa00님한테 PS를 배우면서 C++를 익히는 것으로 시작해서, PS를 꽤 열심히 했었기 때문에 이때는 블루~퍼플 근처의 실력이었습니다. (지금도 퍼플을 못 벗어나고 있네요 ㅋㅋ) 2년 더 이때처럼 Training했으면 제가 PS를 더 잘 했을까요? 모르겠네요…&lt;/li&gt;
  &lt;li&gt;가장 집중적으로 PS를 공부했던 시점이라서 자료구조는 쉽게 공부했습니다. A+.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;컴퓨터구조&quot;&gt;컴퓨터구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;컴퓨터공학이 뭔지 알기 위해 딱 2개의 수업만 들을수 있다면 저는 알고리즘과 컴퓨터구조를 뽑겠습니다. 컴퓨터구조에서는 논설의 끝부분을 시작으로, CPU의 내부 구조, Pipelining, Memory Hierarchy, 멀티코어와 멀티스레드 등을 다룹니다.&lt;/li&gt;
  &lt;li&gt;컴퓨터 자체에 대해 가장 많은 내용을 배울 수 있습니다. 언젠가 고급 컴퓨터 구조를 듣고 싶은데 여력이 될지 모르겠습니다.&lt;/li&gt;
  &lt;li&gt;Verilog로 파이프라이닝이 있는 CPU를 짜는 과제가 나왔었는데, 여기서 거의 0점에 가까운 점수를 받았습니다. 이 과제가 아니었다면 나머지는 A+를 충분히 받을 수 있는 성적이었는데 이 과제 하나 때문에 A0를 받았습니다. Verilog는 너무 어려워요…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로그래밍-언어&quot;&gt;프로그래밍 언어&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;OCaml로 함수형 프로그래밍, 메모리 관리, 재귀 호출 등 PL의 핵심 아이디어들을 배웁니다.&lt;/li&gt;
  &lt;li&gt;인터프리터 만드는 과제가 꽤 많은데, 과제가 재밌지만 오래 걸렸습니다.&lt;/li&gt;
  &lt;li&gt;OCaml 프로그래밍이 굉장히 생소했습니다. 그후로 한번도 안써서 이제는 많이 잊어버렸습니다.&lt;/li&gt;
  &lt;li&gt;과제만 잘 하면 되는, 시험 없는 꿀과목입니다만 시험이 없어서 공부를 덜 한것 같기는 합니다. 학점은 A+ 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;전기전자회로&quot;&gt;전기전자회로&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;일반적인 전기전자회로 수업입니다.&lt;/li&gt;
  &lt;li&gt;힘들고 어려웠습니다. 돌이켜 생각해보면 내용이 막 어렵진 않았는데, 공부하기가 너무 힘들었습니다.&lt;/li&gt;
  &lt;li&gt;B+ 받았는데, 논설이랑 이건 좀 얘기가 다릅니다. 이과목은 미적분학이나 공학수학 내용 (미방 풀기) 에 대한 기본 이해가 필요하고, 수식전개를 잘 해야 합니다. 저희과는 지금 고등학교때 문과였던 / 공학수학을 이수하지 않은 복부전생들이 많아서, 이런 과목은 엄청나게 어드밴티지가 있습니다. 그럼에도 불구하고 B+를 받았다는건 제 놀라운 실력을 imply합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-4학년-과목&quot;&gt;3-4학년 과목&lt;/h2&gt;
&lt;p&gt;컴퓨터공학부의 경우, 3-4학년 과목 상당수가 선수관계에 있지 않고 난이도 면에서 큰 차이가 없다고 느껴 같이 서술합니다.&lt;br /&gt;
대부분의 빡센 전필 과목이 3학년 과목이라서 그렇기도 합니다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘&quot;&gt;알고리즘&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;자료구조와 같은 이유로 비교적 편하게 들었습니다.&lt;/li&gt;
  &lt;li&gt;모든 알고리즘 강의에서 강의하는 시간복잡도, 정렬, 탐색, DP, 그리디, 그래프, 최단경로, MST까지 배웁니다.&lt;/li&gt;
  &lt;li&gt;그 후로는 NP-Complete 문제들과 그 환원, matroid 등 재밌는 개념들을 좀 배웠습니다. 이쪽이 주력이셨던 교수님이셨기 때문에 특히 그랬던듯 합니다.&lt;/li&gt;
  &lt;li&gt;비슷한 PS 실력의 다른 사람들에 비해, 저는 이론적인 알고리즘에 관심이 많은 편입니다. 이때쯤에는 이쪽 분야 진학을 계획하기 시작했기 때문에, PS 공부를 이 이후로는 거의 못 했습니다. 그와는 별개로 알고리즘 수업은 정말 재밌게 들었습니다.&lt;/li&gt;
  &lt;li&gt;그리고 뭐… 어쨌든 퍼플이면 학부 알고리즘 수업은 무난하게 들을 수 있습니다. 특히 construction에 강한 사람들보다 (PS를 진짜 잘하는건 이분들입니다) 저처럼 대학와서 PS를 시작해서 academic하게 공부한 사람은 더 그렇습니다. A+ 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;양자-컴퓨팅의-기초&quot;&gt;양자 컴퓨팅의 기초&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;물리학이라고는 1학년 1학기에 교양 B0 맞은 이후로 쳐다본적도 없는데, 갑자기 양자역학의 기초 원리들을 배우게 되어 어려웠습니다.&lt;/li&gt;
  &lt;li&gt;선형대수학을 열심히 들었다면 할만하고, 그렇지 않다면 듣기 힘든 과목인것 같습니다.&lt;/li&gt;
  &lt;li&gt;나머지 CSE 과목들과 아예 다른 트랙 위에 서 있어서, 이것만 들어도 들을만 합니다 (Lin Alg를 안다면)&lt;/li&gt;
  &lt;li&gt;새롭고 재밌었습니다. 아예 새로운 내용을 배우는 과목은 대체로 좋아하는 편입니다. A+ 받았습니다. 코로나버프가 살짝 있었던듯 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터베이스&quot;&gt;데이터베이스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;제게는 학부 지도교수님이신 교수님께서 강의하시는 과목입니다. 상담때 정말 많은 조언을 받았기 때문에 항상 감사한 마음입니다.&lt;/li&gt;
  &lt;li&gt;무려 JAVA로 밑바닥부터 SQL 쿼리를 파싱하고, 이를 처리하는 프로젝트가 있습니다.&lt;/li&gt;
  &lt;li&gt;모든 DB 강의에서 배우는, DB의 원리들, SQL, DB가 가져야할 원칙 등을 배우는, standard한 수업입니다.&lt;/li&gt;
  &lt;li&gt;공대지만 Engineering스러운 과목은 많이 듣지 못했는데, 이 과목은 좀 CS에서는 Engineering스러운 마인드의 과목이라서 나름의 재미가 있었습니다.&lt;/li&gt;
  &lt;li&gt;하지만 프로젝트의 코딩량이 정말 충격적입니다. 저는 주언어가 C++이었고 JAVA 코딩은 컴프-자구 과제 해본게 다였기 때문에 정말 어려웠습니다. 솔직히 C++로 짰으면 짤 수 있었을것 같은데, 뭐 이건 제 코딩실력의 문제이므로 수업 자체의 난이도와는 좀 다른 얘기가 아닌가 싶습니다.&lt;/li&gt;
  &lt;li&gt;지도교수님께서 강의하시는 과목이라서 그런지 나름 더 열심히 들었고, 재밌었지만 제 JAVA 실력에 의해 B+를 받았습니다. 그와는 별개로 여기서 배운 내용은 이후에도 많은 도움이 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;소프트웨어-개발의-원리-및-실제&quot;&gt;소프트웨어 개발의 원리 및 실제&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 2학기 (6학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;실제 개발의 프로세스, 디자인 패턴 등을 배우고, 팀플로 하나의 웹앱을 직접 만들어서 출시해야 하는 과목입니다.&lt;/li&gt;
  &lt;li&gt;어느순간부터 머신러닝을 포함해야 한다는 요구조건이 붙었습니다.&lt;/li&gt;
  &lt;li&gt;대략 5,000 단어 분량의 5부작 후기가 준비되어 있었으나, 다양한 사정으로 퇴고를 거듭한 끝에 블로그에 올리지 못했습니다.&lt;/li&gt;
  &lt;li&gt;학교 다니는 중 가장 힘들었습니다. 4학점 과목이지만 체감 로드는 15학점 이상 됩니다. 저는 2020-1학기 전체 18학점과 이 과목 하나가 비교할 만 하다고 생각합니다.&lt;/li&gt;
  &lt;li&gt;배우는것은 많습니다. SNULife에 있었던 강의평의 일부를 인용하며 짧은 소개를 마치겠습니다. 참고로, snulife 평점 7.8임에도 당도 1.5에 빛납니다. 
이 강의평 이상으로 이 과목을 표현할 자신이 없습니다.&lt;br /&gt;
&lt;strong&gt;“강의가 끝나고 나면 내가 이전의 나와는 다른 프로그래머가 된 것을 느낄 수 있습니다. 그런데 그건 이전의 내가 프로젝트 하다가 죽어서 그런겁니다.”&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;“여튼 이걸 아직 안 들었다면 마음의 준비 단단히 하시고, 윗공대 오실 떄 왠만하면 이불이나 담요 챙겨오시길 바랍니다. 파이팅.”&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;정말 많은 노력을 (15학점 분량 정도) 했고 A-를 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시스템-프로그래밍&quot;&gt;시스템 프로그래밍&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 2학기 (6학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;컴퓨터구조 수업에 이어서, 컴퓨터 내부의 핵심 원리들을 배웁니다. I/O로 시작해서, Virtual memory, malloc의 원리, Pipe와 프로세스간 통신, 멀티스레딩을 배웁니다. 마지막에는 네트워크 기초를 좀 배웁니다.&lt;/li&gt;
  &lt;li&gt;Malloc을 직접 구현하는 malloc lab이 상당히 악명 높습니다.&lt;/li&gt;
  &lt;li&gt;굉장히 유익하고, 배우는게 많으며, 어렵지만 재밌습니다. 컴구와 함께 반드시 들어야 할 컴퓨터공학과 수업입니다. 크게 컴구/시프와 자구/알골 이렇게까지 4개만 들으면 컴공과의 코어 아이디어는 다 가져갔다고 생각합니다. 이후로는 다 개별 과목이라서요…&lt;/li&gt;
  &lt;li&gt;소개원실 플젝이 모든것을 잡아먹어서 기말을 터트리고 A-를 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;하드웨어-시스템-설계&quot;&gt;하드웨어 시스템 설계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2021년 1학기 (7학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;FPGA 보드로 행렬곱셈을 가속해서 CNN을 빠르게 돌리는… 뭐 그런걸 합니다. 로직은 C++로 짜고, FPGA는 베릴로그를 씁니다.&lt;/li&gt;
  &lt;li&gt;베릴로그를 정말 못 하는 제게는 너무 힘든 과목이었지만, 베릴로그 파트는 훌륭한 팀원이 멱살잡고 캐리했습니다. 그 대가로 저는 C++ 코드를 하루종일 들여다보고 포인터 연산을 열심히 해야 했지만 그래도 팀원과 제 로드 배분이 6:4 정도로 제가 조금 버스 탔다고 생각합니다. 이 은혜는 창의통합설계 때 갚아야한다고 다짐했습니다.&lt;/li&gt;
  &lt;li&gt;짧은 후기를 블로그에 쓸 예정입니다.&lt;/li&gt;
  &lt;li&gt;어렵지만 돌이켜보면 남은건 꽤 많습니다. 아쉬운 점은, 플젝을 한학기 내내 했음에도 실제 로드는 마지막 한주에 몰아져 있었다는 점입니다.&lt;/li&gt;
  &lt;li&gt;선배들이 사람에 따라 0.2~0.4 소개원실이라고 조언했는데, 마지막 주가 되기 전까지는 전혀 이해를 못 했습니다. 마지막 주에는 왜 그런지 납득하긴 했지만, 그래도 저는 동의할 수 없습니다. 소개원실 로드의 1/10도 안 됩니다.&lt;/li&gt;
  &lt;li&gt;혹시 이 글을 보는 19~학번 설컴공이라면 한번쯤 고려해보세요. FPGA같은 유망한 기술에 대해 이정도 이해를 위해 이정도 노력은 들일만한 가치가 있습니다.&lt;/li&gt;
  &lt;li&gt;학점은 A0 받았습니다. 팀원이 한단계 정도는 버프해줬다고 생각합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;창의적-통합-설계&quot;&gt;창의적 통합 설계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2021년 2학기 (8학기차) 에 수강예정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대학원-과목&quot;&gt;대학원 과목&lt;/h2&gt;
&lt;h3 id=&quot;계산이론&quot;&gt;계산이론&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2021년 2학기 (8학기차) 에 수강예정&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="snu-courses" /><summary type="html">Contents</summary></entry><entry><title type="html">서울대학교 수리과학부 전공과목 (주관적인) 소개</title><link href="http://localhost:4000/snu-courses/SNU-courses-MATH/" rel="alternate" type="text/html" title="서울대학교 수리과학부 전공과목 (주관적인) 소개" /><published>2021-07-24T00:00:00+09:00</published><updated>2021-07-24T00:00:00+09:00</updated><id>http://localhost:4000/snu-courses/SNU-courses-MATH</id><content type="html" xml:base="http://localhost:4000/snu-courses/SNU-courses-MATH/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1학년-과목&quot; id=&quot;markdown-toc-1학년-과목&quot;&gt;1학년 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#수학-및-연습-1-고급수학-및-연습-2&quot; id=&quot;markdown-toc-수학-및-연습-1-고급수학-및-연습-2&quot;&gt;수학 및 연습 1, 고급수학 및 연습 2&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2학년-과목&quot; id=&quot;markdown-toc-2학년-과목&quot;&gt;2학년 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#해석개론-및-연습-1&quot; id=&quot;markdown-toc-해석개론-및-연습-1&quot;&gt;해석개론 및 연습 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#선형대수학-1&quot; id=&quot;markdown-toc-선형대수학-1&quot;&gt;선형대수학 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#선형대수학-2&quot; id=&quot;markdown-toc-선형대수학-2&quot;&gt;선형대수학 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#정수론&quot; id=&quot;markdown-toc-정수론&quot;&gt;정수론&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3학년-과목&quot; id=&quot;markdown-toc-3학년-과목&quot;&gt;3학년 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#위상수학개론-1&quot; id=&quot;markdown-toc-위상수학개론-1&quot;&gt;위상수학개론 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#현대대수학-1&quot; id=&quot;markdown-toc-현대대수학-1&quot;&gt;현대대수학 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#복소변수함수론&quot; id=&quot;markdown-toc-복소변수함수론&quot;&gt;복소변수함수론&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#수치선형대수&quot; id=&quot;markdown-toc-수치선형대수&quot;&gt;수치선형대수&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4학년-과목&quot; id=&quot;markdown-toc-4학년-과목&quot;&gt;4학년 과목&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#최적화의-수학적-이론-및-계산&quot; id=&quot;markdown-toc-최적화의-수학적-이론-및-계산&quot;&gt;최적화의 수학적 이론 및 계산&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#학부-4학년-실변수함수론--대학원-실해석학&quot; id=&quot;markdown-toc-학부-4학년-실변수함수론--대학원-실해석학&quot;&gt;학부 4학년 실변수함수론 / 대학원 실해석학&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;수학과는 선수과목이 꽤 복잡한데 복전생이 듣자니 전공이랑 시간표가 겹치는게 있었어서 일부 선수과목을 좀 독학했습니다. 그것도 여기에 대략 적어넣었습니다.&lt;/p&gt;

&lt;h2 id=&quot;1학년-과목&quot;&gt;1학년 과목&lt;/h2&gt;
&lt;h3 id=&quot;수학-및-연습-1-고급수학-및-연습-2&quot;&gt;수학 및 연습 1, 고급수학 및 연습 2&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2018년 1, 2학기 (1, 2학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;미적분학 (Calculus) 와 벡터 미적분학 (Vector Calculus) 를 배웁니다.&lt;/li&gt;
  &lt;li&gt;김홍종 교수님의 미적분학 (1, 2) 책을 배우는데, Stewart 등 미적분학 책보다는 살짝 빡셉니다.&lt;/li&gt;
  &lt;li&gt;이 책은 각 챕터별로 부록 section이 하나씩 있는데, 고급- 과 일반- 의 차이는 이 부록을 나가느냐 안 나가느냐의 차이입니다.&lt;/li&gt;
  &lt;li&gt;부록에 실수체계의 구성, 변분법 등 굉장히 재밌는 내용들이 많습니다.&lt;/li&gt;
  &lt;li&gt;서울대는 입학고사 성적으로 반배정을 하고, 수및연 1에서 A+을 받으면 고급수학 및 연습 2로 바꿀 수 있습니다. 저는 이걸로 바꿔서 고수에서는 A0를 받았었습니다.&lt;/li&gt;
  &lt;li&gt;별개로, 저는 처음에 면적분과 부피적분, 그린 정리 등을 굉장히 이해하지 못했었습니다. 이런 개념들을 이때 이해하지 못했다는 생각 자체를 잘 못했는데, 나중에 보니 좀 상태가 안 좋다는걸 복소 때 알았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2학년-과목&quot;&gt;2학년 과목&lt;/h2&gt;
&lt;h3 id=&quot;해석개론-및-연습-1&quot;&gt;해석개론 및 연습 1&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 1학기 (3학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;본격적인 수리과학부 전공 과목입니다. 서울대에서는 원래 김성기-김도한-계승혁 교수님 저의 해석개론 (소위 김김계라 부릅니다) 을 쓰지만, 저는 영어강의를 들어서 해당사항은 없었습니다.&lt;/li&gt;
  &lt;li&gt;미분가능성, 연속성, 리만적분 등 고등학교 미적분때부터 대충 배우면서 넘어간 개념들을 체계적으로 배웁니다.&lt;/li&gt;
  &lt;li&gt;저는 개인적으로, 수학에 관심이 많다면 여기까지 들어보는건 정말 좋다고 생각합니다. 고등학교 미적분을 배우다보면 생기는 의문들, 대학 캘큘을 배우다보면 생길수있는 의문들이 여기까지 하면 정리가 되기 때문입니다.&lt;/li&gt;
  &lt;li&gt;해개연 1을 들을때는 전공 수학을 공부하는 방법이 익숙하지 않아서…라기 보다는, 수학과 과목은 그냥 증명 흐름만 대략 알면 될것이라고 생각하고 연습문제를 전혀 풀어보지 않는 등 공부 방법을 잘 몰랐었습니다. 어떤 과목 (해석개론) 은 증명을 직접 써보고 손으로 공부해야 한다는걸 깨우쳐주는 계기가 되었습니다. 학점은 B+ 받았습니다.&lt;/li&gt;
  &lt;li&gt;학점과는 별개로 수학을 더 배우고 싶다는 생각이 든 과목입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;선형대수학-1&quot;&gt;선형대수학 1&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 1학기 (3학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;해석개론과 함께 수학과 전공 진입 과목입니다. 컴공과에게는 사실 꼭 필요한 과목인데, 공학수학에서 어느정도 커버를 하기는 하지만 시간의 문제로 충분하지 않기에 공대 (컴공과) 학생들도 수강하면 많은 도움이 되는것 같습니다.&lt;/li&gt;
  &lt;li&gt;저는 영어강의를 들어서 선대1은 선대군으로 배우지 않았고 (Friedberg의 선형대수 책으로 진도를 나갔습니다), 교수님께서 학생들 다수가 공대임을 의식하신것인지 수학과스럽게 수업을 나가지는 않아서 편하게 들을 수 있었습니다.&lt;/li&gt;
  &lt;li&gt;행렬 계산으로 시작해서, 행렬과 선형 사상의 관계, Dimension theorem, Rank 등을 배웁니다.&lt;/li&gt;
  &lt;li&gt;학점은 A+ 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;선형대수학-2&quot;&gt;선형대수학 2&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년 2학기 (4학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;이 수업은 한국어 수업으로 들었습니다. 유명한 이인석 교수님 저의 “선형대수와 군” 으로 나갑니다. (aka 선대군)&lt;/li&gt;
  &lt;li&gt;Quotient space 같은걸 좀 배우고 나서, $O(n)$ 등 linear group, Bilinear form, Perp theorem 등 핵심적인 선형대수의 아이디어들을 배웁니다. Dual space 부분에서 고통받았습니다.&lt;/li&gt;
  &lt;li&gt;이때 전공을 너무 많이 들어서 약간 overwhelm된 면이 조금 있습니다. 여기에 더해서 실수와 공부 부족으로 중간고사를 완전히 날려먹으면서 B+를 받았습니다. 중간고사 보고 드랍할지 고민을 정말 많이 했는데, 반 들었는데 드랍하기는 좀 아까웠던 기억이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정수론&quot;&gt;정수론&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2021년 1학기 (7학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;다만 교수님께서 원래 Cryptography를 연구하시고, Pollard-Rho 알고리즘의 발전에 지대한 공헌을 하신 등 Computational Number Theory에 가까운 분이시기 때문에 저한테는 정말 재밌는 수업이었습니다.&lt;/li&gt;
  &lt;li&gt;수업중 Algorithmic한 부분들 - 예를들어 Lenstra의 소인수분해 등 - 에 대한 언급이 많았고, 격자이론이나 동형암호에 대한 특강 등 컴퓨터공학 전공인 저한테는 정말 배울게 많았습니다.&lt;/li&gt;
  &lt;li&gt;PS하면서 배운 정수론을 좀더 정확히 이해할 수 있었습니다. 초반에 빠르게 일반적인 정수론의 주제들 (중국인의 나머지 정리, 페르마 소정리, 오일러 피 함수, 르장드르 기호, 이차 잉여, 디리클레 합성곱 등) 을 달린 후, 후반에는 타원곡선, 무리수의 유리근사, 소수정리 등의 재밌는 주제들을 다룹니다.&lt;/li&gt;
  &lt;li&gt;Niven 책 연습문제가 워낙 많고 퀄리티가 좋기로 유명해서 재밌어보이는것만 풀면서도 꽤 많이 배웠습니다.&lt;/li&gt;
  &lt;li&gt;학기 후기때는 학점 포기하고 들어야 한다고 했는데, 저거 쓰면서는 약간 미지에 대한 공포에 잡혀 있었던게 아닌가 싶습니다. 올림피아드 출신 친구들이 중간고사 때까지는 정말 잘 하지만, 그 후로는 어차피 다같이 처음 보는 내용입니다. 오히려 저는 PS와 알고리즘에 관심이 많아서 뒷부분 내용들을 재밌게 들었던지라 A+을 받을 수 있었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3학년-과목&quot;&gt;3학년 과목&lt;/h2&gt;
&lt;h3 id=&quot;위상수학개론-1&quot;&gt;위상수학개론 1&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;모두가 그렇듯 도넛과 커피잔이 위상동형인걸 생각하고 수업을 들으러 갔지만, 세달동안 수많은 정의들을 배웁니다. 마지막에 조금 surface의 분류에 대해 나가면서 클라인 병 등을 머릿속으로 접어보고 뚝배기와 돌이 위상동형임을 깨달을 기회가 주어집니다. 저희는 특이하게 Munkres가 아닌 Kahn 책으로 배우는데, 책이 정말 컴팩트하고 notation이 신기합니다. Product로 $\prod$ 대신 $\times$ 였나? 아무튼…&lt;/li&gt;
  &lt;li&gt;이 과목은 정의가 너무 많고, 언어를 배우는 기분으로 접근해야 해서 꽤 힘들었습니다. 저는 온라인 수업이 이때부터 시작되었기 때문에 중간중간 멈출 수 있어 조금은 편했던 듯 한데, 실시간 강의였으면 중간에 정신이 혼미했을것 같습니다.&lt;/li&gt;
  &lt;li&gt;증명 호흡이 긴 과목을 처음 들어 봤는데, Urysohn Lemma 증명처럼 호흡이 긴 증명을 쪼개고 쪼개면서 아이디어를 하나씩 잡아나가는 법을 익힐 수 있었던 것 같습니다.&lt;/li&gt;
  &lt;li&gt;이때는 수학공부를 그럭저럭 열심히 해서 A+을 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;현대대수학-1&quot;&gt;현대대수학 1&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;위상수학개론과 함께, 정의를 쭉 배우는 과목입니다. 학부 현대대수의 모든 아이디어는 현대대수학 2에 몰려 있다던데, 이건 아직 안 들어서 모르겠습니다. 군 환 체 등 정의, 정의, 정의, 성질 몇개, 다시 정의.&lt;/li&gt;
  &lt;li&gt;Fraleigh의 현대대수학 책을 쓰는데, 책 자체가 좀 친절한 편이고 특히 Kahn처럼 컴팩트한 책을 보다가 이걸 보면 정말 옆에 붙어서 가르쳐주는 느낌의 책이기 때문에 조금은 편했습니다.&lt;/li&gt;
  &lt;li&gt;학점은 A0 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;복소변수함수론&quot;&gt;복소변수함수론&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 1학기 (5학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;수리과학부는 타과생용 과목이 있는데, 복소함수론 1의 타과생용 에디션입니다. 실제로 다루는 내용이 많이 다른지 여부는 잘 모르겠습니다. 얘기를 들어보면 교수님에 따라 다르지만 같은 교수님께서 강의하시면 별로 많이 다르지 않은것 같기도 합니다.&lt;/li&gt;
  &lt;li&gt;Gamelin의 complex analysis책을 배우는데, 한학기만에 달려야 하기 때문에 복소적분, 코시리만, 코시적분공식, 유수정리 등 코어한 내용들만 쭉쭉 나갑니다.&lt;/li&gt;
  &lt;li&gt;마지막에 소수정리를 복소해석으로 증명하는 내용을 배웠는데, 굉장히 궁금했던 내용이었기때문에 정말 재밌게 들었습니다. 해석적 정수론이 대충 뭐 하는 건지 구경하는 느낌이었는데 적분이 정말 빡세더군요… ㅋㅋㅋ&lt;/li&gt;
  &lt;li&gt;위상이나 현대는 더 위를 위한 빌드업 느낌이었는데, 이 과목은 그럭저럭 Self-contained된 내용이었기 때문에 저는 특히 재밌게 들었습니다. 복소적분을 할줄안다는게 제 앞으로의 공부에 어떤 도움이 되는지는 사실 잘 모르겠긴 합니다.&lt;/li&gt;
  &lt;li&gt;학점은 A+ 받았습니다. 코로나버프가 살짝 있었던듯 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수치선형대수&quot;&gt;수치선형대수&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2021년 1학기 (7학기차) 에 수강했습니다. 제가 학기 끝나고 쓴 학기 후기에서 얘기했던게 있어서 그대로 가져옵니다.&lt;/li&gt;
  &lt;li&gt;수리과학부 수치해석 루트의 메인 과목입니다. MATLAB 또는 Python을 이용한 프로그래밍도 해야 하고, 과제의 양이 정말 충격적으로 많았는데 그만큼 많이 배웠다고 생각합니다. 중간고사 때까지는 사실 많은 내용을 어디서 주워들은 것들이라고 생각했었는데, 중간고사를 보고 딱히 그렇지 않음을 깨달은 뒤 (…) 기말고사는 열심히 공부하고 봤습니다.&lt;/li&gt;
  &lt;li&gt;간단히 요약하자면, 행렬에 대한 알고리즘을 배우는 과목입니다. numpy의 수많은 알고리즘들을 그대로 가져다 쓸수도 있겠지만, 누군가는 그런것들을 만들어야 하니까요. 예를 들어, 1000 * 1000 행렬의 eigenvalue를 어떻게 구할지, eigenvalue 전부가 아니라 몇개만 필요하다면 어떻게 구할지… $Ax = b$는 정해진 해 $x = A^{-1} b$ 가 있지만, 세상에는 감히 역행렬을 구할 시도조차 할 수 없는 사이즈의 문제들이 있습니다. 그렇기에 iteration method 등 여러 clever 한 알고리즘들을 써야 하는데, 그런 부분들을 배웁니다.&lt;/li&gt;
  &lt;li&gt;후반부 내용들은 굉장히 새로웠습니다.&lt;/li&gt;
  &lt;li&gt;과제를 하다 보니 매트랩도 좀 배울 수 있었습니다. 파이썬/매트랩 선택인데 저는 파이썬을 할줄 알았지만 교재가 매트랩이라 매트랩 쓰는게 정신적으로 덜 고통스럽습니다.&lt;/li&gt;
  &lt;li&gt;학점은 A+ 받았습니다. 졸논 주제도 이쪽이 되지 않을까 싶습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;4학년-과목&quot;&gt;4학년 과목&lt;/h2&gt;
&lt;h3 id=&quot;최적화의-수학적-이론-및-계산&quot;&gt;최적화의 수학적 이론 및 계산&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2020년 2학기 (6학기차) 에 수강했습니다.&lt;/li&gt;
  &lt;li&gt;중간고사 때까지는 제대로 공부를 못 했습니다. 기말고사 전에는 수학과 16학번의 지인과 함께 스터디 식으로 책에 있는 거의 모든 연습문제를 풀어봤고, 증명들 따라가 봤는데 많은 도움이 되었습니다&lt;/li&gt;
  &lt;li&gt;Convex optimization (Boyd 저) 은 한 5주 정도 Part 1만 나갔고, 그 후에는 교수님께서 저술하신 책으로 주로 monotone operator를 이용한 내용들을 나갔습니다. (Convex도 중요하게 쓰이기는 한다) ADMM 등 알고리즘들을 엔지니어로써 사용하기는 하더라도 그 이면의 원리나 수학적인 이론, 수렴성의 증명과 조건 등등에 대해 명확하게 이해하기가 쉽지 않은데, 그런 틀을 잡을 수 있는 과목이었다고 생각합니다. 해석학적인 베이스가 조금 더 있었다면 훨씬 재밌게, 잘 들을 수 있었을 것 같다는 아쉬움은 조금 남습니다.&lt;/li&gt;
  &lt;li&gt;SRG라고 해서, Operator를 기하로 옮겨서 놀라운 유클리드 기하의 원리들을 이용하여 수렴성을 증명하는 생전 처음 보는 내용을 배웠는데, 무려 이 과목을 강의하시는 교수님께서 연구해서 창안하신 내용입니다.&lt;/li&gt;
  &lt;li&gt;예전에는 공부를 더 했으면 더 좋았을텐데 아쉽다는 말을 티스토리 블로그에 적었었는데, 중간고사때는 소개원실 + 시프, 기말고사는 소개원실 + 소개원실 때문에 더 하고 싶어도 할 수가 없었습니다.&lt;/li&gt;
  &lt;li&gt;LaTeX로 필기노트를 옮긴다면 옮길 과목 1순위입니다.&lt;/li&gt;
  &lt;li&gt;학점은 A0 받았습니다. 중간고사때 공부를 좀 더 할 수 있었으면 좋았을것 같습니다. Convex Opt의 나머지 내용은 언젠가 따로 공부해봐도 재밌을것 같습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;학부-4학년-실변수함수론--대학원-실해석학&quot;&gt;학부 4학년 실변수함수론 / 대학원 실해석학&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;두 과목을 동시에 2021년 1학기 (7학기차) 에 수강했습니다. 제가 학기 끝나고 쓴 학기 후기에서 얘기했던게 있어서 그대로 가져옵니다.&lt;/li&gt;
  &lt;li&gt;이 과목을 추천한 수학과 지인을 거의 이틀에 한번씩 욕했지만, 돌이켜 생각해보면 수학과를 복전하면서 이정도 재미와 Challenge는 있어야 하지 않나 싶습니다. 원한다면 수치해석이나 CS스러운 수학과목만 내리 들을 수도 있었겠지만 그러자니 겹치는것도 많고… 대수랑 해석 중 하나를 골라서 좀 높은 레벨의 과목, 본전공생들 수준으로 들을 수 있는 과목을 들어보려고 했는데 해석이 되었네요.&lt;/li&gt;
  &lt;li&gt;실해석학은 워낙 유명한 과목으로 대학원 1년차 과목임에도 학부생 수강생이 훨씬더 많고 타과생도 많습니다만 제기억에 컴공과는 저밖에 없었습니다. 주로 해석학을 배워야 하는 통계학과, (왜인지 저는 잘 모르겠지만 이론적 공부에는 필요하다고 들은거같은) 경제학과가 많았습니다.&lt;/li&gt;
  &lt;li&gt;Graduate / Undergraduate을 나눠서 GRA / URA로 구분하자면, GRA는 루딘의 Real and Complex Analysis의 앞부분 반정도를 커버하고, URA는 Folland의 Real Analysis를 기준으로 그중 일부를 나갑니다. 두 과목의 가장 큰 차이는 ‘세팅’ 이었다고 생각하는데, GRA는 Locally Compact Hausdorff space X를 기본 세팅으로 두는데 비해 URA의 기본 세팅은 $\R$ 또는 $\R^2$ 입니다. 예를들어 Fourier Series를 이해하기 위해 URA에서는 직접 적분을 계산하고 Dirichlet Kernel, Fejer Kernel 등등을 이용하여 내용을 진행하는데 비해, GRA에서는 Hilbert space (완비내적공간)에 대한 일반적인 성질들을 공부하고 그걸 $L^2([-\pi, \pi])$ 에 적용하는 식입니다.&lt;/li&gt;
  &lt;li&gt;그렇다보니 Measure theory, Lebesgue 적분 등을 두가지 관점에서 동시에 보면서 (뚝배기가 박살나긴 했지만) 재밌게 공부할 수 있었습니다. 종합해서 해석학에 대한 이해를 높일 수 있었다고 생각합니다.&lt;/li&gt;
  &lt;li&gt;다만 저처럼 수학을 찍먹할 사람이면 모를까, 수학 전 분야에 대한 이해를 좀 가져야 할 수리과학 전공생들에게 권할만한 테크인지는 잘 모르겠습니다. Redundancy가 있는건 사실이니까요. 저는 복수전공자니까 전필만 듣고나면 제가 듣고싶은거 적당히 골라듣고 챙기면서 움직여도 뭐 되지 않을까요.&lt;/li&gt;
  &lt;li&gt;Measure theory를 공부하게 된 계기는, 3학년 2학기 때 수강했던 최적화 이론입니다. 최적화 이론에서 Martingale 등 놀라운 이론들을 통해 수렴성을 얻는게 좀 있었는데, 도대체 수렴하면 수렴하는거지 Almost surely converge한다는건 무슨소리인가??? 에 대해 답할 수 있게 되었습니다. 최적화이론 수업 이후 조언을 구하였을 때, measure theory와 stochastic differential equation에 대한 공부가 최적화 분야의 엄밀한 이해에 도움이 될 것이라는 조언을 얻을 수 있었습니다.&lt;/li&gt;
  &lt;li&gt;학점은 대학원 실해석은 A+, 학부 실변수는 A0를 받았습니다. 명확히 실해석이 더 상위 과목임에도 학점이 이렇게 된 이유는 단순히 실해석 시험이 좀더 제 스타일에 맞았기 때문입니다. ㅋㅋ!&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="snu-courses" /><summary type="html">Contents</summary></entry><entry><title type="html">Karger-Stein Minimum Cut</title><link href="http://localhost:4000/advanced_algorithms/karger-stein-mincut/" rel="alternate" type="text/html" title="Karger-Stein Minimum Cut" /><published>2021-07-23T00:00:00+09:00</published><updated>2021-07-23T00:00:00+09:00</updated><id>http://localhost:4000/advanced_algorithms/karger-stein-mincut</id><content type="html" xml:base="http://localhost:4000/advanced_algorithms/karger-stein-mincut/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#min-cut&quot; id=&quot;markdown-toc-min-cut&quot;&gt;Min Cut&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#s-t-min-cut&quot; id=&quot;markdown-toc-s-t-min-cut&quot;&gt;s-t min cut&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#kargers-algorithm&quot; id=&quot;markdown-toc-kargers-algorithm&quot;&gt;Karger’s Algorithm&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#edge-contraction&quot; id=&quot;markdown-toc-edge-contraction&quot;&gt;Edge contraction&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#algorithm&quot; id=&quot;markdown-toc-algorithm&quot;&gt;Algorithm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#proof&quot; id=&quot;markdown-toc-proof&quot;&gt;Proof&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#time-complexity&quot; id=&quot;markdown-toc-time-complexity&quot;&gt;Time Complexity&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#karger-stein-algorithm&quot; id=&quot;markdown-toc-karger-stein-algorithm&quot;&gt;Karger-Stein Algorithm&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#time-complexity-of-iteration&quot; id=&quot;markdown-toc-time-complexity-of-iteration&quot;&gt;Time Complexity of iteration&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#probability-of-success&quot; id=&quot;markdown-toc-probability-of-success&quot;&gt;Probability of Success&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#total-time-complexity&quot; id=&quot;markdown-toc-total-time-complexity&quot;&gt;Total time complexity&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#extension&quot; id=&quot;markdown-toc-extension&quot;&gt;Extension&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;min-cut&quot;&gt;Min Cut&lt;/h2&gt;
&lt;p&gt;Min Cut 문제란, 어떤 그래프 $G = (V, E)$ 가 주어졌을 때, $V$의 정점들을 두 집합 $S, T$ 로 나누어서, \(\Setcond{(u, v) \in E}{u \in S, v \in T}\) 즉, 한쪽 끝이 $S$에, 다른쪽 끝이 $T$에 들어가는 간선들의 개수를 최소화하는 문제입니다.
Weighted graph에서는 간선의 개수가 아니라 weight의 합을 최소화하는 문제로 바꾸어 생각하면 됩니다.&lt;/p&gt;

&lt;p&gt;우리는 논의를 위해, 편의상 그래프를 unweighted connected의 경우로만 한정하겠습니다. Directed / Undirected는 (그림은 undirected로 그리더라도) 사실 문제 자체가 똑같습니다. 알고리즘의 측면에서는 조금 차이가 있으므로, 좀더 일반적인 directed graph의 경우를 생각하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/6847c6f5d096dda16e319ccb61c02cc4d3f7dd6a2dc0198741a96670c976cad9.png&quot; alt=&quot;picture 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 이 그림에서 빨간색 cut은 간선 3개짜리 cut이지만, 초록색 cut은 간선 1개짜리입니다.&lt;/p&gt;

&lt;h2 id=&quot;s-t-min-cut&quot;&gt;s-t min cut&lt;/h2&gt;
&lt;p&gt;Min cut 문제의 variation 중 하나는, s-t min cut 이라는 문제입니다. 이 문제는 $s, t$ 라는 두 정점이 각각 $S, T$에 속해야 한다는 추가 제약조건이 걸린 min cut 문제입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매우 유명한 Max-Flow-Min-Cut Theorem에 의하면, s-t min cut 문제는 s-t max flow로 계산할 수 있습니다. 구체적으로, $s$ 에서 $t$로 가는 max flow와 $s-t$ min cut의 크기가 같다는 정리입니다.&lt;/li&gt;
  &lt;li&gt;이 정리의 핵심 아이디어는 두 문제를 각각 LP (Linear Programming) 문제로 바꾼 후, 두 LP를 비교하는 것입니다. 두 LP는 서로 primal-dual 관계에 있음을 알 수 있는데, Dual Linear Program의 Strong duality theorem에 의하면, LP의 경우 strong duality를 갖기 때문에 두 문제의 최적값, 즉 max-flow와 min-cut의 결과값이 같습니다.&lt;/li&gt;
  &lt;li&gt;Primal-Dual LP나 Strong duality에 대한 증명은 이 포스팅의 범위를 넘어가는 이야기이기 때문에 생략합니다. 궁금하다면 &lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 을 참고. Farkas Lemma 등 알아야 할 내용이 상당히 많습니다.&lt;/li&gt;
  &lt;li&gt;Dinic의 알고리즘으로 max flow를 $O(V^2 E)$ 에 해결할 수 있고, $E$ 를 $V^2$ 까지 갈 수 있음을 감안하면&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 현재 실질적으로 가장 빠른 flow는 $O(V^3)$ 시간에 도는 알고리즘들이 있습니다. (Push-Relabel with FIFO)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제, 일반적인 min cut을 풀고자 한다고 생각해 봅시다. 당연히, 모든 정점 페어를 $s, t$로 잡고 s-t min cut을 해보는 방법을 생각할 수 있으므로, 우리는 적어도 $O(V^5)$ 알고리즘을 가지고 있습니다. 이보다 나은 방법을 생각해 봅시다. 이하, 시간 복잡도를 쓸 때 정점이 $n$ 개, 간선이 $m$개라고 생각하겠습니다. 즉 $\abs{V} = n, \abs{E} = m$.&lt;/p&gt;

&lt;h2 id=&quot;kargers-algorithm&quot;&gt;Karger’s Algorithm&lt;/h2&gt;
&lt;p&gt;지금은 MIT의 교수로 계신 Prof. David R Karger가 제시한 Karger’s Algorithm은 Edge contraction이라는 연산에 기반하는, 매우 간단하고 elegant한 알고리즘입니다.&lt;/p&gt;

&lt;h3 id=&quot;edge-contraction&quot;&gt;Edge contraction&lt;/h3&gt;
&lt;p&gt;Edge contraction이란, 말 그대로 edge 양쪽 끝을 접합하는 연산입니다. Edge $e = (u, v)$를 contract한 그래프 $G / e$ 는 다음과 같은 과정을 통해 만들어집니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(u, v)$ 의 양쪽 vertex $u$ 과 $v$를 합쳐 하나의 vertex $w$를 만듭니다.&lt;/li&gt;
  &lt;li&gt;$(u, x)$ 나 $(v, x)$ 가 있으면 이걸 모두 $(w, x)$ 로 만듭니다. 이때, parallel edge는 허용되어야 합니다. &lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;같은 방법으로 $(x, u), (x, v)$ 에 대해서도 같은 과정을 거칩니다.&lt;/li&gt;
  &lt;li&gt;단, $(u, v)$ 간선은 삭제합니다. self loop은 허용하지 않고, $(w, w)$는 없애 버립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 이런 식입니다. 그림을 보면 거의 바로 이해가 갈듯 합니다. 
&lt;img src=&quot;../../images/2c92dd9b9bc3f0c9411cacedc64addffa22ed1adce7826e5922051264953e220.png&quot; alt=&quot;picture 1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h3&gt;
&lt;p&gt;Karger’s Algorithm은 정말 어이가 없을 정도로 간단합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Edge Contraction을 계속 진행해서, 노드 두개와 그 노드 두개 사이의 간선 $k$ 개가 남았다고 합시다.&lt;/li&gt;
  &lt;li&gt;재미있는 사실은, 우리의 Edge contraction은 사실 &lt;strong&gt;이 두 정점은 같은 집합에 있다&lt;/strong&gt; 라고 처리하는 것과 동치입니다.&lt;/li&gt;
  &lt;li&gt;따라서, 남은 두개의 정점 $a, b$에 대해 &lt;strong&gt;a로 합쳐진 정점의 집합&lt;/strong&gt; 과 &lt;strong&gt;b로 합쳐진 정점의 집합&lt;/strong&gt; 을 $S, T$로 삼으면, 마지막 순간에 $a, b$를 잇는 $k$개의 간선이 cut edge가 됩니다.&lt;/li&gt;
  &lt;li&gt;그러므로, 정점을 무작정 랜덤하게 줄여나가다가 2개가 남으면 (min cut은 아니겠지만) cut을 하나 얻습니다.&lt;/li&gt;
  &lt;li&gt;우리는, 이걸 충분히 많이 반복하면 min cut을 얻을 확률이 충분히 높음을 논증하고자 합니다. 구체적으로, 이렇게 cut을 하나 얻는 과정까지를 $q$ 번 반복하여, 그동안 얻은 cut들 중 가장 작은 (간선이 적은) cut을 취하는 것을 생각하겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;/h3&gt;
&lt;p&gt;min cut의 크기를 편의상 $K$ 라고 하고, 실제 cut edge의 집합을 $C$라고 하겠습니다. 이제, 위 알고리즘이 C를 반환할, 즉 올바른 답을 제공할 확률은 $K$개의 Edge가 $n-2$번의 contraction을 모두 살아남아야 합니다. 각 contraction에서는 남은 edge들 중 하나를 &lt;strong&gt;임의로&lt;/strong&gt; contraction해버리므로, 매 스텝을 모두 살아남을 확률은 
\(\prod_{i = 0}^{n-3} \left(1 - \frac{K}{E - i}\right)\)
이렇게 계산됩니다. 그런데, $\frac{K}{E - i}$ 는 잘 생각해보면 좋은 바운드를 잡을 수 있습니다.&lt;/p&gt;

&lt;p&gt;Contraction을 진행하는 과정 중 한 번이라도 만약 어떤 정점 $u$ 가 $d_u &amp;lt; K$ 를 만족한다면, $u$ 와 나머지를 자르는 cut의 크기가 $d_u$ 가 되기 때문에, 정의로부터 모든 정점의 degree는 $K$보다 언제나 크게 됩니다. 따라서 $i$번째 contraction 이전 남은 정점이 $n - i$개이므로 전체 edge의 개수는 $\frac{K(n-i)}{2}$ 개보다 크고, 위 확률 계산은 
\(p_{success} \geq \prod_{i = 0}^{n-3} \left(1 - \frac{2}{n - i}\right) = \frac{1}{\binom{n}{2}}\)
이렇게 계산되게 됩니다.&lt;/p&gt;

&lt;p&gt;편하게, 대충 성공 확률이 $1 / n^2$ 스케일이 된다고 하겠습니다 (이거보다 2배 좀 더되게 높습니다). 만약 우리가 이 알고리즘을 $n^2 \log n$ 번 시도한다면, 개별적인 성공확률이 $1 / n^2$ 인 베르누이 시행을 $n^2 \log n$ 번 하는 것이므로, 모두 실패할 확률은 $\left(1 - \frac{1}{n^2}\right)^{n^2 \log n}$ 이고, 이 값은 $1/n$ 미만입니다. &lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;이정도 실패확률이라면 충분히 큰 $n$에 대해서 받아들일만 합니다. 따라서, 우리는 이 알고리즘을 $n^2 \log n$ 번 정도 실행하면 된다고 생각할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;time-complexity&quot;&gt;Time Complexity&lt;/h3&gt;
&lt;p&gt;그래프 알고리즘이 대개 그렇듯 한번당 드는 시간은 구현하기 나름입니다. Adjacency matrix가 있다면 $O(n^2)$ 으로 구현하면 되고, Adj list가 있다면 $O(m)$ 비슷한 시간이 걸리는게 그럴듯해 보입니다. 가장 쉽게 짜는 방법은 Kruskal 알고리즘을 구현할 때처럼 구현하는 방법이고, 이 방법의 구현체는 (언젠가 제가 구현하면 구현체 링크를 올릴 예정입니다) $O(m \log m)$ 정도에 돌게 할 수 있습니다. 이렇게 짜면 $m \approx n^2$ 일 때 최대 $O(n^2 \log n)$ 이 되므로, 전체 복잡도는 $O(n^4 \log^2 n)$ 이 되겠습니다.&lt;/p&gt;

&lt;p&gt;구현을 잘 하면 한번 iteration을 $O(m)$ 에 돌게 해서, $O(n^4 \log n)$ 에 구겨 넣을 수 있습니다만, 이건 그래프 구현을 잘 하는지의 문제이므로 우리는 다루지 않겠습니다. 다만, 알고리즘의 분석에는 중요하므로, Karger 알고리즘을 잘 구현했을 때의 복잡도는 한번 Iteration에 $O(n^2)$, $n^2 \log n$ 번 반복할 것이므로 $O(n^4 \log n)$ 이다 라고 쓰겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;karger-stein-algorithm&quot;&gt;Karger-Stein Algorithm&lt;/h2&gt;
&lt;p&gt;Karger-Stein은 위 알고리즘과 거의 똑같지만, Clever idea가 살짝 추가되어 훨씬 빨라집니다. 다시 앞서의 확률 계산으로 돌아가겠습니다. 
\(p_{success} \geq \prod_{i = 0}^{n-3} \left(1 - \frac{2}{n - i}\right)\)
이제, 여기서 관찰하고 싶은 사실은, 초반보다 후반에 성공확률이 빠르게 낮아진다는 점입니다. 즉 초반에는 마구 뽑아도 대충 맞을것이라고 기대할 수 있지만, 후반에는 점점 불안해지기 시작한다는 것이죠. 따라서, 초반에는 대충 뽑아서 믿음을 가지고 돌리다가, 후반에는 좀 빡세게 보면 좋지 않을까요?&lt;/p&gt;

&lt;p&gt;이점에 착안한 Karger-Stein은 노드 개수가 대충 $V / \sqrt{2}$개가 될때까지는 그냥 노드를 Karger처럼 줄이다가, 노드가 저만큼 남으면 두배로 많이 검토합니다. 이 수치를 쓰는 이유는, 계산해 보면 $V / \sqrt{2}$개의 노드가 남을 때까지 Contraction을 하면 이동안 min cut이 살아남을 확률이 $1/2$ 가 살짝 넘기 때문입니다. 즉, 원래 Karger 알고리즘은 $n$개부터 $2$개까지 줄여보는걸 한 스텝이라고 정의했지만, $n$ 개부터 $n / \sqrt{2}$ 개까지는 그냥 막 줄이고, $n / \sqrt{2}$ 부터 $n / 2$ 개가 될 때까지 줄여보는 행동은 두번 해서 나은걸 고르고… 이런 식입니다. 단, 재귀적으로 작동한다는 점을 주의해야 합니다. Pseudocode를 쓰면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/a6218b939c81ba01c49e2e77a0a361466d92cb79b6f7de646e29f7602ef6a480.png&quot; alt=&quot;picture 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contract(G, t)&lt;/code&gt; 함수는 $G$의 edge가 $t$가 될 때까지 랜덤하게 contraction해서 줄이는 함수입니다. 6은 별 의미가 있는 상수는 아니고, 그냥 base case를 준 것으로 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이 알고리즘의 성공 확률과 실행 시간에 대해 이해해 보겠습니다. 단, 위키피디아나 여러 자료에는 ceil 등으로 좀 정확하게 써있지만 우리는 어차피 big-O notation에 ceil을 하냐마냐는 영향도 없고… 대충 모든 수를 정수라고 생각하고 넘기겠습니다. $n / \sqrt{2}$ 같은걸 대충 쓰기로 합시다. (사실 분석에는 아무 문제 없습니다!)&lt;/p&gt;

&lt;h3 id=&quot;time-complexity-of-iteration&quot;&gt;Time Complexity of iteration&lt;/h3&gt;
&lt;p&gt;편하게, Ceiling 같은거 다 날리고 점화식을 써 보겠습니다. 위 Pseudocode의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastmincut(G)&lt;/code&gt;가 정점 $n$개의 그래프일 때, Contract 한번이 정점 개수만큼의 시간을 소모함을 고려하면&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; , $\sum_{i = n / \sqrt{2}}^{n} i$ 는 $O(n^2)$ 이므로 (대충 $n^2 / 4$ 정도 된다는걸 보이기 별로 어렵지 않습니다),&lt;br /&gt;
\(T(n) = 2 T(n / \sqrt{2}) + O(n^2)\)
이런 점화식을 얻습니다. 우리 모두 알고리즘 시간에 이미 배운 마스터 정리를 쓰면, $\log_{\sqrt{2}} 2 = 2$ 이므로, $T(n) = O(n^2 \log n)$ 을 얻습니다. 즉, 한번 연산에는 $n^2 \log n$ 시간이 걸린다는 것입니다. 앞서의 Karger과 비교하면, 두배로 연산을 늘리는 과정에서 $\log n$ 만큼의 시간을 추가로 지불했다는것을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;probability-of-success&quot;&gt;Probability of Success&lt;/h3&gt;
&lt;p&gt;이제 한번 시도의 성공 확률에 대해 알아야 합니다. $P(n)$ 을 $n$개 정점에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastmincut&lt;/code&gt;의 결과가 올바를 확률이라고 하면, 이 함수가 실패하기 위해서는 두 개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastmincut(n / sqrt(2))&lt;/code&gt; 가 모두 실패해야 합니다. 따라서, 다음 점화식을 쓸 수 있습니다.
\(P(n) = 1 - \left(1 - \frac{1}{2} P\left(\frac{n}{\sqrt{2}}\right)\right)^2\)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;먼저, 맨 안쪽에 붙는 1/2 는, $n$개에서 $n / \sqrt{2}$ 로 줄일 때 맞게 줄였을 확률이 1/2 밖에 되지 않기 때문입니다. 사실 이 확률이 1/2보다 살짝 크다는 것을 증명할 수 있기 때문에 $P(n) \geq$ 로 시작하는 부등식으로 쓰는 것이 맞습니다.&lt;/li&gt;
  &lt;li&gt;그다음은 당연히, $P(n / \sqrt{2})$ 로, 이 알고리즘이 재귀적으로 맞을 확률을 써 줍니다.&lt;/li&gt;
  &lt;li&gt;우리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 - (둘 다 실패할 확률)&lt;/code&gt; 을 구하므로, 이는 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 - (하나가 실패할 확률)^2&lt;/code&gt; 가 됩니다. 하나가 실패할 확률은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 - (하나가 성공할 확률)&lt;/code&gt; 이므로, 위와 같이 구하는 것이 정당합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제, 이 식을 푸는 방법은 Induction입니다.&lt;/p&gt;

&lt;p&gt;위 식을 잘 전개하면, $P(n) = P(n / \sqrt{2}) - \frac{1}{4} P(n / \sqrt{2})^2$ 임을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;우리는 이제 $P(n) \geq \frac{1}{\log{n}}$ 을 주장합니다. (단, 로그는 로그2) By induction, 다음의 오른쪽 부등호를 증명하면 증명이 끝납니다.
\(P(n) \geq \frac{1}{\log(n/\sqrt{2})} - \frac{1}{4\log^2(n/\sqrt{2})} \geq \frac{1}{\log n}\)
이 부등식을 직접 풀기는 조금 귀찮지만, 별로 어렵지는 않습니다. 솔직히, 대학원 알고리즘 수업에서 배우는 내용에 대한 글을 여기까지 읽을만큼 흥미와 관심이 있는 &lt;del&gt;이상한&lt;/del&gt; 사람이라면 저정도 부등식은 증명하기 별로 어렵지 않을 것 같지만, 칼을 들었으면 무를 썰어야 한다는 철학에 의해 중간 스텝을 대충 생략하더라도 대충 스케치해 보겠습니다.&lt;/p&gt;

&lt;p&gt;밑이 2인 로그를 쓰고 있으므로, 위 식은 이렇게 정리가 됩니다. 
\(\frac{1}{\log n - 1/2)} - \frac{1}{4(\log n - 1/2)}\)&lt;/p&gt;

&lt;p&gt;이제, 이 식을 꾸역꾸역 통분해서 
\(\frac{4 \log n - 3}{4\log^2 n - 4\log n + 1} = \frac{1}{\log n} + \frac{1 - 1 / \log{n}}{4\log^2 n - 4\log n + 1} \geq \frac{1}{\log n}\)&lt;/p&gt;

&lt;p&gt;이렇게 얻습니다. 부등식을 더 이쁘게 패면 $2 / \log n$ 인가? 하는 바운드도 잡을 수 있을텐데, 별로 중요한 논의는 아닙니다.&lt;/p&gt;

&lt;p&gt;어쨌든, 우리는 한번 성공확률이 $1 / \log n$ 수준임을 알았습니다.&lt;/p&gt;

&lt;h3 id=&quot;total-time-complexity&quot;&gt;Total time complexity&lt;/h3&gt;
&lt;p&gt;몇번 수행할 것인지만 정하면 끝입니다. 앞서 Karger 알고리즘의 시간 복잡도 증명에서 했던 것과 똑같은 연산을 해 보면, 성공확률이 $p(n)$ 인 베르누이 시행을 반복해서 $1/n$ 이하의 실패확률을 갖게 하려면, $q(n)$ 번 실행한다고 할 때
\(\left(1 - p(n)\right)^{q(n)} \leq 1 / n\)
이 식을 목표로 하는 것인데, $(1 - x)^{1/x}$ 의 값이 $1/e$ 이하임을 다시 이용 ($p(n) \leq 1$이므로!), $q(n)$ 을 $\frac{\log n}{p(n)}$ 번으로 잡아주면 된다는 것을 알 수 있습니다. 따라서, $q(n) = \log^2 n$ 으로 잡아주면 됩니다.&lt;/p&gt;

&lt;p&gt;우리는 개별 시간이 $O(n^2 \log n)$ 인 수행을 $\log^2 n$번 수행하기로 결정했으므로, 전체 시간복잡도는 $O(n^2 \log^3 n)$입니다. 간단한 아이디어로 충격적인 향상을 이루었음을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;특히 $n^2$ 비슷한 시간이 나왔다는게 중요한데, 간선이 $n^2$ 개일 때 적어도 이 간선들을 검토는 해봐야 하므로 이 문제는 이론상 $O(n^2)$ 보다 빠를 방법이 아예 없습니다. 어렵지 않은 아이디어를 잘 이용해서 이정도까지 복잡도를 내렸다는 점에서, Randomized algorithm의 힘을 잘 보여주는 예시가 아닌가 싶습니다.&lt;/p&gt;

&lt;h2 id=&quot;extension&quot;&gt;Extension&lt;/h2&gt;
&lt;p&gt;이 알고리즘의 재밌는 extension은 $k$-cut입니다. $k$-cut이란, 노드를 $k$개의 connected component로 쪼개기 위한 min cut을 구하는 문제입니다. 우리가 지금까지 공부한 문제는 $k = 2$ 인 경우라고 생각하면 되겠습니다.&lt;/p&gt;

&lt;p&gt;이 문제가 재미있는 이유는, 조금만 extension했을 뿐인데 미친듯이 어렵기 때문입니다. 이 문제는 $k$도 입력으로 주어지는 경우, NP-complete함이 잘 알려져 있습니다. 간단히 생각해보면, 2-cut은 적어도 s-t min cut 문제로 환원한다음 그걸 디닉으로 푸는 방법이 있었는데, 이 문제는 플로우 모델링이 아예 안 됩니다.&lt;/p&gt;

&lt;p&gt;다양한 상황에서 approximation을 한다던가 하는 아이디어들이 연구되고 있지만, 쉽지 않습니다. Gomory-Hu tree를 쓴다던가 등등…&lt;/p&gt;

&lt;p&gt;Karger-Stein algorithm은 $k$-cut에 대해 굉장히 잘 대응합니다. 단순히, 최종적으로 남기는 vertex를 2개가 아닌 $k$개로 남기면 됩니다. 이 방법이 성공할 확률이 그래서 얼마인지, 복잡도가 얼마인지 등은 굉장히 어려운 문제입니다.&lt;/p&gt;

&lt;p&gt;Interestingly, Karger-Stein 알고리즘을 정말 잘 분석하면 $k$-cut에 대해 이 알고리즘이 optimal하다는 것을 보일 수 있다고 합니다. 이 글을 제가 쓰게 된 이유도 엊그제 이 주제 (Karger-Stein is optimal on $k$-cut) 를 다루는 세미나가 있었기 때문에 공부했던 내용을 리뷰할 겸 해서 쓰게 된 것인데요. 언젠가 저 논문을 전부 읽을 수 있을지는 사실 자신이 없습니다. 굉장히 재밌어 보이지만 증명이 Martingale을 쓰는 등 상당한 배경 지식을 요구하는 것 같아 보였습니다. 관심이 있으신 분들은 &lt;a href=&quot;https://arxiv.org/pdf/2005.08301.pdf&quot;&gt;2019년 논문 링크&lt;/a&gt; 가 있습니다.&lt;/p&gt;

&lt;p&gt;별론으로, 세미나에서는 Karger 알고리즘을 랜덤하게 edge들을 순서대로 고르는 대신, 각 edge들에 exponential clock이라고 해서, essentially 각 edge에게 특정 시간에 이벤트가 일어날 확률을 부여하고 그 이벤트가 터지면 contraction해 버리는 식으로 알고리즘을 살짝 다르게 분석했습니다. 이 method가 있다는 것을 다른 곳에서 들었었는데, 처음 들었을 때는 아 그렇구나 라고만 생각했는데 이런식으로 그래프 알고리즘에 적용하면 문제를 연속적인 공간으로 끌고와서 해석적인 기법들을 이용한 분석이 가능하다는 것을 새로 배웠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Stephen Boyd, Lieven Vandenberghe, &lt;em&gt;Convex Optimization&lt;/em&gt;, Chapter 4 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Sparse graph에 대해서는 Orlin 등 더 빠른 알고리즘들이 있지만, 우선은… &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Edge contraction을 정의할때 edge가 겹치면 하나만 남기는 저자들이 있는데, 저희는 그러지 않겠습니다. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;$\left( 1 - \frac{1}{x}\right)^x \leq e^{-x}$ 가 $1/e$ 보다 작음을 이용합니다. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;위 Karger 알고리즘의 시간 복잡도 분석에서 말한 바와 같이 Kruskal처럼 구현하면 여기에 로그가 하나 더 붙습니다만, 우리는 일단 구현을 잘해서 $O(n)$ 에 한 contraction을 처리할 수 있다고 하겠습니다! &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="advanced_algorithms" /><category term="algorithms" /><category term="graph_theory" /><summary type="html">Contents</summary></entry><entry><title type="html">UCPC 팀 해체</title><link href="http://localhost:4000/ucpc_team_broken/" rel="alternate" type="text/html" title="UCPC 팀 해체" /><published>2021-07-22T00:00:00+09:00</published><updated>2021-07-22T00:00:00+09:00</updated><id>http://localhost:4000/ucpc_team_broken</id><content type="html" xml:base="http://localhost:4000/ucpc_team_broken/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;이번 UCPC는 개인 신청 후 팀 신청을 따로 해야 하는데, 이 과정을 3명 모두가 동시에 잊고 있었던 어처구니없는 이유로 UCPC에 참여하지 못하게 되었습니다.&lt;/p&gt;

&lt;p&gt;주최측에 메일을 보내 보기도 했고, 여러가지 방법으로 contact를 시도해 보았으나 원칙적으로 불가하다는 답변을 받았습니다.&lt;/p&gt;

&lt;p&gt;처음에는 솔직히 조금 받아들이지 못하기도 했습니다. 개인신청을 진행하기도 했으니 어떻게든 추가로 등록이 되지 않을까 하는 생각도 했었던 것 같습니다. 
그래서인지, 전대프연측에 보낸 메일을 쓰면서 솔직히 깊게 생각하지 못하고, 감정적으로 대처한 부분도 있지 않나 싶습니다. 여기를 보실 확률은 매우 낮지만 진심으로 죄송하게 생각하고, 언젠가 이부분은 정리가 되고나면 개인적으로라도 꼭 연락을 드리려 합니다.&lt;/p&gt;

&lt;p&gt;저희가 잊고 있었던 탓이니 누구를 탓할수 있는것도 아니고… 그냥 좀 허탈하네요. 원래는 PS에 대한 동력도 확 잃었었는데, SCPC도 있고, 올해 ICPC도 있으니 나름대로 동력을 잃지 않고 해보려고 합니다.&lt;/p&gt;

&lt;p&gt;여튼 굉장히 기대했던 UCPC 팀은 여기까지로 마무리하게 되었습니다. 올해가 마지막 UCPC 참가가 되었던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님께 특히 죄송한 마음입니다. 팀연습하고 디스커션하고 정말 재밌게 했는데 이렇게되어 너무 아쉽네요.&lt;/p&gt;

&lt;p&gt;멘탈이 돌아온다면 이 멤버로 Open contest라도 돌 수 있을지도 모르겠습니다. 지금은 UCPC는 약간 의도적으로라도 어떻게 더 생각하지 않아 보려고 합니다.&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><summary type="html">Contents</summary></entry><entry><title type="html">7월 3주차 Weekly PS</title><link href="http://localhost:4000/ps_weekly/ps-weekly-21Jul3/" rel="alternate" type="text/html" title="7월 3주차 Weekly PS" /><published>2021-07-18T00:00:00+09:00</published><updated>2021-07-18T00:00:00+09:00</updated><id>http://localhost:4000/ps_weekly/ps-weekly-21Jul3</id><content type="html" xml:base="http://localhost:4000/ps_weekly/ps-weekly-21Jul3/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#recent-updates&quot; id=&quot;markdown-toc-recent-updates&quot;&gt;Recent Updates&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rounds&quot; id=&quot;markdown-toc-rounds&quot;&gt;Rounds&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#팀연습-서강대학교-2020-spc-div1-champion&quot; id=&quot;markdown-toc-팀연습-서강대학교-2020-spc-div1-champion&quot;&gt;(팀연습) 서강대학교 2020 SPC Div.1 (Champion)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#대회-scpc-2021-round-1&quot; id=&quot;markdown-toc-대회-scpc-2021-round-1&quot;&gt;(대회) SCPC 2021 Round 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#atcoder-atcoder-beginner-round-210&quot; id=&quot;markdown-toc-atcoder-atcoder-beginner-round-210&quot;&gt;(Atcoder) Atcoder Beginner Round 210&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#problems&quot; id=&quot;markdown-toc-problems&quot;&gt;Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ioi-2009-4-raisins-boj-5463-건포도&quot; id=&quot;markdown-toc-ioi-2009-4-raisins-boj-5463-건포도&quot;&gt;IOI 2009-4, Raisins (BOJ 5463 건포도)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#서강대학교-spc-2015-1f-몬스터-boj-11573&quot; id=&quot;markdown-toc-서강대학교-spc-2015-1f-몬스터-boj-11573&quot;&gt;서강대학교 SPC 2015-1F, 몬스터 (BOJ 11573)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#연세대학교-2018-c-나무-위의-입자-boj-15669&quot; id=&quot;markdown-toc-연세대학교-2018-c-나무-위의-입자-boj-15669&quot;&gt;연세대학교 2018-C 나무 위의 입자 (BOJ 15669)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#연세대학교-2018-l-연세워터파크-boj-15678&quot; id=&quot;markdown-toc-연세대학교-2018-l-연세워터파크-boj-15678&quot;&gt;연세대학교 2018-L 연세워터파크 (BOJ 15678)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ioi-2002-4-batch-scheduling-boj-5498&quot; id=&quot;markdown-toc-ioi-2002-4-batch-scheduling-boj-5498&quot;&gt;IOI 2002-4, Batch Scheduling (BOJ 5498)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#joi-2009-4-散歩-boj-5573-산책&quot; id=&quot;markdown-toc-joi-2009-4-散歩-boj-5573-산책&quot;&gt;JOI 2009-4 散歩 (BOJ 5573 산책)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;July 11 - July 18, 2021&lt;/p&gt;

&lt;p&gt;이 글에 구현코드 링크가 없더라도 &lt;a href=&quot;https://github.com/gratus907/Gratus_PS&quot;&gt;PS 레포 링크&lt;/a&gt; 에 가서 대회 단위로 들어가면 보통 올려놓은 코드를 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;recent-updates&quot;&gt;Recent Updates&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2021 SCPC 라운드 1은 뭐 무난히 통과했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rounds&quot;&gt;Rounds&lt;/h2&gt;
&lt;h3 id=&quot;팀연습-서강대학교-2020-spc-div1-champion&quot;&gt;(팀연습) 서강대학교 2020 SPC Div.1 (Champion)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/cp_practice/team_practice_1/&quot;&gt;포스팅 링크&lt;/a&gt; 에 포스팅했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대회-scpc-2021-round-1&quot;&gt;(대회) SCPC 2021 Round 1&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/cp_rounds/SCPC-2021-Round1/&quot;&gt;포스팅 링크&lt;/a&gt; 에 포스팅했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;atcoder-atcoder-beginner-round-210&quot;&gt;(Atcoder) Atcoder Beginner Round 210&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc210/tasks&quot;&gt;라운드 링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;582등, -9 (1844 -&amp;gt; 1835).&lt;/li&gt;
  &lt;li&gt;D번 DP문제를 못 풀어서 레이팅을 좀 깎아먹었습니다. 대신 E번 (수학..이라긴 좀 애매하고 잘 모르겠습니다) 을 풀어서 본전은 친듯 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;
&lt;p&gt;이번에는 DP 연습을 하기로 했습니다. 백준 번호를 적어놨으므로 문제설명은 가급적 생략합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ioi-2009-4-raisins-boj-5463-건포도&quot;&gt;IOI 2009-4, Raisins (BOJ 5463 건포도)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Gold 1&lt;/li&gt;
  &lt;li&gt;IOI에 이런 문제가 나온적 있는지는 몰랐습니다. 무슨 20세기 대회도 아니고 2009년에..?&lt;/li&gt;
  &lt;li&gt;거의 straightforward한 DP로 해결이 가능합니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dp[r1][c1][r2][c2]&lt;/code&gt; 를 직접 $[r1, c1] \times [r2, c2]$ 사각형의 DP값이라고 정의하면,&lt;/li&gt;
      &lt;li&gt;이제 이 값은 모든 가로/세로 컷을 직접 확인하면 됩니다.&lt;/li&gt;
      &lt;li&gt;구현 코드 가 상당히 간단하므로 확인하면 도움이 될것 같습니다. 레포에서 IOI를 찾아가면 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시간 복잡도는 $O(n^4)$ 칸 DP를 칸당 $O(n)$ 시간에 채우는 것이므로 $O(n^5)$ 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;서강대학교-spc-2015-1f-몬스터-boj-11573&quot;&gt;서강대학교 SPC 2015-1F, 몬스터 (BOJ 11573)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Gold 1&lt;/li&gt;
  &lt;li&gt;마찬가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dp[i][j][k]&lt;/code&gt; 를 빨간색 노란색 파란색이 $i, j, k$ 마리 남은 상황이라고 생각하면 됩니다.&lt;/li&gt;
  &lt;li&gt;이때, Random choice에 의해 빨간색과 노란색이 만날 확률은 $\frac{ij}{ij + jk + ki}$ 입니다.&lt;/li&gt;
  &lt;li&gt;이렇게 각 state transition의 확률을 구해서, 확률을 탑다운 DP로 찾아주면 됩니다.&lt;/li&gt;
  &lt;li&gt;어떤 특정 종의 몬스터가 아예 없어지면 두 종류 중에는 항상 이기는 쪽이 정해져 있으므로 확률이 (1, 0, 0) 형태로 나옵니다. 이를 베이스 케이스로 쓰면 됩니다.&lt;/li&gt;
  &lt;li&gt;대칭성을 잘 이용하면 $n^3$ 개의 실수값만으로 계산할수 있는것 같은데, 저는 $p_1, p_2, p_3$ 을 struct로 묶어서 돌렸습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;연세대학교-2018-c-나무-위의-입자-boj-15669&quot;&gt;연세대학교 2018-C 나무 위의 입자 (BOJ 15669)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 5&lt;/li&gt;
  &lt;li&gt;정점 U, V에 대해, 편의상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;depth(u) &amp;lt; depth(v)&lt;/code&gt; 라고 합시다.&lt;/li&gt;
  &lt;li&gt;이때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;의 ‘위에서’ 하나, ‘아래서’ 하나를 골라서 그 거리가 홀수/짝수가 되는 정점쌍 개수를 세는 문제입니다.
    &lt;ul&gt;
      &lt;li&gt;가장 쉬운 방법은, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dp[i]&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;를 루트로 하는 서브트리에서 깊이가 홀수/짝수인 점의 개수를 미리 세 놓고&lt;/li&gt;
      &lt;li&gt;거리가 짝수이려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; 아래 서브트리에서 짝수 깊이, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; 아래가 아닌 곳에서 짝수 깊이&lt;/li&gt;
      &lt;li&gt;또는 둘다 홀수 깊이인 노드들의 개수의 곱입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;역시 코드가 조금더 보기 쉬운 문제입니다. 모든 정보는 DFS를 돌리면서 Tree DP 할 수 있어서 $O(n)$ 에 해결 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;연세대학교-2018-l-연세워터파크-boj-15678&quot;&gt;연세대학교 2018-L 연세워터파크 (BOJ 15678)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 5&lt;/li&gt;
  &lt;li&gt;핵심은 $D_i = \max_{i - d \leq j &amp;lt; i} (D_j + A_i)$ 라는 DP식이고,&lt;/li&gt;
  &lt;li&gt;이 식에서 $A_i$는 이미 정해져 있으므로 $[i - d, i)$ 구간의 최댓값을 빨리 구할수 있으면 됩니다.&lt;/li&gt;
  &lt;li&gt;Deque DP Optimization이라는 방법을 적용하는 기본 연습문제입니다. 이 방법은 언젠가 따로 소개하겠습니다.&lt;/li&gt;
  &lt;li&gt;$n$ 이 작아서 세그먼트 트리로 $O(n \log n)$ 에도 풀 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ioi-2002-4-batch-scheduling-boj-5498&quot;&gt;IOI 2002-4, Batch Scheduling (BOJ 5498)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 3&lt;/li&gt;
  &lt;li&gt;지문이 굉장히 이해하기 어렵습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 의 부분합을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TS&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt;의 부분합을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FS&lt;/code&gt; 라고 생각하겠습니다.&lt;/li&gt;
  &lt;li&gt;뒤에서부터 역순으로 Batch를 만들면서 오는 식으로 생각합니다.
    &lt;ul&gt;
      &lt;li&gt;Batch 블록 하나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i, i+1, ... j&lt;/code&gt; 구간을 커버한다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t + s + (TS[j] - TS[i-1])&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(FS[j] - FS[i-1])&lt;/code&gt; 에 곱해야 하는데, 각 블록의 시작점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;를 도저히 계산할 방법이 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 문제를 해결하기 위해, 앞 블록에서의 소모 시간을 뒷 블록에 계속 더해 주는 식으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(s + (TS[j] - TS[i-1])) * (FS[n] - FS[i-1])&lt;/code&gt; 로 계산해서 더해주면 모든 블록을 더했을때 결과가 같습니다.&lt;/li&gt;
  &lt;li&gt;따라서 다음 DP식을 생각합니다. 
\(D_i = \min_{i \leq j} (D_j + (s + TS_{j} - TS_{i-1}) (FS_{n} - FS_{i-1}))\)
이 식은 그냥 계산하면 $O(n^2)$ 라서, 더 줄이고 싶습니다.&lt;/li&gt;
  &lt;li&gt;여기서, $j$와 무관한 항을 다 min 밖으로 빼서 정리하면, $D_j + TS_{j} \times u_i$ 들의 minimum을 빠르게 계산하는 문제가 됩니다 ($u_i$는 $i$에 의해 결정되는 상수값)
    &lt;ul&gt;
      &lt;li&gt;이러한 DP를 Convex Hull Trick으로 빠르게 처리할 수 있음이 알려져 있습니다. $TS_{j}$의 성질을 매우 잘 이용해서 스택에 잘 왔다갔다하는 $O(n)$ 풀이도 가능하고…&lt;/li&gt;
      &lt;li&gt;Li-Chao Tree같은 놀라운 (이제 리차오는 별로 놀라운까지는 아닙니다) 자료구조를 박으면 $O(n \log n)$ 에 풀 수 있습니다.&lt;/li&gt;
      &lt;li&gt;Li-Chao Tree에 대해서는 &lt;a href=&quot;http://www.secmem.org/blog/2019/01/03/lichao-tree/&quot;&gt;kjp4155님의 소멤 글&lt;/a&gt; 이 잘 알려져 있고, 무지성 복붙 가능한 최고의 코드입니다.&lt;/li&gt;
      &lt;li&gt;ICPC에도 몇번 나온 자료구조인만큼 하나 가지고 있으면 좋을듯 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이와는 별론으로, 이 문제는 무려 20년 전의 문제라서 $O(n)$ 이 정해이면서 ($n \log n$ 까지는 허용했고) $n$이 1만밖에 안 됩니다. 요즘에 나온다면 500만이나 최소 100만으로 내지 않았을까요? 500만 리차오는 불가능할거고, 100만 리차오는 잘 모르겠습니다.&lt;/li&gt;
  &lt;li&gt;슬프게도, 이것 때문에 $O(n^2)$의 나이브한 DP가 100ms대로 통과합니다. 세월의 흐름이 느껴지기도 하면서, 동시에 만약 지금보다 컴퓨터가 다시 10배 빨라져서 지금 $O(n^2)$ 가 안 뚫리는 문제들이 다 뚫리게 되면 기존 문제들을 온라인저지 상에서 리마스터할 필요가 있을수도 있겠다, 하는 (저와는 별로 상관없는 일이지만) 생각도 들게 하네요.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;joi-2009-4-散歩-boj-5573-산책&quot;&gt;JOI 2009-4 散歩 (BOJ 5573 산책)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;난이도 Platinum 4&lt;/li&gt;
  &lt;li&gt;이번주에 제가 포스팅하는 문제중 가장 어려웠습니다.&lt;/li&gt;
  &lt;li&gt;$N-1$ 번째의 보드 상태를 알고 있다면, $N$번째는 직접 시뮬레이션해서 도착할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;특정 칸에 지금까지 도달한 횟수를 안다면, 그 칸의 상태를 알 수 있습니다.&lt;/li&gt;
  &lt;li&gt;$(1, 1)$ 을 밟는 횟수는 $N-1$번입니다.&lt;/li&gt;
  &lt;li&gt;어떤 칸을 밟는 횟수가 $K$번이면, 계속 오른쪽과 아래가 왔다갔다하므로 그중 절반은 오른쪽으로, 절반은 아래로 내려가게 됩니다.
    &lt;ul&gt;
      &lt;li&gt;단, $K$가 홀수이면 0번째에 어느 방향이었는지를 보고 한번 더가면 됩니다.&lt;/li&gt;
      &lt;li&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dp[i][j+1], dp[i+1][j]&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dp[i][j]/2&lt;/code&gt; 를 (필요하다면 1만큼 더) 더해주면 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 아이디어가 굉장히 떠올리기 힘들었습니다. 역시 DP는 어렵네요.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="ps_weekly" /><category term="weekly-ps" /><summary type="html">Contents</summary></entry><entry><title type="html">삼성 SCPC 예선 1라운드 풀이 / 후기</title><link href="http://localhost:4000/cp_rounds/SCPC-2021-Round1/" rel="alternate" type="text/html" title="삼성 SCPC 예선 1라운드 풀이 / 후기" /><published>2021-07-16T00:00:00+09:00</published><updated>2021-07-16T00:00:00+09:00</updated><id>http://localhost:4000/cp_rounds/SCPC-2021-Round1</id><content type="html" xml:base="http://localhost:4000/cp_rounds/SCPC-2021-Round1/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#scpc&quot; id=&quot;markdown-toc-scpc&quot;&gt;SCPC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#문제-풀이--후기&quot; id=&quot;markdown-toc-문제-풀이--후기&quot;&gt;문제 풀이 / 후기&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-1-친구들&quot; id=&quot;markdown-toc-problem-1-친구들&quot;&gt;Problem 1. 친구들&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명&quot; id=&quot;markdown-toc-문제설명&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-disjoint-set&quot; id=&quot;markdown-toc-풀이-disjoint-set&quot;&gt;풀이 (Disjoint Set)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-2-이진수&quot; id=&quot;markdown-toc-problem-2-이진수&quot;&gt;Problem 2. 이진수&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명-1&quot; id=&quot;markdown-toc-문제설명-1&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-greedy&quot; id=&quot;markdown-toc-풀이-greedy&quot;&gt;풀이 (Greedy)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-3-no-cycle&quot; id=&quot;markdown-toc-problem-3-no-cycle&quot;&gt;Problem 3. No Cycle&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명-2&quot; id=&quot;markdown-toc-문제설명-2&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-greedy--graph&quot; id=&quot;markdown-toc-풀이-greedy--graph&quot;&gt;풀이 (Greedy + Graph)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-4-예약-시스템&quot; id=&quot;markdown-toc-problem-4-예약-시스템&quot;&gt;Problem 4. 예약 시스템&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제설명-3&quot; id=&quot;markdown-toc-문제설명-3&quot;&gt;문제설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-greedy--casework&quot; id=&quot;markdown-toc-풀이-greedy--casework&quot;&gt;풀이 (Greedy + Casework)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#problem-5&quot; id=&quot;markdown-toc-problem-5&quot;&gt;Problem 5&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#문제-설명&quot; id=&quot;markdown-toc-문제-설명&quot;&gt;문제 설명&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#풀이-dsu-based&quot; id=&quot;markdown-toc-풀이-dsu-based&quot;&gt;풀이 (DSU-based)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#후기&quot; id=&quot;markdown-toc-후기&quot;&gt;후기&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#부록--버퍼-이야기-scpc-주의사항&quot; id=&quot;markdown-toc-부록--버퍼-이야기-scpc-주의사항&quot;&gt;부록 : 버퍼 이야기 (SCPC 주의사항)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;scpc&quot;&gt;SCPC&lt;/h1&gt;
&lt;p&gt;SCPC는 삼성전자 (정확히는 Samsung Research) 가 주관하는 알고리즘 문제풀이 대회로, 한국에서 열리는 기업 대회중 가장 큰 규모를 자랑하는 대회입니다. 한국의 코드잼이라고나 할까요.&lt;/p&gt;

&lt;p&gt;ICPC, UCPC 등 팀대회와는 달리 개인전이고, 예선 1라운드 - 예선 2라운드 - 본선으로 구성됩니다.&lt;/p&gt;

&lt;p&gt;예선 1라운드는 24시간, 예선 2라운드는 12시간이라는 엄청난 시간이 주어지고 지구력을 강하게 요구합니다. 또한 제출 기회가 10번(문제에 따라 20번)으로 제한되어 있다는 점도 특징입니다.&lt;/p&gt;

&lt;p&gt;참고로, 2020년 대회는 예선 1라운드를 통과하고 2라운드를 멋지게 말아먹었습니다. 저는 부분점수 시스템을 탓하기로 했습니다만 작년 대회 문제를 다시 stress-test 해보니 꼭 그렇지는 않은 모양입니다. 작년 대회에 대한 (감정이 많이 실린) 후기는 &lt;a href=&quot;https://gratus-blog.tistory.com/121&quot;&gt;여기&lt;/a&gt; 에 적혀 있습니다.&lt;/p&gt;

&lt;p&gt;작년에는 1차 예선 5번을 해결하지 못했지만, 올해는 시작 약 4시간 만에 모든 문제에서 만점을 받을 수 있었습니다. 올해의 구현 코드 링크는 &lt;a href=&quot;https://github.com/gratus907/Gratus_PS/tree/master/Contests/Others/%5BSamsung%5D%20SCPC/2021/Round%201&quot;&gt;여기&lt;/a&gt; 에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/1884fd79ae1d82e347df360ba2645a98a53fe3170016d0cd18a3e88a4a4dfdd5.png&quot; alt=&quot;picture 1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;문제-풀이--후기&quot;&gt;문제 풀이 / 후기&lt;/h1&gt;
&lt;p&gt;시간복잡도에 대한 모든 언급은 테스트케이스 한개당 복잡도입니다.&lt;/p&gt;

&lt;p&gt;구현체를 업로드하긴 하곘지만, 대회중 구현한 코드라서 굉장히 바보같은 실수와 redundant한 구현이 있습니다.&lt;br /&gt;
코드를 정리해서 쓰지 않고 incremental하게 생각해서 그런데, codeground에 연습이 올라오면 정리를 해볼지도 모르겠습니다. 현재 코드가 라운드 중 제 생각의 과정을 그대로 반영해서 오히려 이런 글에 더 적절하다는 생각도 듭니다.&lt;/p&gt;
&lt;h2 id=&quot;problem-1-친구들&quot;&gt;Problem 1. 친구들&lt;/h2&gt;
&lt;h3 id=&quot;문제설명&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;$i$ 번 사람이 $i + D_i$ 번과 친구이고, 친구관계가 equivalence relation을 이룰 때, 친구 관계인 극대 그룹의 개수를 출력하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;극대 그룹이란 “현재 이 그룹 안에서 뽑은 임의의 2명이 서로 친구이면서”, “이 성질을 깨지 않고 이 그룹에 누군가를 추가할 수 없음” 을 말합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-disjoint-set&quot;&gt;풀이 (Disjoint Set)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;즉, equivalence class의 개수를 세는 문제입니다.&lt;/li&gt;
  &lt;li&gt;Disjoint Set Union (DSU) 또는 Union Find (UF) 라고 알려진 자료구조를 써서 쉽게 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;DSU의 구현체와 마지막에 개수를 어떻게 세느냐에 따라 $O(n \log^* n)$ 에도 풀 수 있지만, 저는 그냥 평범하게 merge by size &amp;amp; path compression을 쓰고 set을 써서 $O(n \log n)$ 으로 구현했습니다. 단 한번도 UF가 느려서 문제가 생기는걸 본적이 없습니다.&lt;/li&gt;
  &lt;li&gt;대략 8분 정도 만에 AC를 받았던것 같습니다. 어떤 대회든 시작하면 순간 심박수가 확 높아지는 제 심각한 단점에 의해 필요 이상으로 힘들었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-2-이진수&quot;&gt;Problem 2. 이진수&lt;/h2&gt;
&lt;h3 id=&quot;문제설명-1&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;N비트 비트열 $A$로부터 $B$를 다음과 같이 만듭니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B[i] = A[i - t] || A[i + t]&lt;/code&gt; (단, 인덱스가 1 - N 범위를 벗어나면 무시)&lt;/li&gt;
  &lt;li&gt;B가 주어질 때, A를 복원하는 문제입니다. 가능한 A가 여러가지이므로 이진수로 볼 때 가장 작은 - 즉, 사전순으로 가장 앞서는 답을 출력해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-greedy&quot;&gt;풀이 (Greedy)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사전순이라는 조건 때문에, 앞비트를 0으로 만들 수 있다면 무조건 0으로 만들어야 합니다. 따라서, 최대한 앞비트에 0이 많이 오게 Greedy하게 풀면 됩니다.&lt;/li&gt;
  &lt;li&gt;주의할 점은, $B_i$가 0이면 $A_{i - t}$ 와 $A_{i + t}$ 가 무조건 0이어야 하므로, 어떤 $A_j$ 들은 0으로 고정당합니다. 이것 때문에 앞과 뒤 중 앞을 1로 만들어야만 하는 (사전순으로는 뒤를 1로 만들고 싶겠지만) 상황들이 발생합니다.&lt;/li&gt;
  &lt;li&gt;저는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fix&lt;/code&gt; 라는 배열을 관리하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fix&lt;/code&gt; 배열에 True가 켜져 있으면 손을 못댄다고 생각하는 방식으로 구현했습니다.&lt;/li&gt;
  &lt;li&gt;대략 30분 정도 만에 AC를 받았습니다. fix를 생각하지 않고 그리디하게 했다가 뭔가 답이 안나와서 잠깐 고민했고, 버퍼 이슈 때문에 한번 TLE를 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-3-no-cycle&quot;&gt;Problem 3. No Cycle&lt;/h2&gt;
&lt;h3 id=&quot;문제설명-2&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Directed Acyclic Graph $G$와, 방향이 정해지지 않은 간선들이 주어집니다.&lt;/li&gt;
  &lt;li&gt;간선들에 정방향 (입력방향) 또는 역방향 (입력 반대방향) 을 줍니다. (각각을 0과 1로 표시)&lt;/li&gt;
  &lt;li&gt;목표는 방향을 다 정해서, 결과 그래프가 여전히 Acyclic하게 만드는 것입니다. 당연히 여러 개의 답이 있는 경우들이 있으며, 이런 경우에는 간선들을 0 1 로 표시했을 때 사전순으로 가장 앞서는 답을 출력합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-greedy--graph&quot;&gt;풀이 (Greedy + Graph)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Subtask 1은 간선개수 10개, 정점개수 10개이므로 $2^{10}$가지 경우의 수를 확인하는 풀이가 가능합니다. 이걸로 41 / 180점을 받습니다.&lt;/li&gt;
  &lt;li&gt;사전순을 일단 생각하지 말고, 사이클 없는 간선 방향 정하기만 생각해 봅시다. 여기까지는 굉장히 많이 알려진 문제이며, 주어진 DAG를 Topological sorting한 다음 Topological order를 기준으로 간선을 앞 -&amp;gt; 뒤로 모두 정해버리면 사이클이 발생하지 않습니다. 임의의 Directed Graph가 주어졌을때 사이클이 있는지 확인하는 방법 중, 위상정렬하고 back edge가 있는지 보는 방법이 있음을 알고 있다면 이 방법은 쉽게 떠올릴 수 있습니다. 제가 PS를 처음 시작하고 얼마 안되어 codeforces에 이 문제가 한번 나왔는데 한참 생각해서 풀고 기분이 꽤 좋았던 기억이 있습니다.&lt;/li&gt;
  &lt;li&gt;여기까지, Subtask 2를 해결할 수 있으며, 52 / 180점을 받습니다. 서브태스크 1과 함께하면 93 / 180점입니다.&lt;/li&gt;
  &lt;li&gt;문제 전체를 해결하기 위해서는 조금더 잘 생각해볼 필요가 있습니다. 먼저, 사전순 조건 때문에 만약 가능하다면 항상 앞간선에 0번방향을 부여하고 싶다는 사실을 기억합시다.&lt;/li&gt;
  &lt;li&gt;$n \times n$ 의 비트 행렬 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 이라는걸 생각하겠습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][j]&lt;/code&gt; 는, $i$ 에서 $j$로 가는 경로가 있음을 의미합니다.&lt;/li&gt;
  &lt;li&gt;$(u, v)$ 간선의 방향을 정하는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[v][u]&lt;/code&gt; 가 True이면 $u \to v$ 방향으로 간선을 줄 수 없습니다.&lt;/li&gt;
  &lt;li&gt;그렇지 않다면, $u \to v$ 방향으로 간선을 줄 수 있으므로 주어야 합니다.&lt;/li&gt;
  &lt;li&gt;이제, 간선을 추가했다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 업데이트해야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 업데이트하는 것은
    &lt;ul&gt;
      &lt;li&gt;$u$ 에 도달 가능한 모든 정점 $i$에 대해, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][u]&lt;/code&gt; 가 참인 모든 $i$에 대해&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][j]&lt;/code&gt; 에 $i \to u \to v \to j$ 경로의 존재성을 반영합니다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R[i][j] |= R[v][j]&lt;/code&gt; 를 해줘야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서, 각 간선을 볼때마다 최대 $O(n^2)$ 칸의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 업데이트해야 하기 때문에, $O(n^2 k)$ 알고리즘이 됩니다.&lt;/li&gt;
  &lt;li&gt;$n = 500, k = 2000$ 이므로, 이 시간은 기분이 몹시 나쁩니다. $500 \times 500 \times 2000$ 짜리 테스트케이스 한개면 모를까, 그걸 70개 해결할 수는 없어 보입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::bitset&lt;/code&gt; 으로 관리하면, 시간복잡도는 줄어들지 않지만 비트연산을 묶어서 처리함으로써 64배 빨라집니다. 이를 이용하여, $O(n^2 k)$ 알고리즘을 시간내에 구겨넣을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;bitset을 쓰는 추한 풀이가 싫다면, 매번 간선을 추가할때마다 간선을 0-방향으로 추가해보고 사이클이 있는지 검증하고, 1-방향으로 추가해보는 식으로 $O(nk)$ 에도 풀 수 있다고 합니다. 어떻게 이걸 생각을 못했지????? 이건 라운드가 끝나고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhdroid&lt;/code&gt;랑 디스커션하다가 알았고, bitset을 쓰는 추한 풀이로 욕을 먹었습니다. ㅎㅎ;;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 행렬을 처음에 바보같이 DFS로 계산하는 과정에서 실수를 해서, 이문제 AC를 받는데 무려 1시간 30분 정도가 걸렸습니다. (1시간 58분 AC) 중간에 혹시 못풀수도 있겠다는 공포에 52점을 먹는 등 (22.5시간이 남았음에도…) 24시간 대회는 대회 전략을 고려하지 않고 편한 마음으로 PS를 해야하는데 제가 그게 좀 안 됩니다. 작년 2차 3번의 악몽때문에 제출 기회 제한을 두려워하는 것도 좀 있습니다. 중간에 4번을 좀 생각하다가 돌아와서, 4번은 좀 빨리 풀었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-4-예약-시스템&quot;&gt;Problem 4. 예약 시스템&lt;/h2&gt;
&lt;h3 id=&quot;문제설명-3&quot;&gt;문제설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;$2$행 $m$열로 방들이 있고, 같은 열의 위아래 행들과 같은 행의 양 옆 열들을 ‘인접’ 하다고 정의합니다.&lt;/li&gt;
  &lt;li&gt;사람 $2m$ 명이 각각 스트레스 지수를 가지고 있고, $n$개 그룹으로 나뉘어 있습니다.&lt;/li&gt;
  &lt;li&gt;인접한 방에 다른 그룹의 사람을 배치하면, 그 두 방에 들어간 사람의 스트레스 지수 합만큼 페널티가 발생합니다.&lt;/li&gt;
  &lt;li&gt;이를 최소화하는 방 배치를 찾고자 합니다.&lt;/li&gt;
  &lt;li&gt;재밌게도, 각 그룹은 5명 이상이라는 조건이 있습니다. 이 조건이 없으면 문제가 정말 끔찍할 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-greedy--casework&quot;&gt;풀이 (Greedy + Casework)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어렵지만 재밌었습니다. 먼저, 그룹 $i$의 사람 숫자가 실제로 몇명인지보다는 홀수인지 짝수인지가 중요함을 관찰합니다.&lt;/li&gt;
  &lt;li&gt;왜냐면, 어차피 같은 그룹의 사람들끼리 붙여주면 그 벽에서는 페널티가 발생하지 않고, 페널티가 발생하는 경우는 아래 케이스들밖에 없기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../images/132e43e2b169d80f9b5245bff9986d0214096cfa2e192ee741ef2c06cb2d20bd.png&quot; alt=&quot;picture 1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;잘 관찰해 보면, 홀수 블록이든 짝수 블록이든 끝 4명정도만 중요합니다. 대신 홀수블록이 포함된 연산에서는 2번 페널티를 일으키는 사람이 있게 됩니다.&lt;/li&gt;
  &lt;li&gt;또한, 가장자리 블록은 스트레스를 덜 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;홀수 블록과 짝수 블록에 대해 다음을 계산합니다. 각 블록의 스트레스 지수가 작은 사람부터 정렬했다고 합시다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;(홀수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3 = 2 * s[0] + s[1]&lt;/code&gt; 은 가장자리 홀수 블록이 다른 홀수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(홀수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5 = 2 * s[0] + s[1] + s[2] + s[3]&lt;/code&gt; 은 가장자리가 아닌 홀수 블록이 한쪽으로 다른 홀수 블록과, 다른 쪽으로 짝수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(짝수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2 = s[0] + s[1]&lt;/code&gt; 은 가장자리 짝수 블록이 다른 짝수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(짝수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4 = s[0] + s[1] + s[2] + s[3]&lt;/code&gt; 은 가장자리가 아닌 짝수 블록이 좌우로 다른 짝수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;(짝수 블록)&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6 = 2 * s[0] + 2 * s[1] + s[2] + s[3]&lt;/code&gt; 은 가장자리가 아닌 짝수 블록이 좌우로 홀수 블록과 만날때 스트레스 값입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서브태스크 1, 모든 그룹이 짝수명일 때는 가장자리 두 블록은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt;, 나머지 블록들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 만큼 스트레스를 발생시킵니다. 따라서, 모든 블록의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 를 더한 다음, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2 - l4&lt;/code&gt; 값이 가장 작은 두 블록에 대해서만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt;로 바꿔치기하면 됩니다.&lt;/li&gt;
  &lt;li&gt;서브태스크 2, 모든 그룹이 홀수명일 때도 거의 똑같습니다. 다만 이때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3&lt;/code&gt;이 됩니다.&lt;/li&gt;
  &lt;li&gt;여기까지 해서 88 / 190점을 받을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이제, 다시 경우를 나눕니다. 여기서 하나 의문을 가질만한 것은, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt; 이 어떨때 필요한지 생각하는 것입니다.
    &lt;ul&gt;
      &lt;li&gt;(홀수, 짝수 블록 여러개, 홀수) 블록이 있는데, 이 블록들이 가장자리가 아닌 곳에 배치한다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5 + l6 + l6 + l6 + ... + l5&lt;/code&gt; 가 될 것입니다. (각 블록의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5, l6&lt;/code&gt; 값을 보고 있으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6 + l6&lt;/code&gt; 이 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;이 아니라, 각 블록의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;-값을 의미합니다)&lt;/li&gt;
      &lt;li&gt;그런데, (홀수, 홀수, 짝수….) 로 배치를 바꾸면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5 + l5 + l4 + l4 + .... + l4&lt;/code&gt; 를 지불하게 됩니다. 따라서, ‘가장자리 이득’ 을 보고 싶은 상황이 아니라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;은 아예 필요가 없습니다.&lt;/li&gt;
      &lt;li&gt;같은 방법으로 (벽, 홀수, 짝수, 짝수, … 홀수) 를 분석하면, 이것도 이득이 없습니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;이 말이 되는 유일한 상황은, (벽, 홀수, 짝수, 짝수, …., 홀수, 벽) 인 상황입니다.&lt;/li&gt;
      &lt;li&gt;또한, (홀수, 짝수, 짝수, …, 홀수, 홀수, 짝수, 짝수, … 홀수) 도 잘 분석해 보면 홀수블록들끼리 묶어주는게 이득임을 알 수 있기 때문에, 경우의 수를 잘 나누면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;이 말이 되는 유일한 상황은 위 상황에 추가로 홀수가 벽에 붙은 저 두개밖에 없어야 함을 압니다.
직관적으로 홀수블록의 세번째, 네번째 사람 스트레스값이 너무 커서 이 사람들한테 벽에 붙은 방을 주는게 갈등의 절대적인 개수를 줄이는 것보다 이득이라고 생각하면 됩니다.&lt;/li&gt;
      &lt;li&gt;따라서, 이 경우는 별도로 계산합니다. 홀수 블록 두개의 l3와 나머지의 l6을 더하는 경우가 되겠습니다.&lt;/li&gt;
      &lt;li&gt;이외에는, 한쪽 벽에 (홀수, 홀수) 블록이 박히는 경우를 생각해 줘야 합니다. 이것도 l3, l5 더하고 나머지는 다 l4를 더하다가 맨 오른쪽 끝 블록에서는 l2를 더하는 것이므로, 어렵지 않게 계산 가능합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;홀수블록이 2개보다 많이 있다고 가정합시다. 이제, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;은 아예 생각할 필요가 없습니다.&lt;/li&gt;
  &lt;li&gt;홀수블록은 가장자리에 들어가면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3&lt;/code&gt;, 그외에는 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5&lt;/code&gt;의 스트레스를, 짝수블록은 각각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;따라서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l5&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l4&lt;/code&gt; 들을 모두 더해주고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l3&lt;/code&gt; 나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l2&lt;/code&gt; 로 바꿀 수 있는 기회를 두번 준다고 이해하면 됩니다. 이건 struct에 점수를 계산하는 함수를 몇개 구현하면 정말 이쁘게 구현할수 있습니다.&lt;/li&gt;
  &lt;li&gt;말하는것보다 코드를 보면 조금더 이해가 쉽습니다.&lt;/li&gt;
  &lt;li&gt;대략 1시간 정도 걸려서, 3시간 02분 시점에 AC를 받았습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l6&lt;/code&gt;을 고려하지 못해서 2번 틀렸고, 단순 코딩 실수로 1번 틀렸습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;problem-5&quot;&gt;Problem 5&lt;/h2&gt;
&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;두가지 쿼리가 주어집니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 i j k&lt;/code&gt; 쿼리는, $X_i - X_j = k$ 임을 의미합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2 i j&lt;/code&gt; 쿼리는 $X_i - X_j$ 값을 묻습니다.&lt;/li&gt;
  &lt;li&gt;1번쿼리로 주어진 상대적인 정보만을 가지고 2번쿼리의 값을 계산할 수 있다면 계산하고, 계산하지 못한다면 ‘비교 불가능’을 출력합니다.&lt;/li&gt;
  &lt;li&gt;단, 1번 쿼리가 inconsistent하게 주어질 수 있습니다. 만약 2번쿼리가 들어왔는데 $X_i - X_j$가 여러 가지가 가능해서 계산이 불가능하다면 이를 출력합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;풀이-dsu-based&quot;&gt;풀이 (DSU-based)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;의도한 것인지 알 수 없으나, 백준에 대단히 비슷한 문제가 있습니다. &lt;a href=&quot;https://www.acmicpc.net/problem/3830&quot;&gt;3830번&lt;/a&gt; 입니다.&lt;/li&gt;
  &lt;li&gt;3830번과 이 문제의 차이는 Inconsistency의 유무밖에 없습니다. 그 외에는 모든점에서 동일합니다.&lt;/li&gt;
  &lt;li&gt;3830번은 Platinum III 이긴 하지만, 비교적 많이 풀린 문제이므로 구글링해보면 솔루션은 많이 있습니다. 다시 설명하기는 너무 기니까 대충 요약하자면, DSU를 쓰되, DSU에 추가하면서 이 노드와 이 노드가 포함된 집합의 루트와의 차를 기억하면서 DSU를 쓰면 됩니다.&lt;/li&gt;
  &lt;li&gt;이 코드로 서브태스크 1, 3 (inconsistency 없음) 을 쉽게 풀 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이제, Inconsistency를 생각해 봅시다. 만약 현재 $x_1, x_2, x_3$ 에 대해 $x_1$ 을 0이라고 할 때 relatively $x_2 = 3, x_3 = 2, x_4 = 6$ 이라는 정보가 있다고 합시다.
    &lt;ul&gt;
      &lt;li&gt;$x_2 - x_3 = 1$ 이라는 정보가 주어지면 무시하면 됩니다.&lt;/li&gt;
      &lt;li&gt;만약, $x_2 - x_3 = 2$ 와 같이 틀린 정보가 주어지면, $x_2$의 relative한 값을 이제 알 수 없게 됩니다.&lt;/li&gt;
      &lt;li&gt;재밌는 사실은, 아무 상관 없어 보이는 $x_4$ 도 미지의 값이 된다는 점입니다. 그 이유는, $x_3$ 이 ?가 된 상황에서 위 정보로부터 $x_4 - x_3 = 4$ 와 같은 정보도 implicit하게 주어져 있다고 가정해야 하기 때문입니다.&lt;/li&gt;
      &lt;li&gt;따라서, ?와의 차이를 계산당하는 과정에서 $x_1$을 루트로 하는 트리 전체가 ?가 되어 버립니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그러므로 DSU를 하면서, 루트와의 차이 뿐 아니라 이 노드가 이미 망했는지 여부까지 같이 들고 다니면 됩니다. 모든 노드에 망했다는 정보를 뿌리기에는 시간이 너무 많이 들기 때문에, 루트에만 저장해 놓고 ‘이 트리가 통째로 망했다’ 라고 기억하면 됩니다. 저는 DSU에서 생각하다가 살짝 꼬여서 find하면서도 정보를 갱신하게 해놨는데 아마 필요 없는 것 같습니다.&lt;/li&gt;
  &lt;li&gt;3830을 풀어봤기때문에 1시간 정도 걸려서 4시간 쯤에 AC를 받았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;후기&quot;&gt;후기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;작년 1차보다는 문제가 많이 쉽다고 느껴졌습니다. 특히 후반 문제가 많이 쉬워졌습니다. 작년에는 1차 예선 4번에 금광세그가 출제되고, 5번문제가 충격적으로 어려워서 오전 9시에 시작한 대회가 저녁시간까지 5번 만점자가 한자리수, 4번이 30여명 정도밖에 없었던 기억이 있습니다. 작년에 비해 대회 4시간 만에 4번, 5번 만점자가 40여명 나왔네요.&lt;/li&gt;
  &lt;li&gt;작년에는 2번부터 DP를 prefix sum으로 최적화하는 등 ‘시간 복잡도를 낮추기 위한 아이디어’ 를 요구했었습니다. 그에 비하면 이번 2번은 그냥 그리디인것도 차이가 명확해 보입니다.&lt;/li&gt;
  &lt;li&gt;저는 체감상 4번이 5번보다 어려웠습니다. 실제 만점자수도 현재 (대회 절반 시점) 127 : 79인데, 보통 4번을 먼저 읽을 것임을 고려할때 이정도면 4번이 5번보다 어렵다고 느낄만한 여지도 충분하다고 생각합니다. 3번과 4번의 차이도 1.5배밖에 안 나네요.&lt;/li&gt;
  &lt;li&gt;재밌었습니다. 다만… 2차를 통과할 수 있을지는 솔직히 자신은 별로 없습니다. 반반 정도 봅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;부록--버퍼-이야기-scpc-주의사항&quot;&gt;부록 : 버퍼 이야기 (SCPC 주의사항)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주의 : 제 컴퓨터구조/시스템 프로그래밍 실력은 매우 미약하기 때문에 올바르지 않은 주장이나 사실이 있을 수 있습니다. 건설적인 피드백을 200% 환영합니다.&lt;/li&gt;
  &lt;li&gt;SCPC의 부분점수 시스템은 굉장히 특이합니다.&lt;/li&gt;
  &lt;li&gt;구체적으로, 문제가 모두 multi-testcase 형으로, 처음에 testcase의 개수 T를 받고 T개의 TC를 해결하는 식입니다. 예를 들어, TC i의 답이 i라고 하면, 다음과 같이 출력합니다.
    &lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Case #1
1
Case #2
2
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;서브태스크 1, 2, 3이 있고, 각각이 TC 10개 씩이라면, 1~10, 11~20, 21~30 이런 식입니다.&lt;/li&gt;
  &lt;li&gt;그래서, 23번 TC가 틀리고 그 전까지 다 맞았다면 서브태스크 1과 2의 점수를 받습니다.&lt;/li&gt;
  &lt;li&gt;여기서 시간 초과가 발생하는 상황을 생각해 보겠습니다. 예를 들어 23번 테스트케이스를 수행하다가 시간 초과가 났습니다. 우리의 직관은 23번 TC가 WA인것과 TLE인 것이 동치이므로, 역시 서브태스크 2에 대한 점수를 받을 것으로 예측할 것입니다.&lt;/li&gt;
  &lt;li&gt;하지만, C언어의 출력은 Buffered I/O이기 때문에, (어떤 이유로든) 17번 TC까지는 출력이 되었지만 18~22번 TC까지의 결과는 아직 버퍼에 들어 있을 수도 있습니다. 즉, “현재까지의 출력” 은 17번 TC까지의 정답을 가지고 있고, “버퍼” 가 18번~22번 TC까지의 정답을 가지고 있는데 TLE가 났으면, SCPC는 버퍼에 든 내용물을 무시하고 17번 TC까지 맞은것으로 간주, 서브태스크 1에 대한 점수만 받을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이러한 문제를 해결하기 위해, SCPC는 printf를 이용하는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setbuf(stdout, NULL)&lt;/code&gt; 할 것을 권하고 있습니다.&lt;/li&gt;
  &lt;li&gt;재밌는 사실은, 저걸 하면 매 printf마다 버퍼를 비우기 때문에, printf할 내용이 많으면 조심해야 합니다. 예를 들어, 5만글자짜리 string을 하나의 string으로 묶어서 출력하는 것에 비해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 를 5만번 호출하는 경우 후자는 버퍼를 5만번 처리하기 때문에 후자는 미친듯이 느립니다.&lt;/li&gt;
  &lt;li&gt;예를 들어, 오늘 2번(이진수) 의 제 코드 중, 이 부분은 시간 초과를 받습니다 ($n$ 은 5만입니다)
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;하지만, 이 부분을 이렇게 바꾸면 매우 넉넉하게 통과합니다.
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;사실 printf를 5만번 호출하면 원래 한번에 찍는것보다 느린게 맞습니다. 그러나, 버퍼를 매번 비우도록 강제하는 setbuf 때문에 원래 느려야 할 것보다 더 많이 느립니다.&lt;/li&gt;
  &lt;li&gt;결과적으로, 부분점수를 받기 위해서는 코드가 더 느려질 위험을 감수해야 합니다. 특히 출력물이 10만줄씩 되는 5번문제 같은 경우, ‘원래 맞을 수 있는 코드를 버퍼 비우다가 TLE나는게 아닌지’ 도 고민해야 합니다.&lt;/li&gt;
  &lt;li&gt;이런 방법으로 채점을 하는 장점에 대해서는 전혀 알지 못합니다. 구글 코드잼도 출력 양식이 거의 같은데, 내부적으로 같은 방법으로 채점하고 있는지도 모릅니다. 다만 이 방법이 절대적인 프로그램의 실행 횟수를 줄여서 채점 속도에는 조금 도움이 될 것 같습니다.&lt;/li&gt;
  &lt;li&gt;여튼, 작년에도 저는 SCPC 2차예선에서 저걸로 한번 당했습니다. 올해도 어김없이 이 이슈로 한번 틀렸기 때문에, 조심해야 할 부분을 같이 공유해보고 싶었습니다.&lt;/li&gt;
  &lt;li&gt;채점이 특이한 대회는 사실 이거 말고도 꽤 있습니다. 대표적으로 해커컵…&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp_rounds" /><category term="algorithms" /><summary type="html">Contents</summary></entry><entry><title type="html">2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1</title><link href="http://localhost:4000/cp_practice/team_practice_1/" rel="alternate" type="text/html" title="2021 UCPC 팀연습 #1 : 서강대학교 2020 Div 1" /><published>2021-07-14T00:00:00+09:00</published><updated>2021-07-14T00:00:00+09:00</updated><id>http://localhost:4000/cp_practice/team_practice_1</id><content type="html" xml:base="http://localhost:4000/cp_practice/team_practice_1/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#our-team&quot; id=&quot;markdown-toc-our-team&quot;&gt;Our Team&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#practice--sogang-2020-div1&quot; id=&quot;markdown-toc-practice--sogang-2020-div1&quot;&gt;Practice : Sogang 2020 Div1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-0--start&quot; id=&quot;markdown-toc-phase-0--start&quot;&gt;Phase 0 : Start&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-1--easy-problems&quot; id=&quot;markdown-toc-phase-1--easy-problems&quot;&gt;Phase 1 : Easy Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#a-파일-정리&quot; id=&quot;markdown-toc-a-파일-정리&quot;&gt;A. 파일 정리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#f-폰친구&quot; id=&quot;markdown-toc-f-폰친구&quot;&gt;F. 폰친구&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#c-연료가-부족해&quot; id=&quot;markdown-toc-c-연료가-부족해&quot;&gt;C. 연료가 부족해&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#b-컨설팅&quot; id=&quot;markdown-toc-b-컨설팅&quot;&gt;B. 컨설팅&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-2--3-graph-problems&quot; id=&quot;markdown-toc-phase-2--3-graph-problems&quot;&gt;Phase 2 : 3 Graph Problems&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#e-사탕-배달&quot; id=&quot;markdown-toc-e-사탕-배달&quot;&gt;E. 사탕 배달&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#d-에어컨-설치&quot; id=&quot;markdown-toc-d-에어컨-설치&quot;&gt;D. 에어컨 설치&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#g-confuzzle&quot; id=&quot;markdown-toc-g-confuzzle&quot;&gt;G. Confuzzle&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phase-3--pizza-madness&quot; id=&quot;markdown-toc-phase-3--pizza-madness&quot;&gt;Phase 3 : Pizza Madness&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#후기&quot; id=&quot;markdown-toc-후기&quot;&gt;후기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;our-team&quot;&gt;Our Team&lt;/h2&gt;
&lt;p&gt;이번 UCPC 팀은 이렇게 구성되게 되었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt; : DGIST에서 석사과정을 올 8월에 마무리하고 졸업합니다. ICPC는 석사 1년차까지, UCPC는 석사과정 (석박통합 2년차까지) 임을 감안하면 사실상 이번 UCPC가 대학생 프로그래밍 대회의 마지막을 장식하게 될 것인지라, 저 개인적으로 매우 영광으로 생각하고 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; : 병특 중에 있습니다. 제 블로그에도 여러번 언급되었지만… 해시코드를 함께하고 있는 Little Piplup 팀으로, 둘이서 1:1 연습을 많이 해봤습니다만 전통적인 CP대회를 같이뛰는건 처음입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세명의 Codeforces max rating은 2100+지만, 저랑 dlwocks는 파킹에 실패해서 퍼플로 낙하했습니다. 퍼플+퍼플+오렌지 팀 정도로 볼 수 있을것 같습니다.&lt;/p&gt;

&lt;p&gt;전력을 잠깐 생각해 보자면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님의 스타일은 제가 잘 모르지만 저랑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;은 동일 레이팅의 2인 팀치고는 아마도 꽤 강할 것 같습니다. 제가 상대적으로 조합/정수를 잘 풀고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;이 자료구조/구현 문제를 잘 풀다 보니… 그래서, 3인팀도 나름대로 스타일은 명확하고 잘 맞는것 같습니다.&lt;/p&gt;

&lt;p&gt;작년에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coffeetea&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diordhd&lt;/code&gt; 팀이 2020 ICPC 예선에서 12등인가 하는 놀라운 성적을 얻었는데, 객관적인 전력은 그 근처 어딘가라고 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;practice--sogang-2020-div1&quot;&gt;Practice : Sogang 2020 Div1&lt;/h2&gt;
&lt;p&gt;3시간 정도밖에 시간이 없어서, 돌만한 셋이 별로 없었습니다. Japan ICPC 예선전 정도가 3시간인데, 난이도가 널뛰기하는데다가 백준에서 푼사람이 아무도 없어서 데이터의 올바름을 확신하기 어렵기도 하고… 
서강대학교 대회는 Div 1 과 Div 2로 나뉘어 있고, 원래는 개인대회 3시간짜리 대회입니다. 난이도가 실-골-플-다 문제가 1-2-3-2로 분포된 형태가 UCPC 예선이랑 비슷할것이라고 판단, 이 대회를 3시간 3PC로 돌아보기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;phase-0--start&quot;&gt;Phase 0 : Start&lt;/h2&gt;
&lt;p&gt;리얼리티를 위해 문제 순서를 shuffle 하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni-gratus907-dlwocks31&lt;/code&gt; 순서로 3 3 2 나눠 읽기로 랬습니다.&lt;/p&gt;

&lt;h2 id=&quot;phase-1--easy-problems&quot;&gt;Phase 1 : Easy Problems&lt;/h2&gt;
&lt;h3 id=&quot;a-파일-정리&quot;&gt;A. 파일 정리&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; (00:07)
‘쉬운 구현문제니까 그냥 잡을게요’ 라고 말하고 7분에 AC를 받아왔습니다. 무슨문제인지 안읽어서 모르겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;f-폰친구&quot;&gt;F. 폰친구&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt; (00:30)&lt;br /&gt;
재밌는 조합 문제였습니다.&lt;br /&gt;
$N$ 명에게 $K$ 개를 나눠주는데 1인당 $m$개 이상 $M$개 이하를 받는 경우의 수를 계산하는 문제입니다. 미리 $m$개씩 나눠주고 시작하면, $L = K - mN$ 개의 사탕을 $N$명에게 나눠주되 각자가 $x = M - m$ 개 이하로만 받는 경우의 수를 세면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저, $x$개 조건이 없다면 답은 중복조합을 이용하여 $_N H _L$ 개입니다. $x$개 조건은 여사건을 이용하여 계산할 수 있습니다. 반대로, ‘누가 $x+1$개 이상을 받을지’ 를 미리 정하고 갑시다. $u$명이 $x+1$개 이상을 받는다면, 미리 얘네들한테 $x+1$개씩 나눠주고 나머지들에게 사탕을 잘 나눠주는 경우를 생각하면 됩니다. 따라서, $_N H _{L - (x+1)u}$ 가 될 것입니다.&lt;/p&gt;

&lt;p&gt;그러나, 이 방법의 문제는 ‘나머지들에게 잘 나눠줄때’ 나머지들 중에 또 $x+1$개 이상을 받는 사람이 있을수도 있다는 것입니다. 이를 포함-배제 원리를 이용하여, 다음과 같이 처리하면 됩니다.
\(\sum_{u = 1}^{n} (-1)^u \times {_N C _u} \times {_N H _{L - (x + 1)u}}\)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;c-연료가-부족해&quot;&gt;C. 연료가 부족해&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt; (00:33, 1WA)&lt;br /&gt;
역시 쉬운문제라고 판단하고 30분 정도 시간에 AC를 받았습니다. DP였다고 합니다. 역시 무슨문제인지 안읽어서 잘 모르겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;b-컨설팅&quot;&gt;B. 컨설팅&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt; (00:58, 1WA)&lt;br /&gt;
쉬운 문제인데 구현이 귀찮아서 조금 시간이 걸렸습니다. 요점은, Greedy하게 정말 필요할때만 WAIT를 걸어주면 된다는 것을 어렵지 않게 알 수 있고, WRITE의 시작점들 / 도착점들 / (시작, 도착)Pair 들을 각각, READ의 대상을 하나. 이렇게 해서 집합들을 관리하고 조건을 잘 그대로 코딩하면 됩니다. 파이썬 썼는데 set같은걸 shallow copy한다는걸 까먹어서 1틀했습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;phase-2--3-graph-problems&quot;&gt;Phase 2 : 3 Graph Problems&lt;/h2&gt;
&lt;h3 id=&quot;e-사탕-배달&quot;&gt;E. 사탕 배달&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt; (00:52, 1WA)&lt;br /&gt;
뭔지 잘 모르겠지만 트리에서 뭔가를 하는 문제입니다. 제가 파이썬 구현으로 싸우고 있는 사이에 팀원 두명이 AC를 받아왔습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;d-에어컨-설치&quot;&gt;D. 에어컨 설치&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt; (01:36)&lt;br /&gt;
문제는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$\Z^3$에 정점들이 뿌려져 있고 거리가 1인 정점들을 ‘인접하다’ 고 정의하여 그래프를 만듭니다.&lt;/li&gt;
  &lt;li&gt;그래프에 ‘에어컨’ 을 설치합니다. 이 에어컨 한 대는 설치한 정점과 그 인접한 정점을 커버합니다.&lt;/li&gt;
  &lt;li&gt;이제, 최소 개수의 에어컨을 달아서 모든 정점을 커버하는 문제입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;제가 B번을 맞고 갔을때는 이미 어느정도 둘이 솔루션을 discuss하고 있었던 중이었습니다. 여기에 같이 아이디어를 구상하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님이 코딩을 바로 들어갔습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;먼저, 어차피 각 connected component별로 생각해야 하므로 그래프가 연결되어 있다고 하겠습니다.&lt;/li&gt;
  &lt;li&gt;이제, 이 문제는 &lt;strong&gt;최소 버텍스 커버&lt;/strong&gt; 와 같은 문제임을 압니다.&lt;/li&gt;
  &lt;li&gt;이 문제는 NP-Complete이지만, 이분 그래프에 대해서는 빨리 풀 수 있음이 알려져 있습니다.&lt;/li&gt;
  &lt;li&gt;$(a, b, c)$ 에 대해, $a + b + c$의 홀짝성에 따라 정점에 색깔을 칠해주면 이 그래프가 이분 그래프임을 보일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;따라서, 이 그래프에서 최소 버텍스 커버를 짜면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저는 이걸 알아도 이분그래프에서 최소 버텍스 커버를 어떻게 짜는지 자신이 없었지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuni&lt;/code&gt;님이 그건 짤수 있다고 확신을 줬기 때문에 (:fan:) 맡기고 저랑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;은 남은 2문제를 잡으러 갔습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;코딩을 맡긴게 대략 01:00 시점쯤이고, 5AC에 1문제는 코딩만 남은 상황이었기 때문에 난이도에 대해 심각한 의심이 있었습니다. 실버 1, 골드 2, 플레 2문제 + 1문제 구상까지를 1시간에 밀었다는것도 그렇지만, 지금까지 문제들 중 플레급이라고 생각이 드는건 A번 정도였기 때문입니다. C번은 제가 직접 문제를 보지 않아서 뭐라고 할수가 없고, F번은 나중에 생각해보면 포함배제 쓰는 조합문제가 익숙하지 않다면 어려울것 같기도 합니다만 그럭저럭 꽤 많이 나온 스타일의 문제였지 않나 싶습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;g-confuzzle&quot;&gt;G. Confuzzle&lt;/h3&gt;
&lt;p&gt;Solve : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gratus907&lt;/code&gt;&lt;br /&gt;
Code : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정점 $n$개의 트리가 주어지고, 각 노드가 $1 \leq c_i \leq n$ 의 색깔을 가집니다. 이때, 색깔이 같은 노드 페어 $v_i, v_j$들 중, 서로의 거리가 가장 가까운 노드 간의 거리를 계산하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;트리에서 두 정점 사이의 거리는 LCA를 이용하면 ($O(n \log n)$ 전처리를 하고) $O(\log n)$에 계산할 수 있습니다. Range Minimum Query를 잘 이용하면 $O(1)$에도 할 수 있음이 알려져 있지만, 실제로 이게 필요한 상황은 본적이 없는것 같습니다.&lt;/li&gt;
  &lt;li&gt;다만, 이때 $O(n^2)$ 개의 pair를 확인해야 하므로, $O(n^2 \log n)$ 시간이 걸리는데, 도저히 답이 없는 복잡도입니다.&lt;/li&gt;
  &lt;li&gt;각 점마다 map에, “이 노드를 루트로 하는 서브트리에서, 색깔이 $c$ 인 노드들 중 이 노드에서 가장 가까운 노드까지의 거리” 를 저장한다고 생각합니다. 이를 $M_i$ 맵이라고 생각하겠습니다.&lt;/li&gt;
  &lt;li&gt;내 자녀 노드의 $M_i$들을 모두 알고 있다면, 이들을 합치는 과정에서 두개 이상의 서브트리가 같은 색깔의 노드를 가지고 있다면 이들까지의 거리를 이용하여 페어의 거리를 계산할 수 있습니다. 이 방법이 최단 거리 페어를 항상 찾을 수 있음은 서브트리에 대해 재귀적으로 증명 가능합니다.&lt;/li&gt;
  &lt;li&gt;그러나, 이 방법은 잘 생각해보면 맵을 합치는 데 $O(n \log n)$ 까지 걸리기 때문에, $O(n^2 \log n)$ 시간이 걸립니다.&lt;/li&gt;
  &lt;li&gt;트리에서 두 Map을 합치는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;small-to-large&lt;/code&gt; 테크닉을 적용 &lt;a href=&quot;/algorithms/BOJ4002/&quot;&gt;(ex : BOJ 4002번 풀이 링크)&lt;/a&gt; 하면, $O(n \log^2 n)$ 시간으로 줄일 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Small to Large 테크닉을 적용하자는 말을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dlwocks31&lt;/code&gt;이 거의 5분만에 했고(:fan:), 10분만에 코딩했으나 사소한 실수로 디버깅에 40분이 걸렸습니다. 무려 $n^2 \log n$ 솔루션을 코딩해서 스트레스테스트로 반례를 찾아야만 했습니다. :(&lt;br /&gt;
별론으로, 정해가 상당히 멋집니다. 각 색깔에 대해 그 색깔의 노드가 몇개 없으면 ($k \leq \sqrt{n}$) $O(k^2 \log k)$ 알고리즘을 돌리고, 노드가 많으면 멀티소스 BFS를 돌리는… sqrt decomp스타일 아이디어였습니다.&lt;br /&gt;
하지만 여전히 dlwocks31의 스몰투라지가 복잡도면에서 더 좋은 풀이일 뿐 아니라, 코딩도 매우 간단합니다. :fan:&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;phase-3--pizza-madness&quot;&gt;Phase 3 : Pizza Madness&lt;/h2&gt;

&lt;p&gt;해결하지 못한 H번에 대한 이야기입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 수열 $A$와 작은 수열 $B$가 주어지고, $A$를 원형으로 연결했을 때 $B$에 해당하는 패턴을 매칭하는 문제입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단, 패턴이 실제로 맞을 필요는 없고, ‘원소들 간의 순서’ 가 맞으면 됩니다. 예를 들어, (4, 3, 6) 과 (2, 1, 3) 을 매칭된 것으로 본다는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다양한 아이디어들이 등장했습니다. 각 수를 좌표압축해서, 좌표압축된 $n$개의 수를 라빈카프처럼 해싱하자는 아이디어라던가…&lt;/li&gt;
  &lt;li&gt;해싱된 수열의 일부를 오른쪽 / 왼쪽으로 미는 연산이 기존의 해싱에서 불가능합니다.&lt;/li&gt;
  &lt;li&gt;미는 부분이 구간을 연산한다는 점에 착안하여 각 노드가 구간의 라빈카프 해시값을 가지고 있는 세그먼트 트리 같은 아이디어가 나오고&lt;/li&gt;
  &lt;li&gt;세그먼트 트리도 중간에 노드를 날리지는 못하기 때문에, 여기에 무슨 스플레이 트리를 써서…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; &lt;strong&gt;이게 될리가 없습니다&lt;/strong&gt;. 그렇게 한시간동안 셋이서 해괴한 트리들을 꺼내다가 연습을 종료했습니다.&lt;br /&gt;
결국 답은 KMP 알고리즘의 변형이던데, 꽤 멋진 문제인것 같네요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;비대면 팀연습이지만 굉장히 재밌었습니다. 배울것도 많았고..ㅋㅋㅋ 특히 작년 ICPC같은경우는 제가 나이로나 PS짬밥으로나 맏이였는데 이번에는 양쪽으로 다 막내인 팀이라서 (?) ㅋㅋㅋ 또 색다른 팀인듯 합니다.&lt;br /&gt;
남은 기간 공부도 재밌게 하고, 무엇보다 대회를 즐길 수 있을 것 같아서 기대가 됩니다.&lt;/p&gt;

&lt;p&gt;Little Piplup을 2명 2명 (저랑 dlwocks / coffeetea와 dhdroid) 먼저 갈라놓고 새 팀원을 찾아보기로 했을때 얘기했던것중 하나가 PS를 즐길수 있었으면 한다는 것이었습니다. 사실 무슨 뉴텔라급이 아닌이상 UCPC는 수상할 수 있는 대회가 아니고, 지금으로써는 예선 통과를 걱정하는 상황도 아니기 때문에 순수하게 문제풀이의 즐거움을 추구하기로 했습니다. 2019년 말~2020년 초에는 정말 PS를 즐겼다고 생각하는데, 그후로 학교공부가 바빠지면서 그러지 못했다가 이제 다시 그때의 마음가짐이 돌아오는것 같아서 개인적으로 굉장히 행복합니다.&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cp_practice" /><summary type="html">Contents</summary></entry><entry><title type="html">논문읽기 : DELTACON</title><link href="http://localhost:4000/cs-adventure/deltacon/" rel="alternate" type="text/html" title="논문읽기 : DELTACON" /><published>2021-07-12T00:00:00+09:00</published><updated>2021-07-12T00:00:00+09:00</updated><id>http://localhost:4000/cs-adventure/deltacon</id><content type="html" xml:base="http://localhost:4000/cs-adventure/deltacon/">&lt;div id=&quot;toc&quot;&gt;
  &lt;p&gt;Contents&lt;/p&gt;
&lt;/div&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;처음으로 정리해볼 논문은 2013년 SDM(SIAM International Conference on Data Mining)에 발표된 DeltaCon입니다.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;두 그래프 $G_1 = (V_1, E_1), G_2 = (V_2, E_2)$ 가 주어졌을 때, 우리는 두 그래프의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유사도&lt;/code&gt; 를 측정하는 어떤 좋은 메트릭을 갖고 싶습니다. 이 메트릭이 있으면&lt;/p&gt;</content><author><name>Wonseok Shin</name><email>gratus907@snu.ac.kr</email></author><category term="cs-adventure" /><category term="graph theory" /><summary type="html">Contents</summary></entry></feed>